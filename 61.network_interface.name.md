# Task #61 - network_interface.name

## Summary

Implemented `network_interface[].name` field in `virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].name`. The field is Required, ForceNew, and directly maps from user input without transformation. Added ForceNew trigger to track all network interface names as a JSON-encoded list.

## Shadow Implementation

```hcl
# In local.body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations
var.orchestrated_virtual_machine_scale_set_network_interface != null ? { # <-
  networkInterfaceConfigurations = [ # <-
    for nic in var.orchestrated_virtual_machine_scale_set_network_interface : { # <-
      name = nic.name # <-
      properties = merge( # <-
        { # <-
          ipConfigurations = [ # <-
            # ... Task #69-86 # <-
          ] # <-
        } # <-
      ) # <-
    } # <-
  ] # <-
} : {} # <-

# In local.replace_triggers_external_values # <-
network_interface_name = { value = var.orchestrated_virtual_machine_scale_set_network_interface != null ? jsonencode([for nic in var.orchestrated_virtual_machine_scale_set_network_interface : nic.name]) : "" } # <-
```

## Create Phase Verification

### Query Create Method

Queried Create method using `query_terraform_block_implementation_source_code` with `entrypoint_name=create`.

### Provider Code Evidence

```go
if v, ok := d.GetOk("network_interface"); ok {
    networkInterfaces, err := ExpandOrchestratedVirtualMachineScaleSetNetworkInterface(v.([]interface{}))
    if err != nil {
        return fmt.Errorf("expanding `network_interface`: %w", err)
    }

    networkProfile.NetworkInterfaceConfigurations = networkInterfaces
    virtualMachineProfile.NetworkProfile = networkProfile
}

// From ExpandOrchestratedVirtualMachineScaleSetNetworkInterface
func ExpandOrchestratedVirtualMachineScaleSetNetworkInterface(input []interface{}) (*[]virtualmachinescalesets.VirtualMachineScaleSetNetworkConfiguration, error) {
    output := make([]virtualmachinescalesets.VirtualMachineScaleSetNetworkConfiguration, 0)

    for _, v := range input {
        raw := v.(map[string]interface{})
        
        // ... other fields ...
        
        config := virtualmachinescalesets.VirtualMachineScaleSetNetworkConfiguration{
            Name: raw["name"].(string),
            Properties: &virtualmachinescalesets.VirtualMachineScaleSetNetworkConfigurationProperties{
                // ... properties ...
            },
        }
        
        output = append(output, config)
    }

    return &output, nil
}

// Assignment to virtual machine profile (single-phase)
props.Properties.VirtualMachineProfile = &virtualMachineProfile
```

### Pattern Identification

**Single-phase Create pattern** - Field is set in the expand function, which is called before `CreateOrUpdateThenPoll`. No two-phase update detected.

### Decision

Field belongs in **Create phase** → Added to `local.body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].name`

## Assignment Path Verification

### Predicted Path

```
body
└── properties
    └── virtualMachineProfile
        └── networkProfile
            └── networkInterfaceConfigurations[]
                └── name
```

### Provider Code Evidence

```go
// From expand function
config := virtualmachinescalesets.VirtualMachineScaleSetNetworkConfiguration{
    Name: raw["name"].(string),
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetNetworkConfigurationProperties{
        // ...
    },
}

// In Create method
networkProfile.NetworkInterfaceConfigurations = networkInterfaces
virtualMachineProfile.NetworkProfile = networkProfile

// Assignment to props
props.Properties.VirtualMachineProfile = &virtualMachineProfile
```

### Verified Path

```
body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].name
```

### Path Comparison

✅ **MATCH** - Predicted path matches the verified assignment path exactly. The `name` field is at the root level of each `VirtualMachineScaleSetNetworkConfiguration` object, not nested under `Properties`.

## Provider Schema

From `OrchestratedVirtualMachineScaleSetNetworkInterfaceSchema()`:

```go
"name": {
    Type:         pluginsdk.TypeString,
    Required:     true,
    ForceNew:     true,
    ValidateFunc: validation.StringIsNotEmpty,
},
```

**Field Properties:**
- Type: String
- Required: true
- ForceNew: true
- ValidateFunc: StringIsNotEmpty

## Azure API Schema

Query: `body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations.name`

Result: `String`

## Hidden Fields

No hidden fields detected. The expand function directly uses `raw["name"].(string)` without any transformation, default, or hardcoded values.

## Mapping

| Terraform Field | Azure API Field | Notes |
|----------------|----------------|-------|
| `network_interface[].name` | `networkInterfaceConfigurations[].name` | Direct string mapping, no transformation |

## Special Handling

### ForceNew

The field has `ForceNew: true` in the provider schema. According to executor.md, we must add it to `replace_triggers_external_values`.

**Implementation Strategy:**
- Since we have a list of network interfaces, we need to track all names
- If any name changes, the resource must be replaced
- Using `jsonencode([for nic in ... : nic.name])` to create a stable string representation of all names
- The key `network_interface_name` is stable (always present)
- The value changes only when the list of names changes

**ForceNew Trigger:**
```hcl
network_interface_name = { value = var.orchestrated_virtual_machine_scale_set_network_interface != null ? jsonencode([for nic in var.orchestrated_virtual_machine_scale_set_network_interface : nic.name]) : "" }
```

**Rationale:**
- When `network_interface` is null, value is empty string (stable)
- When `network_interface` is not null, value is JSON array of names
- Any change to names triggers replacement (adding, removing, or renaming)
- The key is always present (no unstable key issue)

### Validation

The provider schema has `ValidateFunc: validation.StringIsNotEmpty`. This validation must be replicated explicitly.

**CHECKER CORRECTION:** While the Terraform type system enforces non-null via `string` type, it does NOT prevent empty strings `""`. The `StringIsNotEmpty` validation from the provider must be explicitly replicated.

**Implemented validation:**
```hcl
variable "orchestrated_virtual_machine_scale_set_network_interface" {
  # ... type definition ...
  
  validation {
    condition = (
      var.orchestrated_virtual_machine_scale_set_network_interface == null ||
      alltrue([for nic in var.orchestrated_virtual_machine_scale_set_network_interface : nic.name != ""])
    )
    error_message = "The network_interface name must not be empty."
  }
}
```

This validation ensures that:
- When the parent `network_interface` is null, validation passes (handled by parent)
- When the parent is not null, all `name` fields must not be empty strings
- Exact replication of provider's `StringIsNotEmpty` validation

## Critical Review & Edge Case Analysis

### Null Semantics

**Field-level null handling:**
- `name` is Required in the schema → Cannot be null
- Variable type is `string` (not `optional(string)`) → Terraform enforces non-null
- When `network_interface` parent is null, the field is not rendered (handled by parent skeleton)

**Parent-level null handling:**
- When `var.orchestrated_virtual_machine_scale_set_network_interface` is null, entire networkInterfaceConfigurations is omitted (handled by Task #60 skeleton)
- ForceNew trigger uses conditional: `!= null ? jsonencode(...) : ""`
- This ensures stable key with stable value when parent is null

### Boundary Conditions

**Empty string:**
- Provider validation `StringIsNotEmpty` prevents this
- Not applicable as validation is at provider level and Terraform type system ensures non-null

**Empty list:**
- If `network_interface = []` (empty list), the `for` expression produces `[]`
- ForceNew trigger: `jsonencode([]) = "[]"`
- This is valid and stable

**Single vs. multiple interfaces:**
- Single: `jsonencode(["nic1"]) = "[\"nic1\"]"`
- Multiple: `jsonencode(["nic1", "nic2"]) = "[\"nic1\",\"nic2\"]"`
- Order matters (stable as list maintains order)

### Idempotency

**Name stability:**
- Names are user-provided strings
- No provider-side transformation or normalization
- Repeated applies with same input produce identical output

**List order:**
- Terraform maintains list order from configuration
- The `for` expression preserves order
- JSON encoding is deterministic for ordered lists

**ForceNew trigger stability:**
- JSON encoding is deterministic
- Same names in same order always produce same JSON string
- Value only changes when names actually change

### Safe References

**Variable access:**
- Parent null check: `var.orchestrated_virtual_machine_scale_set_network_interface != null`
- Field access: `nic.name` - safe because we're inside the `for` loop which only executes when parent is not null
- Type system guarantees `name` is non-null string

**ForceNew trigger:**
- Conditional ensures we don't iterate when parent is null
- Falls back to empty string when null

### Edge Cases

1. **network_interface is null:**
   - Skeleton conditional omits entire networkInterfaceConfigurations
   - ForceNew trigger value is `""`
   - ✅ Correct: No field rendered, stable trigger

2. **network_interface is empty list []:**
   - `for` produces empty array
   - Result: `networkInterfaceConfigurations = []`
   - ForceNew trigger value is `"[]"`
   - ✅ Correct: Valid API input, stable trigger

3. **Single interface with name "nic-1":**
   - Result: `networkInterfaceConfigurations = [{ name = "nic-1", ... }]`
   - ForceNew trigger value is `"[\"nic-1\"]"`
   - ✅ Correct: Direct mapping

4. **Multiple interfaces with different names:**
   - Result: Each interface gets its own name in array
   - ForceNew trigger captures all names in order
   - ✅ Correct: Maintains order and uniqueness

5. **Changing a name:**
   - Old: `jsonencode(["nic-1", "nic-2"])`
   - New: `jsonencode(["nic-1", "nic-3"])`
   - Trigger detects change → replacement triggered
   - ✅ Correct: ForceNew behavior maintained

6. **Reordering names:**
   - Old: `jsonencode(["nic-1", "nic-2"])`
   - New: `jsonencode(["nic-2", "nic-1"])`
   - Trigger detects change → replacement triggered
   - ✅ Correct: Order matters in Terraform lists, ForceNew ensures consistency

7. **Adding/removing interfaces:**
   - Adding: JSON array grows → trigger changes → replacement
   - Removing: JSON array shrinks → trigger changes → replacement
   - ✅ Correct: Any structural change triggers replacement

## Checklist

- ✅ Field implemented in correct location (parent skeleton created by Task #60)
- ✅ ForceNew wrapped in replace_triggers_external_values with stable key
- ✅ Logic exactly matches provider (direct string mapping from raw["name"])
- ✅ Validation implemented (StringIsNotEmpty replicated - corrected by Checker)
- ✅ No hidden fields (expand function uses raw value directly)
- ✅ Critical review completed (null, edge, idempotent, safe refs)
- ✅ Edge Case Analysis section included
- ✅ Proof document created
- ✅ Ready to update track.md
- ✅ Self-Review: Only implemented `name` field, did not add other network_interface arguments

## Implementation Verification

The implementation exactly replicates provider behavior:
1. ✅ Field is Required → Enforced by variable type `string` (non-optional)
2. ✅ Field is ForceNew → Added to replace_triggers_external_values
3. ✅ Direct mapping → No transformation applied
4. ✅ Validation → StringIsNotEmpty implicitly enforced by Terraform
5. ✅ List handling → ForceNew trigger uses jsonencode to track all names
6. ✅ Stable keys → Key always present, value changes only when names change

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2025-12-04
**Task:** #61 - network_interface.name

### Issues Identified

#### Issue 1: Missing StringIsNotEmpty Validation

**Problem:**
The executor claimed that Terraform's type system with `string` (non-optional) enforces `StringIsNotEmpty`, but this is incorrect. Terraform's `string` type only prevents `null` values, not empty strings `""`. The provider's `validation.StringIsNotEmpty` must be explicitly replicated per executor.md requirements.

**Executor's Reasoning (Incorrect):**
> "The Terraform type system enforces that `name` must be a non-null string. The StringIsNotEmpty validation from the provider provides the same guarantee. No additional validation block is needed in variables.tf."

**Why This Violates executor.md:**
From executor.md Category 1 - Value Constraints:
> **MANDATORY:** Every validation found in the provider schema MUST be implemented in `variables.tf`
> **NO DEFERRAL:** Do NOT defer validations to Azure API checks

**Provider's Actual Behavior:**
```go
"name": {
    Type:         pluginsdk.TypeString,
    Required:     true,
    ForceNew:     true,
    ValidateFunc: validation.StringIsNotEmpty,  // Explicitly prevents empty strings
},
```

**Expected Behavior:**
- User provides `name = ""` → Terraform validation should fail at plan time
- User provides `name = "valid-name"` → Validation passes
- User provides `name = null` → Type system rejects (separate from validation)

**Root Cause:**
Executor confused type-system null checking with validation logic. While `string` type prevents `null`, it does NOT prevent empty strings. The `StringIsNotEmpty` validation is a separate check that must be explicitly replicated.

### Corrections Made

#### Fix 1: Added StringIsNotEmpty Validation

**Changed Files:**
- `variables.tf`: Added validation block to `orchestrated_virtual_machine_scale_set_network_interface` variable
- `61.network_interface.name.md`: Corrected validation section and updated checklist

**New Implementation:**
```hcl
variable "orchestrated_virtual_machine_scale_set_network_interface" {
  type = list(object({
    # ... fields including name = string ...
  }))
  default     = null
  description = <<-EOT
    # ... description ...
  EOT

  validation {
    condition = (
      var.orchestrated_virtual_machine_scale_set_network_interface == null ||
      alltrue([for nic in var.orchestrated_virtual_machine_scale_set_network_interface : nic.name != ""])
    )
    error_message = "The network_interface name must not be empty."
  }
}
```

**Why This is EXACT:**
1. Checks all network interface names when parent is not null
2. Uses `alltrue()` to ensure every name in the list is non-empty
3. Returns appropriate error message matching provider behavior
4. Allows null at parent level (handled by parent conditional)
5. Prevents empty strings at field level (exact replication of `StringIsNotEmpty`)

**Verification:**
- Scenario 1: `network_interface = null` → Validation passes (parent null check) ✅
- Scenario 2: `network_interface = [{ name = "nic1", ... }]` → Validation passes ✅
- Scenario 3: `network_interface = [{ name = "", ... }]` → Validation fails with error ✅
- Scenario 4: `network_interface = [{ name = "nic1", ... }, { name = "", ... }]` → Validation fails ✅
- Edge Case: `network_interface = []` → Validation passes (empty list is valid, alltrue([]) = true) ✅

### Compliance Statement

After corrections, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`:

✅ **ForceNew Logic:** Simple ForceNew correctly implemented with stable key tracking JSON-encoded list of names
✅ **Stable Keys:** Key `network_interface_name` is always present in `replace_triggers_external_values`
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase)
✅ **Type Conversion:** Correct string-to-string mapping
✅ **Null Handling:** Correctly propagates null semantics at parent level
✅ **Validations:** StringIsNotEmpty validation now implemented (corrected)
✅ **Edge Cases:** All edge cases properly analyzed and handled

**Status:** CORRECTED AND APPROVED ✅

---
