# Task #118: os_profile.windows_configuration.hotpatching_enabled

## Summary

Implemented `hotpatching_enabled` field in `windows_configuration` block. This optional boolean field enables Windows hotpatching and maps to Azure API's `patchSettings.enableHotpatching` property. Default value is `false` as per provider schema.

## Shadow Implementation

**variables.tf:**
```hcl
hotpatching_enabled      = optional(bool, false)
```

**migrate_main.tf:**
```hcl
windowsConfiguration = merge(
  {
    enableAutomaticUpdates = var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.enable_automatic_updates
  },
  {
    patchSettings = {
      enableHotpatching = var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.hotpatching_enabled
    }
  },
  # ... other fields
)
```

## Create Phase Verification

**Query:** `query_terraform_block_implementation_source_code(block_type="resource", terraform_type="azurerm_orchestrated_virtual_machine_scale_set", entrypoint_name="create")`

**Pattern Identified:** Single-phase creation

**Field Classification:** Create phase (set before CreateOrUpdateThenPoll call)

**Go Code Evidence:**
```go
// From resourceOrchestratedVirtualMachineScaleSetCreate
if len(winConfigRaw) > 0 && winConfigRaw[0] != nil {
    osType = virtualmachinescalesets.OperatingSystemTypesWindows
    winConfig := winConfigRaw[0].(map[string]interface{})
    // ... other fields ...
    
    // Validate patch mode and hotpatching configuration
    isHotpatchEnabledImage := isValidHotPatchSourceImageReference(sourceImageReferenceRaw, sourceImageId)
    patchMode := winConfig["patch_mode"].(string)
    hotpatchingEnabled := winConfig["hotpatching_enabled"].(bool)
    
    // ... validation logic ...
    
    vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(winConfig, customData)
}

// From expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration
patchSettings.EnableHotpatching = pointer.To(input["hotpatching_enabled"].(bool))
winConfig.PatchSettings = &patchSettings
osProfile.WindowsConfiguration = &winConfig
```

**Decision:** Field is set in Create phase within the initial request body.

## Assignment Path Verification

**Predicted Path:** `properties.virtualMachineProfile.osProfile.windowsConfiguration.patchSettings.enableHotpatching`

**Go Code Evidence:**
```go
// Step 1: expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration returns osProfile
patchSettings.EnableHotpatching = pointer.To(input["hotpatching_enabled"].(bool))
winConfig.PatchSettings = &patchSettings
osProfile.WindowsConfiguration = &winConfig
return &osProfile

// Step 2: Assigned to virtualMachineProfile
virtualMachineProfile.OsProfile = vmssOsProfile

// Step 3: Assigned to props
props.Properties.VirtualMachineProfile = &virtualMachineProfile

// Step 4: API call
client.CreateOrUpdateThenPoll(ctx, id, props, ...)
```

**Verified Path:** `properties.virtualMachineProfile.osProfile.windowsConfiguration.patchSettings.enableHotpatching`

**Path Comparison:** ✅ Match - predicted path is correct

## Provider Schema

**Query:** `query_golang_source_code(symbol="func", name="OrchestratedVirtualMachineScaleSetWindowsConfigurationSchema")`

**Go Source:**
```go
"hotpatching_enabled": {
    Type:     pluginsdk.TypeBool,
    Optional: true,
    Default:  false,
},
```

**Field Properties:**
- Type: Bool
- Optional: true
- Default: false
- ForceNew: false (not specified)
- Sensitive: false
- Computed: false

## Azure API Schema

**Query:** Full resource schema shows:
```
"windowsConfiguration": ObjectWithOptionalAttrs(map[string]Type{
    "patchSettings": ObjectWithOptionalAttrs(map[string]Type{
        "enableHotpatching": Bool,
        // ... other fields
    }, []string{"assessmentMode", "automaticByPlatformSettings", "enableHotpatching", "patchMode"})
}, // ...)
```

**API Property:** `properties.virtualMachineProfile.osProfile.windowsConfiguration.patchSettings.enableHotpatching`

**Type:** Bool (optional)

## Hidden Fields

None. The field is directly exposed in the Terraform schema.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) |
|------------------------|----------------------|
| hotpatching_enabled | enableHotpatching |

## Special Handling

### Defaults

**Implementation:**
```hcl
hotpatching_enabled = optional(bool, false)
```

**Rationale:** Provider schema specifies `Default: false`. Using nested `optional(bool, false)` syntax to apply the default at the object type level as per executor.md guidelines.

### Validations

**Complex validations exist in provider but are NOT implemented:**

The provider has extensive validation logic for hotpatching:

```go
// From Create method
isHotpatchEnabledImage := isValidHotPatchSourceImageReference(sourceImageReferenceRaw, sourceImageId)

if isHotpatchEnabledImage {
    // Validations when using hotpatch-enabled image:
    // 1. patch_mode must be AutomaticByPlatform
    // 2. provision_vm_agent must be true
    // 3. Application health extension required
    // 4. hotpatching_enabled must be true
    
    if patchMode != string(virtualmachinescalesets.WindowsVMGuestPatchModeAutomaticByPlatform) {
        return fmt.Errorf("when using a hotpatching enabled image, `patch_mode` must be set to `%s`", virtualmachinescalesets.WindowsVMGuestPatchModeAutomaticByPlatform)
    }
    
    if !provisionVMAgent {
        return fmt.Errorf("when using a hotpatching enabled image, `provision_vm_agent` must be set to `true`")
    }
    
    if !hasHealthExtension {
        return fmt.Errorf("when using a hotpatching enabled image, an application health extension must be configured")
    }
    
    if !hotpatchingEnabled {
        return fmt.Errorf("when using a hotpatching enabled image, `hotpatching_enabled` must be set to `true`")
    }
} else {
    // Validation when NOT using hotpatch-enabled image
    if hotpatchingEnabled {
        return fmt.Errorf("`hotpatching_enabled` can only be used with supported Windows Server images: '2022-datacenter-azure-edition', '2022-datacenter-azure-edition-core-smalldisk', '2022-datacenter-azure-edition-hotpatch', '2022-datacenter-azure-edition-hotpatch-smalldisk', '2025-datacenter-azure-edition', '2025-datacenter-azure-edition-smalldisk', '2025-datacenter-azure-edition-core', or '2025-datacenter-azure-edition-core-smalldisk'")
    }
}
```

**Why Not Implementing:**

These validations involve:
1. Complex image reference parsing via `isValidHotPatchSourceImageReference()` function
2. Cross-field dependencies with `patch_mode`, `provision_vm_agent`, `source_image_reference`, `source_image_id`
3. Extension configuration checks (`hasHealthExtension`)

**Deferral:** These validations are cross-field validations that require implementation across multiple tasks:
- Task #120 (patch_mode)
- Task #121 (provision_vm_agent)
- Task #18 (source_image_id)
- Task #152-156 (source_image_reference)
- Task #43-56 (extension configuration)

Recording in `following.md` for coordination.

### Update Behavior

**From Update Method:**
```go
if d.HasChange("os_profile.0.windows_configuration.0.hotpatching_enabled") {
    if isHotpatchEnabledImage && !hotpatchingEnabled {
        return fmt.Errorf("when using a hotpatching enabled image, `hotpatching_enabled` must be set to `true`, got `%s`", strconv.FormatBool(hotpatchingEnabled))
    }
    windowsConfig.PatchSettings.EnableHotpatching = pointer.To(hotpatchingEnabled)
}
```

**Key Points:**
- Field is updateable (not ForceNew)
- Validation prevents disabling hotpatching on hotpatch-enabled images
- Update validation also requires complex image checks

**No ForceNew Required:** Field can be updated in place.

## Deferred Work Completion

Checked `following.md` - no work was deferred to this task.

Recording deferred validations:

| Deferred By | Deferred To | Type | Description | Status |
|-------------|-------------|------|-------------|--------|
| #118 | Multiple (#120, #121, #18, #152-156, #43-56) | Validation | Complex hotpatching validations requiring image reference parsing and cross-field checks. Includes: (1) When using hotpatch-enabled images, patch_mode must be AutomaticByPlatform, provision_vm_agent must be true, health extension required, and hotpatching_enabled must be true. (2) When NOT using hotpatch-enabled images, hotpatching_enabled must be false. | Pending |

## Critical Review & Edge Cases

### Edge Case Analysis

**Null Semantics:**
- `null` → Uses default value `false` (handled by `optional(bool, false)`)
- `false` → Explicitly disabled
- `true` → Explicitly enabled

**Boundary Conditions:**
- Boolean field - only two valid values (true/false)
- Default of `false` ensures predictable behavior when not specified

**Idempotency:**
- ✅ Field value is directly assigned
- ✅ Boolean type ensures no order-dependent logic
- ✅ Default value applied consistently

**Safe References:**
- ✅ Field is accessed after null check: `var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration != null`
- ✅ Parent block condition ensures safe access

**Merge Structure:**
- ✅ Nested patchSettings object properly merged
- ✅ Enables future fields (assessmentMode, patchMode) to merge into same patchSettings block
- ✅ Structure matches Azure API requirements

**Complex Validation Notes:**
The provider has complex validations that check if the source image is a hotpatch-enabled image (using pattern matching on image reference). These validations are technically implementable but require:
1. Implementing the `isValidHotPatchSourceImageReference()` logic in Terraform
2. Coordination with tasks that own related fields
3. All dependent fields to be implemented first

This is deferred to allow proper coordination across multiple tasks.

## Checklist

- ✅ Property in correct local (`body.properties.virtualMachineProfile.osProfile.windowsConfiguration.patchSettings.enableHotpatching`)
- ✅ Default value applied (`optional(bool, false)`)
- ✅ No ForceNew required (field is updateable)
- ✅ Complex validations documented and deferred to coordinate with related tasks
- ✅ Hidden fields checked (none)
- ✅ Deferred work: Recorded complex validations in following.md for coordination
- ✅ Deferred work from following.md: None deferred to this task
- ✅ Critical review completed
- ✅ Edge Case Analysis documented
- ✅ Proof created
- ✅ track.md will be updated to "Pending for check"
- ✅ Self-Review: Only implemented hotpatching_enabled field - no fields from other tasks added

## Notes

- This field is part of the `patchSettings` object which will contain three fields total: `assessmentMode` (Task #119), `patchMode` (Task #120), and `enableHotpatching` (this task)
- The patchSettings block structure allows future tasks to merge their fields into the same object
- Complex cross-field validations exist but require coordination with multiple other tasks that own the dependent fields

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #118 - os_profile.windows_configuration.hotpatching_enabled

### Validation Results

✅ **ForceNew Logic:** No ForceNew required - field is updateable per provider's Update method
✅ **Stable Keys:** Not applicable - no ForceNew triggers needed
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase)
✅ **Type Conversion:** Bool type - correctly propagated with no conversion needed
✅ **Null Handling:** Correctly uses `optional(bool, false)` syntax for default value
✅ **Validations:** Complex cross-field validations properly deferred to coordinating tasks and recorded in following.md
✅ **Deferred Work Completion:** No deferred work for this task (checked following.md)
✅ **Deferred Work Recording:** Complex hotpatching validations properly deferred to multiple related tasks with clear descriptions in following.md
✅ **Edge Cases:** All edge cases properly analyzed - null semantics, boundary conditions, merge structure

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The field is correctly:
- Placed in `windowsConfiguration.patchSettings.enableHotpatching` matching Azure API structure
- Defaulted to `false` using the preferred `optional(bool, false)` syntax
- Identified as updateable (not ForceNew) per provider implementation
- Complex validations appropriately deferred with proper documentation

No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
