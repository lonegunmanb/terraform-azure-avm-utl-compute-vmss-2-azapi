# Task #34 - data_disk.caching

## Summary

Implemented the required `caching` argument for the `data_disk` block. This field specifies the type of caching (None, ReadOnly, or ReadWrite) for each data disk in the Virtual Machine Scale Set.

## Shadow Implementation

```hcl
locals {
  body = {
    properties = {
      virtualMachineProfile = {
        storageProfile = {
          dataDisks = [
            for data_disk in var.orchestrated_virtual_machine_scale_set_data_disk : {
              caching = data_disk.caching # <-
            }
          ]
        }
      }
    }
  }
}
```

```hcl
variable "orchestrated_virtual_machine_scale_set_data_disk" {
  type = list(object({
    caching = string # <-
    # ... other fields
  }))
  
  validation { # <-
    condition = ( # <-
      var.orchestrated_virtual_machine_scale_set_data_disk == null || # <-
      alltrue([ # <-
        for disk in var.orchestrated_virtual_machine_scale_set_data_disk : # <-
        contains(["None", "ReadOnly", "ReadWrite"], disk.caching) # <-
      ]) # <-
    ) # <-
    error_message = "The caching must be one of: None, ReadOnly, ReadWrite." # <-
  } # <-
}
```

## Create Phase Verification

**Pattern:** Single-phase creation

**Evidence from Create method:**

```go
if v, ok := d.GetOk("data_disk"); ok {
    ultraSSDEnabled := d.Get("additional_capabilities.0.ultra_ssd_enabled").(bool)
    dataDisks, err := ExpandOrchestratedVirtualMachineScaleSetDataDisk(v.([]interface{}), ultraSSDEnabled)
    if err != nil {
        return fmt.Errorf("expanding `data_disk`: %w", err)
    }
    virtualMachineProfile.StorageProfile.DataDisks = dataDisks
}
```

**Classification:** Create phase - The entire `data_disk` block including the `caching` field is expanded and assigned to `virtualMachineProfile.StorageProfile.DataDisks` before the `CreateOrUpdateThenPoll` call.

**Decision:** Implement in `local.body`

## Assignment Path Verification

**Predicted Path:** `properties.virtualMachineProfile.storageProfile.dataDisks[].caching`

**Tracing Assignment from Expand Function:**

```go
func ExpandOrchestratedVirtualMachineScaleSetDataDisk(input []interface{}, ultraSSDEnabled bool) (*[]virtualmachinescalesets.VirtualMachineScaleSetDataDisk, error) {
    disks := make([]virtualmachinescalesets.VirtualMachineScaleSetDataDisk, 0)
    
    for _, v := range input {
        raw := v.(map[string]interface{})
        
        disk := virtualmachinescalesets.VirtualMachineScaleSetDataDisk{
            Caching: pointer.To(virtualmachinescalesets.CachingTypes(raw["caching"].(string))),
            // ... other fields
        }
        
        disks = append(disks, disk)
    }
    
    return &disks, nil
}
```

**Assignment Chain:**
1. `Caching: pointer.To(virtualmachinescalesets.CachingTypes(raw["caching"].(string)))` → Sets `Caching` field on disk struct
2. `virtualMachineProfile.StorageProfile.DataDisks = dataDisks` → Assigns to `StorageProfile.DataDisks`
3. `props.Properties.VirtualMachineProfile = &virtualMachineProfile` → Wraps in VirtualMachineProfile
4. Final API payload: `properties.virtualMachineProfile.storageProfile.dataDisks[].caching`

**Verified Path:** `properties.virtualMachineProfile.storageProfile.dataDisks[].caching` ✅

**Path Comparison:** Predicted path matches verified path.

## Provider Schema

```go
"caching": {
    Type:     pluginsdk.TypeString,
    Required: true,
    ValidateFunc: validation.StringInSlice([]string{
        string(virtualmachinescalesets.CachingTypesNone),
        string(virtualmachinescalesets.CachingTypesReadOnly),
        string(virtualmachinescalesets.CachingTypesReadWrite),
    }, false),
},
```

**Key Properties:**
- **Type:** String
- **Required:** Yes
- **ForceNew:** No
- **Validation:** Must be one of: `None`, `ReadOnly`, `ReadWrite`
- **Default:** None
- **Computed:** No

## Azure API Schema

**Resource Type:** `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

**Property Path:** `body.properties.virtualMachineProfile.storageProfile.dataDisks[].caching`

**Type:** String (optional in API schema)

**Valid Values:** None, ReadOnly, ReadWrite

**Description:** Specifies the caching requirements for the data disk. This property is for read and write caching of the disk data.

## Hidden Fields

No hidden fields detected. The expand function shows the field is assigned directly without any additional hidden properties or special logic.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|------------------------|----------------------|-------|
| `caching` | `caching` | Direct mapping, same case |

## Special Handling

### Validation

**Provider Validation:** The provider enforces an enum validation requiring the value to be one of `None`, `ReadOnly`, or `ReadWrite`.

**Implementation in variables.tf:**

```hcl
validation {
  condition = (
    var.orchestrated_virtual_machine_scale_set_data_disk == null ||
    alltrue([
      for disk in var.orchestrated_virtual_machine_scale_set_data_disk :
      contains(["None", "ReadOnly", "ReadWrite"], disk.caching)
    ])
  )
  error_message = "The caching must be one of: None, ReadOnly, ReadWrite."
}
```

This validation:
- Allows null for the entire data_disk list
- Validates each disk's caching value when the list is provided
- Uses `alltrue()` to ensure ALL disks have valid caching values
- Replicates the exact provider validation

### ForceNew

**Analysis:** The schema does NOT have `ForceNew: true` for this field, and there is no CustomizeDiff logic affecting it.

**Implementation:** No ForceNew handling required. The field can be updated in-place.

### Sensitive

**Analysis:** Not a sensitive field. It's a simple caching mode setting.

**Implementation:** Field is placed in `local.body`, not `local.sensitive_body`.

## Critical Review & Edge Case Analysis

### Null Semantics
- **Field Level:** The `caching` field is REQUIRED within each data disk object. Users must provide a value.
- **List Level:** The entire `data_disk` list can be null, meaning no data disks are configured.
- **Empty String:** Not possible due to validation - empty string would fail the enum check.

### Boundary Conditions
- **Valid Values:** Validation ensures only "None", "ReadOnly", "ReadWrite" are accepted.
- **Case Sensitivity:** The Azure API enum values use PascalCase format. Provider constants match these exactly.

### Idempotency
- **Direct Assignment:** The field is assigned directly from user input with no transformations.
- **No State Dependencies:** The caching value doesn't depend on any other state or computed values.
- **Array Iteration:** Using `for` expression ensures consistent ordering based on input list order.

### Safe References
- **Null Check:** The parent conditional `var.orchestrated_virtual_machine_scale_set_data_disk != null` protects against null references.
- **Field Access:** `data_disk.caching` is safe because caching is a required field within each disk object.
- **No Nested Access:** Direct field access with no deep nesting.

### Edge Cases Handled
1. **Null data_disk list:** The parent conditional handles this by skipping the entire dataDisks array.
2. **Empty data_disk list:** Results in an empty `dataDisks` array `[]`, which is valid.
3. **Invalid caching value:** Caught by validation block at plan time.
4. **Mixed caching values:** Supported - each disk can have a different caching mode.

### Provider Behavior Match
The implementation exactly replicates provider behavior:
- Required field within data_disk objects
- Enum validation for valid values
- No default value (user must specify)
- Direct assignment with no transformations
- Not ForceNew (can be updated)

## Checklist

- ✅ Property in correct local (`body`)
- ✅ Validation IMPLEMENTED in variables.tf (MANDATORY)
- ✅ Not ForceNew (no wrapping needed)
- ✅ Hidden fields checked (none found)
- ✅ Critical review completed (null, edge, idempotent, safe refs)
- ✅ Edge Case Analysis documented
- ✅ Proof created
- ✅ Logic EXACTLY replicated from provider (no shortcuts)
- ✅ Self-Review: Added ONLY what Task #34 requires (data_disk.caching field)

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-08
**Task:** #34 - data_disk.caching

### Validation Results

✅ **ForceNew Logic:** Not ForceNew (schema shows `ForceNew: false`, no CustomizeDiff logic)
✅ **Stable Keys:** Not applicable (field is not in replace_triggers_external_values)
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase)
✅ **Type Conversion:** Correct - string type preserved from Terraform to Azure API
✅ **Null Handling:** Correctly allows null list, requires caching value in each disk object
✅ **Validations:** MANDATORY validation implemented in variables.tf (enum check for None/ReadOnly/ReadWrite)
✅ **Edge Cases:** All edge cases properly analyzed (null list, empty list, mixed values, invalid values)
✅ **Sensitive Field:** Correctly placed in `local.body` (not sensitive)
✅ **Scope Compliance:** Only Task #34 content added (caching field)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The validation is mandatory and correctly implemented in `variables.tf` using `alltrue()` to validate each disk's caching value. The field is directly assigned without wrapping (not ForceNew), properly nested in the storageProfile.dataDisks array, and handles all edge cases correctly.

**Status:** APPROVED ✅

---
