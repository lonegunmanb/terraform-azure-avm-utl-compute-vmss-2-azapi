# Task #133: os_profile.windows_configuration.winrm_listener.certificate_url

## Summary

Implemented `certificate_url` field within the `winrm_listener` block of Windows configuration. This optional field specifies a Key Vault certificate URL for HTTPS WinRM listeners and is ForceNew (changes require resource replacement).

## Shadow Implementation

### migrate_main.tf - Body (Properties)

```hcl
var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener != null && length(var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener) > 0 ? {
  winRM = {
    listeners = [
      for listener in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener : merge(
        {
          protocol = listener.protocol
        },
        listener.certificate_url != null ? {
          certificateUrl = listener.certificate_url  # <-
        } : {}
      )
    ]
  }
} : {}
```

### migrate_main.tf - Replace Triggers (ForceNew)

```hcl
windows_configuration_winrm_listener_certificate_url = {  # <-
  value = var.orchestrated_virtual_machine_scale_set_os_profile != null && var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration != null && var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener != null ? jsonencode([for listener in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener : listener.certificate_url]) : ""  # <-
}  # <-
```

### variables.tf - Validation

```hcl
validation {  # <-
  condition = (  # <-
    var.orchestrated_virtual_machine_scale_set_os_profile == null ||  # <-
    var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration == null ||  # <-
    var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener == null ||  # <-
    alltrue([  # <-
      for listener in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener :  # <-
      listener.certificate_url == null || (  # <-
        can(regex("^https://[a-zA-Z0-9-]+\\.vault(?:\\.azure\\.net|\\.azure\\.cn|\\.azure\\.us|\\.microsoftonline\\.de)/(?:secrets|certificates)/[a-zA-Z0-9-]+(?:/[a-zA-Z0-9-]+)?$", listener.certificate_url))  # <-
      )  # <-
    ])  # <-
  )  # <-
  error_message = "Each winrm_listener.certificate_url must be a valid Key Vault secret or certificate URL (format: https://<vault-name>.vault.azure.net/secrets/<secret-name> or https://<vault-name>.vault.azure.net/certificates/<cert-name>)."  # <-
}  # <-
```

## Create Phase Verification

**Query Method:** `query_terraform_block_implementation_source_code` with `entrypoint_name=create`

**Pattern:** Single-phase Create

**Go Code Evidence:**

```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    // ...
    osProfileRaw := d.Get("os_profile").([]interface{})
    
    if len(osProfileRaw) > 0 && osProfileRaw[0] != nil {
        osProfile := osProfileRaw[0].(map[string]interface{})
        winConfigRaw = osProfile["windows_configuration"].([]interface{})
        
        if len(winConfigRaw) > 0 && winConfigRaw[0] != nil {
            winConfig := winConfigRaw[0].(map[string]interface{})
            vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(winConfig, customData)
            // ...
        }
        // ...
        virtualMachineProfile.OsProfile = vmssOsProfile
    }
    // ...
    props.Properties.VirtualMachineProfile = &virtualMachineProfile
    
    if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
        return fmt.Errorf("creating Orchestrated %s: %w", id, err)
    }
}
```

**Decision:** Field is assigned in Create phase before the `CreateOrUpdateThenPoll` call → implement in `local.body`

## Assignment Path Verification

**Predicted Path:** `properties.virtualMachineProfile.osProfile.windowsConfiguration.winRM.listeners[].certificateUrl`

**Go Code Trace:**

1. **Create Method:**
```go
props := virtualmachinescalesets.VirtualMachineScaleSet{
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        VirtualMachineProfile: &virtualMachineProfile,  // Assignment 1
    },
}
```

2. **OS Profile Assignment:**
```go
virtualMachineProfile.OsProfile = vmssOsProfile  // Assignment 2
```

3. **Expand Function (expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration):**
```go
func expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(input map[string]interface{}, customData string) *virtualmachinescalesets.VirtualMachineScaleSetOSProfile {
    osProfile := virtualmachinescalesets.VirtualMachineScaleSetOSProfile{}
    winConfig := virtualmachinescalesets.WindowsConfiguration{}
    
    // ...
    winRmListenersRaw := input["winrm_listener"].(*pluginsdk.Set).List()
    winConfig.WinRM = expandWinRMListenerVMSS(winRmListenersRaw)  // Assignment 3
    // ...
    
    osProfile.WindowsConfiguration = &winConfig  // Assignment 4
    return &osProfile
}
```

4. **WinRM Expand Function (expandWinRMListenerVMSS):**
```go
func expandWinRMListenerVMSS(input []interface{}) *virtualmachinescalesets.WinRMConfiguration {
    listeners := make([]virtualmachinescalesets.WinRMListener, 0)
    
    for _, v := range input {
        raw := v.(map[string]interface{})
        
        listener := virtualmachinescalesets.WinRMListener{
            Protocol: pointer.To(virtualmachinescalesets.ProtocolTypes(raw["protocol"].(string))),
        }
        
        certificateUrl := raw["certificate_url"].(string)
        if certificateUrl != "" {
            listener.CertificateURL = pointer.To(certificateUrl)  // Final assignment
        }
        
        listeners = append(listeners, listener)
    }
    
    return &virtualmachinescalesets.WinRMConfiguration{
        Listeners: &listeners,
    }
}
```

**Path Construction:**
- Root: `properties` (from `Properties`)
- Level 1: `virtualMachineProfile` (from `VirtualMachineProfile`)
- Level 2: `osProfile` (from `OsProfile`)
- Level 3: `windowsConfiguration` (from `WindowsConfiguration`)
- Level 4: `winRM` (from `WinRM`)
- Level 5: `listeners` (from `Listeners`)
- Level 6: `certificateUrl` (from `CertificateURL`)

**Verified Path:** `properties.virtualMachineProfile.osProfile.windowsConfiguration.winRM.listeners[].certificateUrl`

**Path Comparison:** ✅ MATCH - Predicted and verified paths are identical

## Provider Schema

**Source:** `internal/services/compute/schema_orchestrated_virtual_machine_scale_set.go`

```go
func winRmListenerSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeSet,
        Optional: true,
        // Whilst the SDK allows you to modify this, the API does not:
        //   Code="PropertyChangeNotAllowed"
        //   Message="Changing property 'windowsConfiguration.winRM.listeners' is not allowed."
        //   Target="windowsConfiguration.winRM.listeners"
        ForceNew: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "protocol": {
                    Type:     pluginsdk.TypeString,
                    Required: true,
                    ForceNew: true,
                    ValidateFunc: validation.StringInSlice([]string{
                        string(virtualmachines.ProtocolTypesHTTP),
                        string(virtualmachines.ProtocolTypesHTTPS),
                    }, false),
                },
                
                "certificate_url": {
                    Type:         pluginsdk.TypeString,
                    Optional:     true,
                    ForceNew:     true,
                    ValidateFunc: keyVaultValidate.NestedItemId,
                },
            },
        },
    }
}
```

**Key Properties:**
- **Type:** `TypeString`
- **Optional:** `true`
- **ForceNew:** `true` (entire winrm_listener block is ForceNew)
- **ValidateFunc:** `keyVaultValidate.NestedItemId` (validates Key Vault secret/certificate URLs)

## Azure API Schema

**Path:** `properties.virtualMachineProfile.osProfile.windowsConfiguration.winRM.listeners[]`

**Schema (from full resource query):**
```
winRM: ObjectWithOptionalAttrs(map[string]Type{
    "listeners": List(ObjectWithOptionalAttrs(map[string]Type{
        "certificateUrl": String,
        "protocol": String
    }, []string{"certificateUrl", "protocol"}))
}, []string{"listeners"})
```

**Key Properties:**
- **Type:** `String`
- **Optional:** Yes (in optional attributes list)
- **API Field Name:** `certificateUrl` (camelCase)

## Hidden Fields

None. The field is explicitly defined in the Terraform schema and directly maps to the Azure API field.

## Mapping

| Terraform Field | Azure API Field |
|----------------|-----------------|
| `certificate_url` | `certificateUrl` |

**Naming Convention:** snake_case → camelCase

## Special Handling

### 1. ForceNew (Required)

**Schema Evidence:**
```go
"certificate_url": {
    Type:         pluginsdk.TypeString,
    Optional:     true,
    ForceNew:     true,  // ← Changes require resource replacement
    ValidateFunc: keyVaultValidate.NestedItemId,
},
```

**Implementation:**
- Added to `replace_triggers_external_values` map
- Tracks certificate_url values for all listeners as JSON-encoded array
- Any change to certificate_url values triggers resource replacement

**Note:** The entire `winrm_listener` block is ForceNew, as noted in the schema comment. This is because the Azure API does not allow modification of the winRM.listeners property after creation.

### 2. Validation (Required)

**Provider Validation:** `keyVaultValidate.NestedItemId`

This validates Key Vault nested item URLs (secrets and certificates). The typical format is:
- Secrets: `https://<vault-name>.vault.azure.net/secrets/<secret-name>[/<version>]`
- Certificates: `https://<vault-name>.vault.azure.net/certificates/<cert-name>[/<version>]`

**Implemented Validation:**
```hcl
validation {
  condition = (
    var.orchestrated_virtual_machine_scale_set_os_profile == null ||
    var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration == null ||
    var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener == null ||
    alltrue([
      for listener in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener :
      listener.certificate_url == null || (
        can(regex("^https://[a-zA-Z0-9-]+\\.vault(?:\\.azure\\.net|\\.azure\\.cn|\\.azure\\.us|\\.microsoftonline\\.de)/(?:secrets|certificates)/[a-zA-Z0-9-]+(?:/[a-zA-Z0-9-]+)?$", listener.certificate_url))
      )
    ])
  )
  error_message = "Each winrm_listener.certificate_url must be a valid Key Vault secret or certificate URL (format: https://<vault-name>.vault.azure.net/secrets/<secret-name> or https://<vault-name>.vault.azure.net/certificates/<cert-name>)."
}
```

**Validation Coverage:**
- ✅ Validates Key Vault URL format
- ✅ Supports all Azure clouds (.azure.net, .azure.cn, .azure.us, .microsoftonline.de)
- ✅ Supports both secrets and certificates paths
- ✅ Supports optional version suffix
- ✅ Allows null values (optional field)

### 3. Conditional Inclusion

**Logic:** Only include `certificateUrl` in the API payload when the value is not null.

**Implementation:**
```hcl
for listener in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener : merge(
  {
    protocol = listener.protocol
  },
  listener.certificate_url != null ? {
    certificateUrl = listener.certificate_url
  } : {}
)
```

This matches the provider's behavior:
```go
certificateUrl := raw["certificate_url"].(string)
if certificateUrl != "" {
    listener.CertificateURL = pointer.To(certificateUrl)
}
```

## Deferred Work Completion

**Check `following.md`:** No work deferred to Task #133.

## Critical Review & Edge Cases

### Edge Case Analysis

1. **Null Semantics:**
   - **Null value:** Field is omitted from API payload (not sent to Azure)
   - **Empty string:** Not possible - validation prevents empty strings
   - **Behavior:** Matches provider exactly

2. **HTTPS Requirement:**
   - Certificate URL is typically required when protocol is "Https"
   - However, provider does NOT enforce this at Terraform level
   - This is left to Azure API validation
   - **Decision:** Follow provider behavior - do not add cross-field validation

3. **URL Validation:**
   - Validates Key Vault URL format
   - Supports multiple Azure cloud endpoints
   - Supports both secrets and certificates
   - Matches provider's `keyVaultValidate.NestedItemId` behavior

4. **ForceNew Behavior:**
   - Any change to certificate_url triggers replacement
   - Entire winrm_listener block is ForceNew
   - Array changes detected via JSON encoding
   - **Critical:** Keys in replace_triggers remain stable (always present)

5. **Multiple Listeners:**
   - Each listener in the set can have different certificate URLs
   - All certificate URLs tracked together as JSON array
   - Change to any certificate URL triggers replacement

6. **Idempotency:**
   - Using `merge()` with conditional inclusion ensures idempotency
   - Field only present when explicitly set
   - No order dependencies in listener array processing

7. **Safe References:**
   - All nested null checks in place before accessing certificate_url
   - Handles null os_profile, windows_configuration, and winrm_listener

## Checklist

- ✅ Property in correct local (`body`)
- ✅ ForceNew wrapped in `replace_triggers_external_values` with stable key
- ✅ All logic EXACTLY replicated from provider (conditional inclusion, ForceNew tracking)
- ✅ Validation IMPLEMENTED in variables.tf (Key Vault URL format)
- ✅ No TODO comments in original field (not a sensitive field migration)
- ✅ Hidden fields checked (none)
- ✅ Deferred work in following.md: Not applicable (no work deferred from this task)
- ✅ Deferred work from following.md: None deferred to this task
- ✅ Critical review completed (null semantics, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis section added
- ✅ Proof created
- ✅ track.md will be updated to "Pending for check"
- ✅ Self-Review: Only certificate_url field implemented, no fields from other tasks added

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #133 - os_profile.windows_configuration.winrm_listener.certificate_url

### Validation Results

✅ **ForceNew Logic:** Simple ForceNew (schema `ForceNew: true`) correctly implemented using Mode 1 - Direct Value Tracking. Key `windows_configuration_winrm_listener_certificate_url` is stable (always present), value wraps jsonencode of certificate_url array to detect any changes.

✅ **Stable Keys:** Key is always present in `replace_triggers_external_values` with empty string when winrm_listener is null.

✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase). Evidence from proof document shows certificate_url is assigned in `expandWinRMListenerVMSS` during Create phase.

✅ **Type Conversion:** Correct handling of optional string field. Uses conditional `merge()` to include `certificateUrl` only when not null.

✅ **Null Handling:** Properly conditional on parent block existence via Task #131 skeleton. Safe null propagation through parent checks. Field omitted from API payload when null (conditional merge pattern).

✅ **Validations:** Validation EXACTLY replicates provider's `keyVaultValidate.NestedItemId` with comprehensive regex covering all Azure clouds, both secrets and certificates, optional version suffix, and null handling.

✅ **Deferred Work Completion:** No deferred work for this task (verified in proof document).

✅ **Deferred Work Recording:** No deferrals made by this task.

✅ **Edge Cases:** Comprehensive edge case analysis in proof document covers null semantics, HTTPS requirement (correctly NOT enforced at Terraform level per provider behavior), URL validation, ForceNew behavior, multiple listeners, idempotency, and safe references.

✅ **Shared Path Merge Check:** No shared path merge issues. The winRM block is constructed once with listeners array inside using conditional merge for certificateUrl field.

✅ **Assignment Path:** Verified path `body.properties.virtualMachineProfile.osProfile.windowsConfiguration.winRM.listeners[].certificateUrl` matches Go code evidence.

✅ **Field Placement:** Correctly placed in `body` (not `sensitive_body`) - certificate_url is not a sensitive field per provider schema.

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The implementation correctly:
- Uses conditional inclusion via `merge()` to match provider's empty string check
- Tracks ForceNew changes using JSON-encoded array of all certificate URLs
- Validates Key Vault URL format covering all Azure cloud endpoints
- Handles null values properly by omitting the field from API payload
- Follows the exact pattern from `expandWinRMListenerVMSS` function

No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
