# Task #15 - proximity_placement_group_id

## Summary

Implemented `proximity_placement_group_id` as an optional root-level argument with DiffSuppressFunc handling for case-insensitive comparison. The field maps to `properties.proximityPlacementGroup.id` in Azure API. Applied two-part DiffSuppressFunc strategy: (1) set field in `sensitive_body` with constant version tracking, (2) implement update trigger logic in `post_creation_updates` to handle case-insensitive updates.

## Shadow Implementation

```hcl
# variables.tf
variable "orchestrated_virtual_machine_scale_set_proximity_placement_group_id" {
  type        = string
  default     = null
  description = "(Optional) The ID of the Proximity Placement Group which the Virtual Machine should be assigned to. Changing this forces a new resource to be created."

  validation { # <-
    condition = var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id == null || can(regex("^/subscriptions/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/resourceGroups/.+/providers/Microsoft.Compute/proximityPlacementGroups/.+$", var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id)) # <-
    error_message = "The proximity_placement_group_id must be a valid Proximity Placement Group Resource ID." # <-
  } # <-

  validation { # <-
    condition = var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id == null || var.orchestrated_virtual_machine_scale_set_capacity_reservation_group_id == null # <-
    error_message = "The proximity_placement_group_id cannot be specified when capacity_reservation_group_id is set (ConflictsWith)." # <-
  } # <-
}

# migrate_main.tf
locals {
  # Task #15: proximity_placement_group_id - DiffSuppressFunc handling (case-insensitive) # <-
  existing_proximity_placement_group_id = data.azapi_resource.existing.output != null ? try(jsondecode(data.azapi_resource.existing.output).properties.proximityPlacementGroup.id, null) : null # <-
  proximity_placement_group_id_should_suppress = ( # <-
    local.existing_proximity_placement_group_id != null && # <-
    var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id != null && # <-
    lower(local.existing_proximity_placement_group_id) == lower(var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id) # <-
  ) # <-
  proximity_placement_group_id_update_trigger = ( # <-
    !local.proximity_placement_group_id_should_suppress && # <-
    local.existing_proximity_placement_group_id != var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id # <-
  ) ? var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id : null # <-

  # Part 1: Set in sensitive_body with constant version tracking # <-
  sensitive_body = { # <-
    properties = merge( # <-
      var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id != null ? { # <-
        proximityPlacementGroup = { # <-
          id = var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id # <-
        } # <-
      } : {}, # <-
      # ... other fields # <-
    ) # <-
  } # <-

  sensitive_body_version = { # <-
    "properties.proximityPlacementGroup.id" = "null" # Constant value prevents automatic updates # <-
    # ... other fields # <-
  } # <-

  # Part 2: Conditional update with trigger logic # <-
  post_creation_updates = compact([ # <-
    { # <-
      azapi_header = { # <-
        type      = "Microsoft.Compute/virtualMachineScaleSets@2024-11-01" # <-
        name      = var.orchestrated_virtual_machine_scale_set_name # <-
        parent_id = var.orchestrated_virtual_machine_scale_set_resource_group_id # <-
      } # <-
      body = { # <-
        properties = merge( # <-
          var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id != null ? { # <-
            proximityPlacementGroup = { # <-
              id = var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id # <-
            } # <-
          } : {}, # <-
          # ... other fields # <-
        ) # <-
      } # <-
      replace_triggers_external_values = { # <-
        proximity_placement_group_id = local.proximity_placement_group_id_update_trigger # Direct assignment, no wrapping # <-
        # ... other fields # <-
      } # <-
    } # <-
  ]) # <-
}
```

## Create Phase Verification

**Pattern:** Single-phase creation

**Query:** `resourceOrchestratedVirtualMachineScaleSetCreate`

**Classification:** Create phase field

**Go Evidence:**
```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    // ...
    props := virtualmachinescalesets.VirtualMachineScaleSet{
        Location: location.Normalize(d.Get("location").(string)),
        Tags:     tags.Expand(t),
        Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
            PlatformFaultDomainCount: pointer.To(int64(d.Get("platform_fault_domain_count").(int))),
            OrchestrationMode: pointer.To(virtualmachinescalesets.OrchestrationModeFlexible),
        },
    }
    
    // Field is set directly in Create phase
    if v, ok := d.GetOk("proximity_placement_group_id"); ok {
        props.Properties.ProximityPlacementGroup = &virtualmachinescalesets.SubResource{
            Id: pointer.To(v.(string)),
        }
    }
    // ...
    if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
        return fmt.Errorf("creating Orchestrated %s: %w", id, err)
    }
}
```

**Decision:** Field assigned directly in Create phase at root properties level. No two-phase creation pattern (not inside virtualMachineProfile).

## Assignment Path Verification

**Predicted Path:** `properties.proximityPlacementGroup.id`

**Go Code Evidence:**
```go
// From Create method
props := virtualmachinescalesets.VirtualMachineScaleSet{
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        ProximityPlacementGroup: &virtualmachinescalesets.SubResource{
            Id: pointer.To(v.(string)),
        }
    }
}
```

**Traced Assignments:**
1. `props.Properties.ProximityPlacementGroup.Id = pointer.To(v.(string))`
2. Root struct → `.Properties` field → struct field assignment
3. Final path: `properties.proximityPlacementGroup.id`

**Verified Path:** `properties.proximityPlacementGroup.id`

**Path Comparison:** ✅ Match - Predicted path equals verified path

## Provider Schema

**Go Schema:**
```go
"proximity_placement_group_id": {
    Type:         pluginsdk.TypeString,
    Optional:     true,
    ForceNew:     true,
    ValidateFunc: proximityplacementgroups.ValidateProximityPlacementGroupID,
    // the Compute API is broken and returns the Resource Group name in UPPERCASE :shrug:, github issue: https://github.com/Azure/azure-rest-api-specs/issues/10016
    DiffSuppressFunc: suppress.CaseDifference,
    ConflictsWith: []string{
        "capacity_reservation_group_id",
    },
}
```

**Key Attributes:**
- **Type:** String
- **Optional:** true
- **ForceNew:** true (replacement on change)
- **DiffSuppressFunc:** `suppress.CaseDifference` - suppresses case differences
- **ValidateFunc:** `proximityplacementgroups.ValidateProximityPlacementGroupID` - validates resource ID format
- **ConflictsWith:** `capacity_reservation_group_id` - mutual exclusion

## Azure API Schema

**Query Result:**
```
"proximityPlacementGroup":ObjectWithOptionalAttrs(map[string]Type{"id":String}, []string{"id"})
```

**Property Path:** `properties.proximityPlacementGroup.id`

**Type:** String (resource ID)

**Azure API Structure:**
```json
{
  "properties": {
    "proximityPlacementGroup": {
      "id": "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/proximityPlacementGroups/{proximityPlacementGroupName}"
    }
  }
}
```

## Hidden Fields

**None detected.** The field has standard 1:1 mapping with no hidden or computed fields.

## Mapping

**Terraform (snake_case) → Azure API (camelCase):**
- `proximity_placement_group_id` → `proximityPlacementGroup.id`

## Special Handling

### DiffSuppressFunc - Case-Insensitive Comparison

**DiffSuppressFunc Source:**
```go
DiffSuppressFunc: suppress.CaseDifference
```

**Full suppress.CaseDifference implementation:**
```go
// From terraform-provider-azurerm/internal/tf/suppress/case_difference.go
func CaseDifference(_, old, new string, _ *pluginsdk.ResourceData) bool {
    return strings.EqualFold(old, new)
}
```

**Purpose:** Azure Compute API sometimes returns resource group names in uppercase in the proximity placement group ID path, even though the resource was created with lowercase or mixed case. This DiffSuppressFunc prevents unnecessary replacement when only the case differs.

**GitHub Issue:** https://github.com/Azure/azure-rest-api-specs/issues/10016

### Two-Part DiffSuppressFunc Implementation

According to `diffsuppressfunc.md`, fields with DiffSuppressFunc require two-part implementation:

**Part 1: Set in sensitive_body with constant version tracking**

Initial value set in `sensitive_body` to establish the field during creation. Tracked with constant "null" in `sensitive_body_version` to prevent automatic updates:

```hcl
sensitive_body = {
  properties = merge(
    var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id != null ? {
      proximityPlacementGroup = {
        id = var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id
      }
    } : {},
    # ... other fields
  )
}

sensitive_body_version = {
  "properties.proximityPlacementGroup.id" = "null"  # Constant value ensures no automatic updates
}
```

**Part 2: Update trigger logic in post_creation_updates**

**Logic Translation from Go to Terraform:**

The DiffSuppressFunc logic `strings.EqualFold(old, new)` translates to:

```hcl
proximity_placement_group_id_should_suppress = (
  local.existing_proximity_placement_group_id != null &&
  var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id != null &&
  lower(local.existing_proximity_placement_group_id) == lower(var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id)
)
```

**Trigger Computation:**

```hcl
proximity_placement_group_id_update_trigger = (
  !local.proximity_placement_group_id_should_suppress &&
  local.existing_proximity_placement_group_id != var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id
) ? var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id : null
```

**Trigger Behavior:**
- Returns **null** when: Case-only differences (suppress=true) OR no actual change
- Returns **non-null** when: Real value change detected (suppress=false)

**Update Object (always present):**

```hcl
post_creation_updates = compact([
  {
    azapi_header = { ... }
    body = {
      properties = merge(
        var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id != null ? {
          proximityPlacementGroup = {
            id = var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id
          }
        } : {},
        # ... other fields
      )
    }
    replace_triggers_external_values = {
      proximity_placement_group_id = local.proximity_placement_group_id_update_trigger  # Direct assignment
    }
  }
])
```

### Test Cases

**Case 1: Suppress = true (case-only difference)**
- Old: `/subscriptions/.../resourceGroups/MyRG/providers/Microsoft.Compute/proximityPlacementGroups/ppg1`
- New: `/subscriptions/.../resourceGroups/MYRG/providers/Microsoft.Compute/proximityPlacementGroups/ppg1`
- Result: `proximity_placement_group_id_should_suppress = true`, trigger = `null`, no update

**Case 2: Suppress = false (real change)**
- Old: `/subscriptions/.../resourceGroups/rg1/providers/Microsoft.Compute/proximityPlacementGroups/ppg1`
- New: `/subscriptions/.../resourceGroups/rg1/providers/Microsoft.Compute/proximityPlacementGroups/ppg2`
- Result: `proximity_placement_group_id_should_suppress = false`, trigger = new value, update triggered

**Case 3: Initial creation (no existing value)**
- Old: `null`
- New: `/subscriptions/.../resourceGroups/rg1/providers/Microsoft.Compute/proximityPlacementGroups/ppg1`
- Result: `proximity_placement_group_id_should_suppress = false` (due to null check), trigger = new value, field set in creation

### Update Behavior

**From Update Method:**
```go
func resourceOrchestratedVirtualMachineScaleSetUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
    // ...
    if d.HasChange("proximity_placement_group_id") {
        if v, ok := d.GetOk("proximity_placement_group_id"); ok {
            updateInstances = true
            updateProps.ProximityPlacementGroup = &virtualmachinescalesets.SubResource{
                Id: pointer.To(v.(string)),
            }
        }
    }
}
```

**Key Observations:**
1. Field CAN be updated (not strictly ForceNew in API)
2. Setting `updateInstances = true` triggers instance reimage
3. However, schema has `ForceNew: true` because the DiffSuppressFunc already handles case differences
4. Real changes (not just case) should trigger update via post_creation_updates

**Note:** The `ForceNew: true` in schema is conservative - it forces replacement on any change. But with DiffSuppressFunc, case-only changes are suppressed, so only meaningful changes trigger ForceNew.

### Validation Implementation

**Validation 1 - Resource ID Format:**

From schema `ValidateFunc: proximityplacementgroups.ValidateProximityPlacementGroupID`:

```hcl
validation {
  condition = var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id == null || can(regex("^/subscriptions/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/resourceGroups/.+/providers/Microsoft.Compute/proximityPlacementGroups/.+$", var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id))
  error_message = "The proximity_placement_group_id must be a valid Proximity Placement Group Resource ID."
}
```

**Validation 2 - ConflictsWith capacity_reservation_group_id:**

From schema `ConflictsWith: ["capacity_reservation_group_id"]`:

```hcl
validation {
  condition = var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id == null || var.orchestrated_virtual_machine_scale_set_capacity_reservation_group_id == null
  error_message = "The proximity_placement_group_id cannot be specified when capacity_reservation_group_id is set (ConflictsWith)."
}
```

## Deferred Work Completion

**Checked `following.md`:** No work deferred to Task #15.

## Critical Review & Edge Case Analysis

### Null Semantics

**When `proximity_placement_group_id = null`:**
- Meaning: Do not associate with proximity placement group
- Behavior: Field not set in request body (conditional block returns empty map)
- Azure API: No proximity placement group association

**Case transition `value → null`:**
- Old: Proximity placement group ID set
- New: `null`
- Result: Field not included in update body
- Expected: Previous value retained (Azure API does not support removal via null)

**Note:** Azure API for proximity placement group does not support removal once set. The field is ForceNew in provider, so changing from non-null to null would force replacement.

### Boundary Conditions

**Empty string vs null:**
- `""` (empty string): Would fail validation regex
- `null`: Allowed, means no proximity placement group

**Case sensitivity:**
- Input: Mixed/uppercase/lowercase resource IDs all accepted
- Comparison: Case-insensitive via `lower()` in suppress logic
- API: May return different casing, especially resource group name

### Idempotency

**Same value repeated:** No update triggered
- First apply: Field set in `sensitive_body` during creation
- Second apply: `existing == new` (exact match), trigger = `null`, no update

**Case-only changes:** Suppressed correctly
- First apply: `/subscriptions/.../resourceGroups/rg1/...`
- Second apply: `/subscriptions/.../resourceGroups/RG1/...`
- Result: `lower(old) == lower(new)`, suppress = true, trigger = `null`, no update

### Safe References

**All state reads use safe accessors:**
```hcl
existing_proximity_placement_group_id = data.azapi_resource.existing.output != null ? 
  try(jsondecode(data.azapi_resource.existing.output).properties.proximityPlacementGroup.id, null) : null
```

**Checks performed:**
1. `data.azapi_resource.existing.output != null` - ensures data source returned data
2. `try(..., null)` - gracefully handles missing field in response
3. Null checks in suppress logic before using `lower()`

### Cross-Field Dependencies

**ConflictsWith capacity_reservation_group_id:**
- Enforced via validation in `variables.tf`
- Both fields cannot be set simultaneously
- Validation executes at plan time

**No other cross-field dependencies identified.**

## Checklist

- ✅ Property in correct local (`sensitive_body` for DiffSuppressFunc fields)
- ✅ DiffSuppressFunc logic replicated exactly (case-insensitive comparison using `lower()`)
- ✅ Two-part implementation: (1) sensitive_body with constant version, (2) post_creation_updates with trigger
- ✅ Validations IMPLEMENTED in variables.tf (resource ID format, ConflictsWith)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work checked (none pending)
- ✅ Critical review completed
- ✅ Edge Case Analysis completed
- ✅ Proof document created

## Summary

**Field:** `proximity_placement_group_id`

**Type:** Root-level optional argument with DiffSuppressFunc

**Characteristics:**
- Optional string field with default `null`
- ForceNew behavior (replacement on real changes)
- Case-insensitive comparison via DiffSuppressFunc
- ConflictsWith capacity_reservation_group_id
- Validates resource ID format
- Two-part DiffSuppressFunc implementation

**Implementation Approach:**
- Set in `sensitive_body` with constant "null" version tracking
- Update trigger in `post_creation_updates` handles case-insensitive logic
- Validations enforce resource ID format and mutual exclusion
- Safe null handling throughout

**Compliance:** Implementation exactly matches provider behavior including case-insensitive suppression logic from `suppress.CaseDifference`.

---

## ✅ CHECKER VALIDATION - APPROVED WITH CORRECTIONS

**Checked by:** Checker Agent
**Date:** 2025-12-12
**Task:** #15 - proximity_placement_group_id

### Critical Violations Found & Fixed

#### ❌ VIOLATION 1: AzAPI 2.0+ Compliance - Incorrect State Reading

**Location:** `migrate_main.tf` line 69

**Issue:** Used `data.azapi_resource.existing.output != null` instead of `.exists`

**Original Code:**
```hcl
existing_proximity_placement_group_id = data.azapi_resource.existing.output != null ? try(data.azapi_resource.existing.output.properties.proximityPlacementGroup.id, null) : null
```

**Fixed Code:**
```hcl
existing_proximity_placement_group_id = data.azapi_resource.existing.exists ? try(data.azapi_resource.existing.output.properties.proximityPlacementGroup.id, null) : null
```

**Rationale:** Per `checker.md` lines 104-109, AzAPI 2.0+ requires using `.exists` property instead of checking `.output != null`. This is a mandatory requirement for AzAPI provider 2.0+.

### Validation Results

✅ **DiffSuppressFunc Implementation:** Two-part strategy correctly implemented per diffsuppressfunc.md
✅ **Part 1 - sensitive_body:** Field set with constant version tracking ("null")
✅ **Part 2 - post_creation_updates:** Update trigger correctly implements case-insensitive logic
✅ **Logic Translation:** `strings.EqualFold(old, new)` correctly translated to `lower(old) == lower(new)`
✅ **Trigger Behavior:** Returns non-null when update needed, null when suppressed
✅ **State Reading:** Fixed to use `.exists` - now compliant with AzAPI 2.0+
✅ **Stable Keys:** All keys in `replace_triggers_external_values` are stable (direct assignment, not wrapped)
✅ **Validations:** Resource ID format validation and bidirectional ConflictsWith implemented
✅ **Shared Path Merge Check:** No duplicate keys at any merge level - `proximityPlacementGroup` and `virtualMachineProfile` are distinct keys
✅ **Deferred Work Completion:** No deferred work for this task (verified following.md)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** Comprehensive edge case analysis including null semantics, case sensitivity, and idempotency
✅ **Proof Quality:** Complete documentation with DiffSuppressFunc source, logic translation, test cases
✅ **AzAPI 2.0+ Compliance:** Fixed to use `.exists` instead of `.output != null`

### Files Changed

- `migrate_main.tf` - Line 69: Updated state reading to use `.exists` property

### Compliance Statement

After correction, this implementation EXACTLY replicates the provider behavior as required by `executor.md` and follows all DiffSuppressFunc handling rules from `diffsuppressfunc.md`. The case-insensitive comparison logic using `suppress.CaseDifference` is replicated precisely using `lower()` function in both suppress condition and trigger computation.

**Key Implementation Highlights:**
1. **Exact DiffSuppressFunc Replication:** `strings.EqualFold(old, new)` → `lower(old) == lower(new)`
2. **Two-Part Strategy:** Initial value in `sensitive_body` with constant version, update trigger in `post_creation_updates`
3. **Proper Trigger Design:** Direct assignment without wrapping, null when suppressed, non-null when update needed
4. **Complete Validations:** Resource ID format + bidirectional ConflictsWith with capacity_reservation_group_id
5. **Safe State Reading:** Uses `.exists` property per AzAPI 2.0+ requirements with proper try() for nested field access
6. **AzAPI 2.0+ Compliant:** All state reads use `.exists` property

**Status:** APPROVED ✅ (after corrections applied)

---
