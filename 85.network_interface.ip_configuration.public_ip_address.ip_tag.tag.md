# Task #85: network_interface.ip_configuration.public_ip_address.ip_tag.tag - Block Argument

## Summary

Implemented the `tag` field within the `ip_tag` block by replacing comment placeholders in all 4 conditional branches. The field maps the Terraform `tag` field directly to Azure API's `tag` field with no transformation. Added validation for StringIsNotEmpty requirement and ForceNew tracking in `replace_triggers_external_values`.

## Shadow Implementation

```hcl
ipTags = [
  for ip_tag in ip_config.public_ip_address[0].ip_tag : {
    tag = ip_tag.tag # <-
    # ipTagType = ... # Task #86
  }
]
```

Added to `replace_triggers_external_values`:
```hcl
public_ip_ip_tag = { # <-
  value = var.orchestrated_virtual_machine_scale_set_network_interface != null ? jsonencode([ # <-
    for nic in var.orchestrated_virtual_machine_scale_set_network_interface : [ # <-
      for ip_config in nic.ip_configuration : ip_config.public_ip_address != null && length(ip_config.public_ip_address) > 0 ? ip_config.public_ip_address[0].ip_tag : null # <-
    ] # <-
  ]) : "" # <-
} # <-
```

Added validation in `variables.tf`:
```hcl
validation { # <-
  condition = ( # <-
    var.orchestrated_virtual_machine_scale_set_network_interface == null || # <-
    alltrue([ # <-
      for nic in var.orchestrated_virtual_machine_scale_set_network_interface : alltrue([ # <-
        for ip_config in nic.ip_configuration : # <-
        ip_config.public_ip_address == null || alltrue([ # <-
          for pub_ip in ip_config.public_ip_address : # <-
          pub_ip.ip_tag == null || alltrue([ # <-
            for ip_tag in pub_ip.ip_tag : # <-
            ip_tag.tag != null && ip_tag.tag != "" # <-
          ]) # <-
        ]) # <-
      ]) # <-
    ]) # <-
  ) # <-
  error_message = "Each IP tag's 'tag' field must not be empty." # <-
} # <-
```

## Create Phase Verification

### Query Result

From Task #84 proof document, the Create method uses a single-phase pattern:

```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    // ... (setup code)
    
    if v, ok := d.GetOk("network_interface"); ok {
        networkInterfaces, err := ExpandOrchestratedVirtualMachineScaleSetNetworkInterface(v.([]interface{}))
        if err != nil {
            return fmt.Errorf("expanding `network_interface`: %w", err)
        }

        networkProfile.NetworkInterfaceConfigurations = networkInterfaces
        virtualMachineProfile.NetworkProfile = networkProfile
    }
    
    // ...
    props.Properties.VirtualMachineProfile = &virtualMachineProfile
    
    if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
        return fmt.Errorf("creating Orchestrated %s: %w", id, err)
    }
}
```

### Create Pattern

**Pattern:** Single-phase create

The resource uses `CreateOrUpdateThenPoll` which is a single-phase creation pattern. The `ip_tag.tag` field is part of the `ip_tag` block expanded via the network interface expansion chain and included in the initial create request.

### Field Phase Classification

**Phase:** Create phase

The `tag` field is:
1. Expanded via `ExpandOrchestratedVirtualMachineScaleSetNetworkInterface` → `expandOrchestratedVirtualMachineScaleSetIPConfiguration` → `expandOrchestratedVirtualMachineScaleSetPublicIPAddress`
2. Set in the `virtualMachineProfile.NetworkProfile` before the create call
3. Sent to the API in the initial `CreateOrUpdateThenPoll` request

**Decision:** Implement in `local.body` (Create phase)

## Assignment Path Verification

### Predicted Path

Based on Azure API schema and parent block structure:
```
body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].properties.ipConfigurations[].properties.publicIPAddressConfiguration.properties.ipTags[].tag
```

### Go Code Evidence

From Task #84, the expand function `expandOrchestratedVirtualMachineScaleSetPublicIPAddress`:

```go
func expandOrchestratedVirtualMachineScaleSetPublicIPAddress(raw map[string]interface{}) *virtualmachinescalesets.VirtualMachineScaleSetPublicIPAddressConfiguration {
    ipTagsRaw := raw["ip_tag"].([]interface{})
    ipTags := make([]virtualmachinescalesets.VirtualMachineScaleSetIPTag, 0)
    for _, ipTagV := range ipTagsRaw {
        ipTagRaw := ipTagV.(map[string]interface{})
        ipTags = append(ipTags, virtualmachinescalesets.VirtualMachineScaleSetIPTag{
            Tag:       pointer.To(ipTagRaw["tag"].(string)), // ← Direct field access: tag
            IPTagType: pointer.To(ipTagRaw["type"].(string)),
        })
    }

    publicIPAddressConfig := virtualmachinescalesets.VirtualMachineScaleSetPublicIPAddressConfiguration{
        Name: raw["name"].(string),
        Properties: &virtualmachinescalesets.VirtualMachineScaleSetPublicIPAddressConfigurationProperties{ // ← .Properties assignment
            IPTags: &ipTags, // ← Assignment to .Properties.IPTags
        },
    }
    
    return &publicIPAddressConfig
}
```

Key observation: The provider accesses `ipTagRaw["tag"].(string)` directly and assigns it to the `Tag` field in the Go struct.

### Verified Path

```
body
└── properties (assigned via props.Properties)
    └── virtualMachineProfile (assigned via props.Properties.VirtualMachineProfile)
        └── networkProfile (assigned via virtualMachineProfile.NetworkProfile)
            └── networkInterfaceConfigurations (assigned via networkProfile.NetworkInterfaceConfigurations)
                └── [array elements]
                    └── properties (assigned via config.Properties)
                        └── ipConfigurations (assigned via config.Properties.IPConfigurations)
                            └── [array elements]
                                └── properties (assigned via ipConfiguration.Properties)
                                    └── publicIPAddressConfiguration (assigned via ipConfiguration.Properties.PublicIPAddressConfiguration)
                                        └── properties (assigned via publicIPAddressConfig.Properties)
                                            └── ipTags (assigned via publicIPAddressConfig.Properties.IPTags)
                                                └── [array elements]
                                                    └── tag (assigned via VirtualMachineScaleSetIPTag.Tag)
```

### Path Comparison

**Match:** ✅ The predicted path matches the verified path exactly.

The assignment chain is:
1. `VirtualMachineScaleSetIPTag.Tag = pointer.To(ipTagRaw["tag"].(string))`
2. `ipTags = append(ipTags, <struct with Tag field>)`
3. `publicIPAddressConfig.Properties.IPTags = &ipTags`
4. (Rest of the chain documented in Task #84)

## Provider Schema

From Task #84 proof document and confirmed by schema query:

```go
"ip_tag": {
    Type:     pluginsdk.TypeList,
    Optional: true,
    ForceNew: true,
    Elem: &pluginsdk.Resource{
        Schema: map[string]*pluginsdk.Schema{
            "tag": {
                Type:         pluginsdk.TypeString,
                Required:     true,
                ForceNew:     true, // ← Field-level ForceNew
                ValidateFunc: validation.StringIsNotEmpty, // ← Validation requirement
            },
            "type": {
                Type:         pluginsdk.TypeString,
                Required:     true,
                ForceNew:     true,
                ValidateFunc: validation.StringIsNotEmpty,
            },
        },
    },
},
```

**Field Properties:**
- **Type:** `TypeString` (Required)
- **ForceNew:** `true` - Any change requires resource replacement
- **Validation:** `validation.StringIsNotEmpty` - Must not be empty string

## Azure API Schema

Query: `body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations.properties.ipConfigurations.properties.publicIPAddressConfiguration.properties.ipTags`

From Task #84:
```
List(ObjectWithOptionalAttrs(map[string]Type{"ipTagType":String, "tag":String}, []string{"ipTagType", "tag"}))
```

**Structure:**
- Array of objects
- Each object contains: `ipTagType`, `tag` (both optional per API schema, but required by Terraform provider schema)
- Field name: `tag` (Terraform) → `tag` (API) - direct mapping, no transformation

## Hidden Fields Check

### Expand Function Analysis

From Task #84, the expand function for IP tags:

```go
ipTagsRaw := raw["ip_tag"].([]interface{})
ipTags := make([]virtualmachinescalesets.VirtualMachineScaleSetIPTag, 0)
for _, ipTagV := range ipTagsRaw {
    ipTagRaw := ipTagV.(map[string]interface{})
    ipTags = append(ipTags, virtualmachinescalesets.VirtualMachineScaleSetIPTag{
        Tag:       pointer.To(ipTagRaw["tag"].(string)), // ← Only user-provided value
        IPTagType: pointer.To(ipTagRaw["type"].(string)),
    })
}
```

### Hidden Fields Result

**NO HIDDEN FIELDS FOUND** - The `tag` field uses only the user-provided value from the Terraform configuration. No hardcoded values, defaults, or transformations are applied.

The provider:
1. Reads `ipTagRaw["tag"].(string)` directly from user input
2. Wraps it with `pointer.To()` to create a pointer
3. Assigns it to the `Tag` field in the Go struct
4. No additional processing, validation logic, or transformation

## Mapping

| Terraform Field | Azure API Field | Transformation |
|----------------|----------------|----------------|
| `ip_tag[].tag` | `ipTags[].tag` | None (direct mapping) |

**Note:** 
- Field name in Terraform: `tag`
- Field name in Azure API: `tag`
- Both use the same lowercase name with no camelCase conversion

## Special Handling

### Validation Implementation

**Requirement:** `ValidateFunc: validation.StringIsNotEmpty`

**Implementation:** Added validation block in `variables.tf`:

```hcl
validation {
  condition = (
    var.orchestrated_virtual_machine_scale_set_network_interface == null ||
    alltrue([
      for nic in var.orchestrated_virtual_machine_scale_set_network_interface : alltrue([
        for ip_config in nic.ip_configuration :
        ip_config.public_ip_address == null || alltrue([
          for pub_ip in ip_config.public_ip_address :
          pub_ip.ip_tag == null || alltrue([
            for ip_tag in pub_ip.ip_tag :
            ip_tag.tag != null && ip_tag.tag != ""
          ])
        ])
      ])
    ])
  )
  error_message = "Each IP tag's 'tag' field must not be empty."
}
```

**Rationale:** 
- The provider schema enforces `StringIsNotEmpty` validation
- We replicate this in Terraform to fail fast at plan time
- Nested loops traverse: network_interface → ip_configuration → public_ip_address → ip_tag → tag field
- Checks both `!= null` and `!= ""` to match StringIsNotEmpty behavior

**Ownership:** This validation is owned by Task #85 (the field that requires the validation) per executor.md rules.

### ForceNew Handling

**Requirement:** Both the block and field are marked `ForceNew: true` in the provider schema.

**Implementation:** Added to `replace_triggers_external_values`:

```hcl
public_ip_ip_tag = {
  value = var.orchestrated_virtual_machine_scale_set_network_interface != null ? jsonencode([
    for nic in var.orchestrated_virtual_machine_scale_set_network_interface : [
      for ip_config in nic.ip_configuration : ip_config.public_ip_address != null && length(ip_config.public_ip_address) > 0 ? ip_config.public_ip_address[0].ip_tag : null
    ]
  ]) : ""
}
```

**Rationale:**
- Track the entire `ip_tag` list (not just `tag` field) because the block itself is ForceNew
- Use `jsonencode()` to serialize the list of objects for change detection
- Changes to any field within `ip_tag` (tag or type) will trigger replacement
- Follows the pattern established by other public IP fields (prefix_id, sku_name, version)

**Mode:** Mode 1 - Direct Value Tracking (wrapping in object with `value` key ensures key stability)

### Integration with Parent Skeleton

The implementation replaces the comment placeholder `# tag = ... # Task #85` in all 4 conditional branches:

1. **Branch 1** (lines ~248-255): When domain_name_label is set
2. **Branch 2** (lines ~270-277): When idle_timeout_in_minutes is set
3. **Branch 3** (lines ~289-296): When public_ip_prefix_id is set
4. **Branch 4** (lines ~303-310): Default branch

Each replacement is identical:
```hcl
tag = ip_tag.tag
```

This direct assignment matches the provider's expand logic: `Tag: pointer.To(ipTagRaw["tag"].(string))`

### Iteration Context

The field is accessed within a `for` expression:
```hcl
for ip_tag in ip_config.public_ip_address[0].ip_tag : {
  tag = ip_tag.tag
  # ipTagType = ... # Task #86
}
```

The iteration variable `ip_tag` represents each element in the `ip_tag` list, and we access its `tag` field directly. This matches the provider's loop:
```go
for _, ipTagV := range ipTagsRaw {
    ipTagRaw := ipTagV.(map[string]interface{})
    ipTags = append(ipTags, virtualmachinescalesets.VirtualMachineScaleSetIPTag{
        Tag: pointer.To(ipTagRaw["tag"].(string)),
        // ...
    })
}
```

## Deferred Work Completion

Checked `following.md` for any work deferred to Task #85: **None found.**

No validation, logic, or implementation was deferred to this task from earlier tasks.

## Critical Review & Edge Case Analysis

### Null Semantics

**Null meaning:** "Do not include this IP tag in the list"

However, due to Terraform's type system:
- The `tag` field is `string` (not `optional(string)`) within the `ip_tag` object
- This means `tag` cannot be null within a defined ip_tag element
- Users must provide a value for `tag` if they include an ip_tag object
- Our validation ensures the value is not empty

**Correctness:** ✅ Matches provider behavior - the provider requires the field and validates it's not empty.

### Edge Cases

1. **Empty string:**
   - Validation prevents empty strings: `ip_tag.tag != ""`
   - Provider schema has `ValidateFunc: validation.StringIsNotEmpty`
   - Our validation replicates this exactly

2. **Null vs empty string:**
   - Type definition (`string` not `optional(string)`) prevents null values within an object
   - Validation catches empty strings
   - Both provider and our implementation reject these cases

3. **No ip_tag objects:**
   - Conditional in parent skeleton handles: `ip_config.public_ip_address[0].ip_tag != null && length(...) > 0`
   - When no ip_tags exist, the entire `ipTags` field is omitted (returns `{}` from conditional)
   - This matches provider behavior when the list is empty

4. **Order preservation:**
   - `for` expression preserves list order
   - Provider uses `append()` which maintains insertion order
   - IP tag order is preserved from input to API request

5. **Special characters:**
   - No special character restrictions in provider schema
   - Azure API accepts any non-empty string for tag value
   - Our implementation passes through values unchanged (no escaping or transformation)

### Idempotency

**Idempotent:** ✅ Yes

- Direct field access with no transformations
- No state-dependent logic
- Deterministic behavior: same input always produces same output
- ForceNew ensures changes are detected consistently

### Safe References

**Safe:** ✅ Yes

- Field access `ip_tag.tag` is safe because:
  1. Parent conditional ensures `ip_tag` is not null and has length > 0
  2. Iteration variable `ip_tag` is guaranteed non-null by Terraform's type system
  3. Field `tag` is required (not optional) so it always exists in valid objects
- No nested object access that could fail on null intermediate values
- Validation provides additional safety by catching empty strings at plan time

### Integration with Provider Logic

The implementation exactly matches the provider's expand logic:

**Provider:**
```go
ipTagRaw := ipTagV.(map[string]interface{})
ipTags = append(ipTags, virtualmachinescalesets.VirtualMachineScaleSetIPTag{
    Tag: pointer.To(ipTagRaw["tag"].(string)),
    // ...
})
```

**Our Implementation:**
```hcl
for ip_tag in ip_config.public_ip_address[0].ip_tag : {
  tag = ip_tag.tag
  // ...
}
```

Both:
1. Iterate over the ip_tag list
2. Access the `tag` field directly from each element
3. Assign the value to the `tag`/`Tag` field without transformation
4. Maintain order and include all elements

### ForceNew Behavior

**Critical:** Any change to `tag` triggers resource replacement.

**Why ForceNew:**
- IP tags are immutable in Azure after public IP creation
- The provider marks both the block and field as `ForceNew: true`
- Our implementation tracks the entire `ip_tag` structure in `replace_triggers_external_values`

**Edge case - Changing order:**
- If user reorders ip_tags in the list, the JSON encoding will change
- This will trigger replacement via `replace_triggers_external_values`
- This is correct behavior - Azure treats ordered lists, and order changes should trigger rebuild

**Edge case - Adding/removing tags:**
- Adding a tag: Changes the JSON-encoded value, triggers replacement ✅
- Removing a tag: Changes the JSON-encoded value, triggers replacement ✅
- Both are correct - IP tags are immutable per Azure API constraints

## Checklist

- ✅ Property in correct local (`local.body` within ipTags array in all 4 branches)
- ✅ ForceNew handling (Added `public_ip_ip_tag` to `replace_triggers_external_values` with stable key wrapping)
- ✅ All logic exactly replicated from provider (Direct field access matches `ipTagRaw["tag"].(string)` pattern)
- ✅ Validations implemented (StringIsNotEmpty validation added to `variables.tf` with nested loops)
- ✅ TODO comments (N/A - not a sensitive field, no independent ephemeral variable needed)
- ✅ Hidden fields checked (None found - uses only user-provided value)
- ✅ Deferred work in following.md (N/A - no work deferred to other tasks)
- ✅ Deferred work from following.md (Checked - none found deferred to Task #85)
- ✅ Critical review (Null semantics, edge cases, idempotency, safe references all analyzed)
- ✅ Edge Case Analysis section included
- ✅ Proof created
- ✅ `track.md` status to be updated to "Pending for check"
- ✅ Self-review: Added ONLY the `tag` field implementation for Task #85, did not implement Task #86 (type field)

## Task Dependencies

**Completed:** Task #84 (parent skeleton) - provided the structure with comment placeholders

**Remaining:** Task #86 (`network_interface.ip_configuration.public_ip_address.ip_tag.type`) - will replace the remaining comment placeholder for the `ipTagType` field

**Independent:** Task #85 and #86 can be executed in any order as they replace independent comment placeholders within the same iteration block.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-09
**Task:** #85 - network_interface.ip_configuration.public_ip_address.ip_tag.tag

### Validation Results

✅ **ForceNew Logic:** Simple ForceNew (schema `ForceNew: true`). Correctly tracked in `replace_triggers_external_values` using Mode 1 (Direct Value Tracking with stable key wrapping). The `public_ip_ip_tag` key tracks the entire `ip_tag` list structure with `jsonencode()`.

✅ **Stable Keys:** The `public_ip_ip_tag` key in `replace_triggers_external_values` is stable - always present, using empty string `""` when condition is false.

✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase). Evidence from Create method shows field is expanded via network interface expansion chain and included in initial `CreateOrUpdateThenPoll` request.

✅ **Type Conversion:** Direct mapping from Terraform `string` to Azure API `string` with no transformation required. Field name is identical in both schemas (`tag` → `tag`).

✅ **Null Handling:** Correctly handles null semantics. Field is required (not optional) within `ip_tag` objects per Terraform type system. Parent conditional ensures safe access: `ip_config.public_ip_address[0].ip_tag != null && length(...) > 0`.

✅ **Validations:** Provider validation `validation.StringIsNotEmpty` correctly replicated in `variables.tf` validation block (lines 782-799). Validation uses nested `alltrue()` loops to traverse the hierarchy and checks both `!= null` and `!= ""` to match StringIsNotEmpty behavior.

✅ **Assignment Path:** Verified path matches exactly:
- Predicted: `body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].properties.ipConfigurations[].properties.publicIPAddressConfiguration.properties.ipTags[].tag`
- Implementation: Matches (confirmed via Go code trace through expand function chain)

✅ **Implementation Replicas Provider Exactly:** Direct field access `tag = ip_tag.tag` matches provider's `Tag: pointer.To(ipTagRaw["tag"].(string))` with no transformation or additional logic.

✅ **Hidden Fields:** None found. Provider uses only user-provided value with no hardcoded values, defaults, or transformations.

✅ **Deferred Work Completion:** No deferred work for this task - checked `following.md`, no entries found for Task #85.

✅ **Deferred Work Recording:** No deferrals made - implementation is self-contained.

✅ **Edge Cases:** All edge cases properly analyzed:
- Empty string: Caught by validation
- Null handling: Type system prevents null within objects
- No ip_tag objects: Handled by parent conditional
- Order preservation: Maintained by `for` expression
- Special characters: No restrictions, passed through unchanged

✅ **All 4 Branches Updated:** Implementation correctly replaces comment placeholder `# tag = ... # Task #85` in all 4 conditional branches (lines 258, 280, 299, 313).

✅ **Integration with Skeleton:** Properly integrated within parent skeleton's `for ip_tag in ip_config.public_ip_address[0].ip_tag` iteration block. Does not interfere with Task #86's placeholder.

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found. The field is:
- Directly mapped with no transformation
- Properly validated with exact StringIsNotEmpty logic
- Correctly tracked for ForceNew with stable keys
- Safely accessed with proper null guards in parent conditionals
- Integrated in all required conditional branches

**Status:** APPROVED ✅

---
