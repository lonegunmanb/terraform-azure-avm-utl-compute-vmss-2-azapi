# Task #58: identity.type - Block Argument Implementation

## Summary

Implemented `identity.type` argument within the existing identity block skeleton in `azapi_header`. The type field is Required and must be set to "UserAssigned" per provider schema validation. This field maps directly to the Azure API identity.type property at root level.

## Shadow Implementation

```hcl
locals {
  azapi_header = merge(
    {
      type      = "Microsoft.Compute/virtualMachineScaleSets@2024-11-01"
      name      = var.orchestrated_virtual_machine_scale_set_name
      location  = var.orchestrated_virtual_machine_scale_set_location
      parent_id = var.orchestrated_virtual_machine_scale_set_resource_group_id
    },
    var.orchestrated_virtual_machine_scale_set_identity != null ? {
      identity = {
        type = var.orchestrated_virtual_machine_scale_set_identity.type # <-
        # identity_ids = ... # Task #59
      }
    } : {}
  )
}
```

```hcl
# variables.tf
variable "orchestrated_virtual_machine_scale_set_identity" {
  type = object({
    identity_ids = set(string)
    type         = string
  })
  default     = null
  description = <<-EOT
 - `identity_ids` - (Required) Specifies a list of User Managed Identity IDs to be assigned to this Windows Virtual Machine Scale Set.
 - `type` - (Required) The type of Managed Identity that should be configured on this Windows Virtual Machine Scale Set. Only possible value is `UserAssigned`.
EOT

  validation { # <-
    condition = ( # <-
      var.orchestrated_virtual_machine_scale_set_identity == null || # <-
      var.orchestrated_virtual_machine_scale_set_identity.type == "UserAssigned" # <-
    ) # <-
    error_message = "The type must be 'UserAssigned'." # <-
  } # <-
}
```

## Create Phase Verification

### Query Result from Create Method

From `resourceOrchestratedVirtualMachineScaleSetCreate`:

```go
if v, ok := d.GetOk("identity"); ok {
    identityExpanded, err := identity.ExpandSystemAndUserAssignedMap(v.([]interface{}))
    if err != nil {
        return fmt.Errorf("expanding `identity`: %w", err)
    }
    props.Identity = identityExpanded
}
```

This code appears in the Create method BEFORE the `client.CreateOrUpdateThenPoll()` call.

### Analysis

**Pattern:** Single-phase creation  
**Field Classification:** Create phase - identity is expanded and set on `props.Identity` before the CreateOrUpdate API call  
**Decision:** Field value goes in `azapi_header.identity` (root level of azapi_resource), specifically the `type` property

## Assignment Path Verification

### Predicted Path

Based on Azure API schema for `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`:
- Root-level property: `identity` (object)
- Child property: `type` (string)

### Go Code Evidence

From Create method:
```go
props.Identity = identityExpanded
```

From the `ExpandSystemAndUserAssignedMap` function:
```go
func ExpandSystemAndUserAssignedMap(input []interface{}) (*SystemAndUserAssignedMap, error) {
    identityType := TypeNone
    identityIds := make(map[string]UserAssignedIdentityDetails, 0)

    if len(input) > 0 {
        raw := input[0].(map[string]interface{})
        typeRaw := raw["type"].(string)
        if typeRaw == string(TypeSystemAssigned) {
            identityType = TypeSystemAssigned
        }
        if typeRaw == string(TypeSystemAssignedUserAssigned) {
            identityType = TypeSystemAssignedUserAssigned
        }
        if typeRaw == string(TypeUserAssigned) {
            identityType = TypeUserAssigned
        }
        // ...
    }

    return &SystemAndUserAssignedMap{
        Type:        identityType,
        IdentityIds: identityIds,
    }, nil
}
```

The `SystemAndUserAssignedMap` struct:
```go
type SystemAndUserAssignedMap struct {
    Type        Type                                   `json:"type" tfschema:"type"`
    PrincipalId string                                 `json:"principalId" tfschema:"principal_id"`
    TenantId    string                                 `json:"tenantId" tfschema:"tenant_id"`
    IdentityIds map[string]UserAssignedIdentityDetails `json:"userAssignedIdentities"`
}
```

The JSON tag `"type"` indicates the field is serialized as `type` in the Azure API request.

### Verified Path

**In azapi_resource:**
- Root level: `identity.type`

**Assignment chain:**
1. Terraform config: `identity.type` (string value from user)
2. Expand function: Maps to `SystemAndUserAssignedMap.Type` field
3. Props assignment: `props.Identity = identityExpanded`
4. API request: Serialized as root-level `identity.type`

### Path Comparison

✅ **Match** - The type field is correctly placed at `identity.type` in azapi_header

## Provider Schema

From `resourceOrchestratedVirtualMachineScaleSet()` schema:

```go
"identity": commonschema.UserAssignedIdentityOptional(),
```

The `commonschema.UserAssignedIdentityOptional()` function:

```go
func UserAssignedIdentityOptional() *schema.Schema {
    return &schema.Schema{
        Type:     schema.TypeList,
        Optional: true,
        MaxItems: 1,
        Elem: &schema.Resource{
            Schema: map[string]*schema.Schema{
                "type": {
                    Type:     schema.TypeString,
                    Required: true,
                    ValidateFunc: validation.StringInSlice([]string{
                        string(identity.TypeUserAssigned),
                    }, false),
                },
                "identity_ids": {
                    Type:     schema.TypeSet,
                    Required: true,
                    Elem: &schema.Schema{
                        Type:         schema.TypeString,
                        ValidateFunc: commonids.ValidateUserAssignedIdentityID,
                    },
                },
            },
        },
    }
}
```

**Key Properties for `type` field:**
- **Type:** TypeString
- **Required:** true (within identity block)
- **Optional:** false
- **ForceNew:** Not specified (defaults to false)
- **Computed:** Not specified (defaults to false)
- **DiffSuppressFunc:** None
- **ValidateFunc:** `validation.StringInSlice([]string{string(identity.TypeUserAssigned)}, false)`

**Validation Details:**
The validation restricts the `type` field to only accept "UserAssigned" value. The constant `identity.TypeUserAssigned` equals the string "UserAssigned".

## Azure API Schema

Resource Type: `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

### Query Result

```
ObjectWithOptionalAttrs(map[string]Type{"type":String, "userAssignedIdentities":Map(EmptyObject)}, []string{"type", "userAssignedIdentities"})
```

**Analysis:**
- The identity object has two properties: `type` and `userAssignedIdentities`
- Both are optional in the API schema (ObjectWithOptionalAttrs)
- `type` is a String type
- Assignment path: Root level `identity.type`

## Hidden Fields

No hidden fields for the `type` property itself. The parent identity object has computed fields (`principalId`, `tenantId`) but these are handled at the block level and are read-only.

## Mapping

### Terraform (snake_case) → Azure API (camelCase)

| Terraform Field | Azure API Field | Notes |
|----------------|-----------------|-------|
| `type` | `type` | No transformation needed - same name in both |

**Value Mapping:**
The provider schema only allows "UserAssigned" as a valid value, which maps directly to the Azure API identity type.

## Special Handling

### Validation Implementation

**Provider Schema Validation:**
```go
ValidateFunc: validation.StringInSlice([]string{
    string(identity.TypeUserAssigned),
}, false),
```

The provider validates that `type` must be exactly "UserAssigned". This validation MUST be replicated in variables.tf.

**Shadow Module Implementation:**
```hcl
validation {
  condition = (
    var.orchestrated_virtual_machine_scale_set_identity == null ||
    var.orchestrated_virtual_machine_scale_set_identity.type == "UserAssigned"
  )
  error_message = "The type must be 'UserAssigned'."
}
```

**Justification for EXACT replication:**
- Uses StringInSlice with only one valid value: "UserAssigned"
- Case-sensitive validation (false parameter = no case insensitivity)
- Error occurs at plan time if user provides invalid value
- Validation placed on parent identity variable (ownership rule)

### No ForceNew Required

**Schema Analysis:**
- No `ForceNew: true` in provider schema for `type` field
- No CustomizeDiff logic affecting identity.type
- Identity updates are supported by Azure API

**Decision:** No entry needed in `replace_triggers_external_values` for identity.type

### No Sensitive Field

The `type` field contains only the identity type string ("UserAssigned"), which is not sensitive information. It goes in `azapi_header` (not `sensitive_body`).

### Placement in azapi_header

The `type` field is placed within the `identity` object in `azapi_header`, which is correct because:
1. Identity is a root-level property in both AzureRM provider and Azure API
2. AzAPI resource design allows `identity` at root level (one of the 5 allowed fields)
3. The identity structure in azapi_resource uses `identity.type` and `identity.identity_ids` syntax

## Deferred Work Completion

Checked `following.md` - file does not exist, no deferred work to complete for this task.

## Critical Review & Edge Case Analysis

### Null Semantics

**Identity block is null:**
- The entire identity object is omitted from Azure API request
- The conditional `var.orchestrated_virtual_machine_scale_set_identity != null ? {...} : {}` handles this
- No type field is sent when identity block is absent

**Type field specifically:**
- Schema marks `type` as Required within the identity block
- If identity block exists, type field MUST be present (enforced by Terraform)
- Cannot be null when identity block is specified

### Empty String

**Validation prevents empty string:**
The validation `var.orchestrated_virtual_machine_scale_set_identity.type == "UserAssigned"` will reject empty strings. Empty strings do not match "UserAssigned", so validation fails at plan time.

### Boundary Conditions

**Single allowed value:**
The provider schema only allows "UserAssigned" as a valid value. This is intentional - the comment in the provider schema states:
```go
// whilst the Swagger defines multiple at this time only UAI is supported
"identity": commonschema.UserAssignedIdentityOptional(),
```

This means even though Azure API potentially supports other identity types (SystemAssigned, SystemAssignedUserAssigned), the AzureRM provider for orchestrated VMSS explicitly restricts to UserAssigned only.

**Our validation exactly matches this restriction.**

### Idempotency

The `type` field is a simple string assignment with a single allowed value. No ordering or comparison issues. Applying the same configuration multiple times produces identical results.

### Safe References

```hcl
var.orchestrated_virtual_machine_scale_set_identity != null ? {
  identity = {
    type = var.orchestrated_virtual_machine_scale_set_identity.type
  }
} : {}
```

**Safety analysis:**
- The null check on the parent block ensures we only access `.type` when the identity object exists
- Within the conditional branch, `.type` is safe because:
  - The object schema defines `type` as a required field
  - Terraform's type system enforces this at validation time
  - If identity block is specified, type field must be present

### Edge Cases

**1. Case sensitivity:**
The validation uses exact string match `== "UserAssigned"`, which is case-sensitive. This matches the provider's `StringInSlice(..., false)` where the second parameter `false` means case-sensitive matching.

**2. Other identity types:**
Even though the Azure API supports "SystemAssigned" and "SystemAssigned, UserAssigned", the provider schema explicitly blocks these for orchestrated VMSS. Our validation replicates this exact restriction.

**3. Type changes:**
Since identity has no ForceNew flag, changing the type value would theoretically be an update. However, since only "UserAssigned" is valid, the type value cannot actually change in practice (it's always "UserAssigned" or the entire identity block is absent).

**4. Identity block presence:**
The parent identity variable is optional (default = null). When absent:
- No identity object in azapi_header
- Type field not evaluated
- No validation errors

When present:
- Identity object included in azapi_header
- Type field is Required by Terraform schema
- Validation ensures type == "UserAssigned"

## Checklist

- ✅ Field placed in correct location (`azapi_header.identity.type`)
- ✅ Value assigned directly from variable (no transformation needed)
- ✅ Validation implemented in variables.tf (MANDATORY - StringInSlice with "UserAssigned" only)
- ✅ Validation EXACTLY matches provider schema
- ✅ No ForceNew required (not in schema or CustomizeDiff)
- ✅ Not a sensitive field (goes in azapi_header, not sensitive_body)
- ✅ Create phase verified (single-phase, Create phase)
- ✅ Assignment path verified (identity.type at root level)
- ✅ Provider schema analyzed (Required, StringInSlice validation)
- ✅ Azure API schema verified (root-level identity.type string)
- ✅ Hidden fields checked (none for this field)
- ✅ Mapping documented (no transformation needed)
- ✅ Deferred work checked (none to complete)
- ✅ Critical review completed with edge case analysis
- ✅ Self-review: Only identity.type field added, no other fields
- ✅ Parent block skeleton exists (Task #57 completed)
- ✅ Comment placeholder replaced in skeleton

---

**Implementation Status:** Complete - Ready for checker validation

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-09
**Task:** #58 - identity.type

### Validation Results

✅ **ForceNew Logic:** No ForceNew required - schema shows no `ForceNew: true`, and identity updates are supported
✅ **Stable Keys:** N/A - no replace_triggers_external_values entry needed
✅ **Phase Detection:** Field correctly placed in `azapi_header.identity.type` (Create phase, root level)
✅ **Type Conversion:** Direct string assignment, no conversion needed
✅ **Null Handling:** Proper null check on parent identity block before accessing `.type` field
✅ **Validations:** Validation EXACTLY replicates provider logic - `StringInSlice([]string{"UserAssigned"}, false)` → `type == "UserAssigned"`
✅ **Deferred Work Completion:** No following.md file exists, no deferred work to complete
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Sensitive Field:** Not sensitive - correctly placed in azapi_header (not sensitive_body)
✅ **Edge Cases:** Comprehensive edge case analysis provided in proof document
✅ **Shared Path Merge:** No shared path issues - identity object only appears once in azapi_header merge

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`:

- **Validation Logic:** The provider restricts identity.type to only "UserAssigned" using `StringInSlice`. The shadow module implements the identical constraint with exact string comparison.
- **Placement:** Correctly placed in `azapi_header.identity` as a root-level field (one of the 5 allowed azapi_resource root fields).
- **Assignment Path:** Correctly traced through provider code: `props.Identity = identityExpanded` serializes to root-level `identity.type` in Azure API.
- **Null Semantics:** Proper handling with conditional merge - identity object only added when parent block is non-null.
- **Error Message:** Clear and matches provider intent ("The type must be 'UserAssigned'").

No deviations, simplifications, or "safer alternatives" were found. The implementation follows the exact method prescribed in executor.md for Type 4 (Block Argument) tasks.

**Status:** APPROVED ✅

---
