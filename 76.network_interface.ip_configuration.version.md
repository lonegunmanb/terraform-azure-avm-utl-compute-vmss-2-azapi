# Task #76: network_interface.ip_configuration.version - Proof Document

## Summary
Implemented the `network_interface.ip_configuration.version` field mapping from `azurerm_orchestrated_virtual_machine_scale_set` to `azapi_resource`. This optional field specifies the Internet Protocol Version (IPv4 or IPv6) for the IP configuration, with a default value of "IPv4". The field maps to `privateIPAddressVersion` in the Azure API and includes validation to prevent IPv6 from being set as a primary IP configuration.

## Shadow Implementation

```hcl
# In migrate_main.tf (lines 201-203)
{
  privateIPAddressVersion = ip_config.version  # <-
# publicIPAddressConfiguration = { # Task #77-86
```

```hcl
# In variables.tf - Validation blocks added after line 686
validation {
  condition = (  # <-
    var.orchestrated_virtual_machine_scale_set_network_interface == null ||  # <-
    alltrue([  # <-
      for nic in var.orchestrated_virtual_machine_scale_set_network_interface : alltrue([  # <-
        for ip_config in nic.ip_configuration :  # <-
        ip_config.version == null || contains(["IPv4", "IPv6"], ip_config.version)  # <-
      ])  # <-
    ])  # <-
  )  # <-
  error_message = "The version must be either 'IPv4' or 'IPv6'."  # <-
}  # <-

validation {  # <-
  condition = (  # <-
    var.orchestrated_virtual_machine_scale_set_network_interface == null ||  # <-
    alltrue([  # <-
      for nic in var.orchestrated_virtual_machine_scale_set_network_interface : alltrue([  # <-
        for ip_config in nic.ip_configuration :  # <-
        !(ip_config.primary == true && ip_config.version == "IPv6")  # <-
      ])  # <-
    ])  # <-
  )  # <-
  error_message = "An IPv6 Primary IP Configuration is unsupported - instead add a IPv4 IP Configuration as the Primary and make the IPv6 IP Configuration the secondary."  # <-
}  # <-
```

## Create Phase Verification

### Query Method
Queried Create method using:
```
query_terraform_block_implementation_source_code(
  block_type="resource",
  entrypoint_name="create",
  terraform_type="azurerm_orchestrated_virtual_machine_scale_set"
)
```

### Pattern Identification
**Single-phase pattern** - The field is set during the initial resource creation in the Create method.

### Go Code Evidence
From `resourceOrchestratedVirtualMachineScaleSetCreate`:

```go
if v, ok := d.GetOk("network_interface"); ok {
    networkInterfaces, err := ExpandOrchestratedVirtualMachineScaleSetNetworkInterface(v.([]interface{}))
    if err != nil {
        return fmt.Errorf("expanding `network_interface`: %w", err)
    }

    networkProfile.NetworkInterfaceConfigurations = networkInterfaces
    virtualMachineProfile.NetworkProfile = networkProfile
}
```

The field is part of the network interface configuration which is expanded and assigned to `virtualMachineProfile.NetworkProfile` before the create call:

```go
if !isLegacy {
    props.Properties.VirtualMachineProfile = &virtualMachineProfile
}

log.Printf("[DEBUG] Creating Orchestrated %s.", id)
if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

### Classification
**Create phase** - The field is set before the `CreateOrUpdateThenPoll` call, so it belongs in `local.body`.

### Decision
Implement in `local.body` within the ip_configuration properties structure.

## Assignment Path Verification

### Predicted Path
Based on the resource structure:
```
body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].properties.ipConfigurations[].properties.privateIPAddressVersion
```

### Go Code Evidence - Tracing Assignments

**1. Initial expansion in Create method:**
```go
networkProfile := &virtualmachinescalesets.VirtualMachineScaleSetNetworkProfile{
    NetworkApiVersion: pointer.To((virtualmachinescalesets.NetworkApiVersion)(d.Get("network_api_version").(string))),
}

if v, ok := d.GetOk("network_interface"); ok {
    networkInterfaces, err := ExpandOrchestratedVirtualMachineScaleSetNetworkInterface(v.([]interface{}))
    if err != nil {
        return fmt.Errorf("expanding `network_interface`: %w", err)
    }

    networkProfile.NetworkInterfaceConfigurations = networkInterfaces
    virtualMachineProfile.NetworkProfile = networkProfile
}
```

**2. Network interface expansion:**
```go
func ExpandOrchestratedVirtualMachineScaleSetNetworkInterface(input []interface{}) (*[]virtualmachinescalesets.VirtualMachineScaleSetNetworkConfiguration, error) {
    output := make([]virtualmachinescalesets.VirtualMachineScaleSetNetworkConfiguration, 0)

    for _, v := range input {
        raw := v.(map[string]interface{})
        
        ipConfigurations := make([]virtualmachinescalesets.VirtualMachineScaleSetIPConfiguration, 0)
        ipConfigurationsRaw := raw["ip_configuration"].([]interface{})
        for _, configV := range ipConfigurationsRaw {
            configRaw := configV.(map[string]interface{})
            ipConfiguration, err := expandOrchestratedVirtualMachineScaleSetIPConfiguration(configRaw)
            if err != nil {
                return nil, err
            }

            ipConfigurations = append(ipConfigurations, *ipConfiguration)
        }

        config := virtualmachinescalesets.VirtualMachineScaleSetNetworkConfiguration{
            Name: raw["name"].(string),
            Properties: &virtualmachinescalesets.VirtualMachineScaleSetNetworkConfigurationProperties{
                // ...
                IPConfigurations: ipConfigurations,
                // ...
            },
        }
        
        output = append(output, config)
    }

    return &output, nil
}
```

**3. IP configuration expansion with version field:**
```go
func expandOrchestratedVirtualMachineScaleSetIPConfiguration(raw map[string]interface{}) (*virtualmachinescalesets.VirtualMachineScaleSetIPConfiguration, error) {
    // ...
    primary := raw["primary"].(bool)
    version := virtualmachinescalesets.IPVersion(raw["version"].(string))
    if primary && version == virtualmachinescalesets.IPVersionIPvSix {
        return nil, fmt.Errorf("an IPv6 Primary IP Configuration is unsupported - instead add a IPv4 IP Configuration as the Primary and make the IPv6 IP Configuration the secondary")
    }

    ipConfiguration := virtualmachinescalesets.VirtualMachineScaleSetIPConfiguration{
        Name: raw["name"].(string),
        Properties: &virtualmachinescalesets.VirtualMachineScaleSetIPConfigurationProperties{
            Primary:                               pointer.To(primary),
            PrivateIPAddressVersion:               pointer.To(version),  // <-- Field assigned here
            ApplicationGatewayBackendAddressPools: applicationGatewayBackendAddressPoolIds,
            ApplicationSecurityGroups:             applicationSecurityGroupIds,
            LoadBalancerBackendAddressPools:       loadBalancerBackendAddressPoolIds,
        },
    }
    // ...
    return &ipConfiguration, nil
}
```

**4. Final assignment to props:**
```go
virtualMachineProfile := virtualmachinescalesets.VirtualMachineScaleSetVMProfile{
    StorageProfile: &virtualmachinescalesets.VirtualMachineScaleSetStorageProfile{},
}
// ... networkProfile setup with NetworkInterfaceConfigurations ...
virtualMachineProfile.NetworkProfile = networkProfile

// ...
props := virtualmachinescalesets.VirtualMachineScaleSet{
    // ...
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        // ...
    },
}

if !isLegacy {
    props.Properties.VirtualMachineProfile = &virtualMachineProfile
}
```

### Verified Path
```
body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].properties.ipConfigurations[].properties.privateIPAddressVersion
```

### Path Comparison
**Result: MATCH** ✅

The traced path matches the predicted path exactly. The field flows through:
1. `expandOrchestratedVirtualMachineScaleSetIPConfiguration` → `Properties.PrivateIPAddressVersion`
2. Added to `IPConfigurations` array in network configuration `Properties`
3. Network configuration added to `NetworkInterfaceConfigurations`
4. Assigned to `virtualMachineProfile.NetworkProfile`
5. Finally assigned to `props.Properties.VirtualMachineProfile`

## Provider Schema

From `orchestratedVirtualMachineScaleSetIPConfigurationSchema()`:

```go
"version": {
    Type:     pluginsdk.TypeString,
    Optional: true,
    Default:  string(virtualmachinescalesets.IPVersionIPvFour),
    ValidateFunc: validation.StringInSlice([]string{
        string(virtualmachinescalesets.IPVersionIPvFour),
        string(virtualmachinescalesets.IPVersionIPvSix),
    }, false),
},
```

**Key attributes:**
- **Type:** String
- **Optional:** true
- **Required:** false
- **ForceNew:** false (not specified, so updates are allowed)
- **Default:** "IPv4" (IPVersionIPvFour)
- **ValidateFunc:** Must be "IPv4" or "IPv6"

## Azure API Schema

**Field path:** `properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].properties.ipConfigurations[].properties.privateIPAddressVersion`

**API field name:** `privateIPAddressVersion`

The Azure API schema uses camelCase naming where the Terraform field `version` maps to `privateIPAddressVersion` in the API.

## Hidden Fields

No hidden fields detected for this argument. The field has a straightforward one-to-one mapping from Terraform to Azure API.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|------------------------|----------------------|-------|
| `version` | `privateIPAddressVersion` | Optional field with default "IPv4" |

## Special Handling

### 1. Default Value
The provider schema specifies a default value of "IPv4" which is replicated using the PREFERRED method from executor.md:

**Variable Definition (variables.tf line 548):**
```hcl
version = optional(string, "IPv4")
```

This uses the `optional(type, default)` syntax for nested objects, which is the PREFERRED method over the fallback `coalesce()` approach. The Terraform type system ensures that when `version` is null, the default "IPv4" is automatically applied.

**Implementation (migrate_main.tf line 202):**
```hcl
privateIPAddressVersion = ip_config.version
```

No `coalesce()` is needed because the default is already handled by the `optional()` modifier in the type definition, matching the provider's behavior exactly.

### 2. Validation - Enum Values
Implemented validation to ensure the value is either "IPv4" or "IPv6":
```hcl
validation {
  condition = (
    var.orchestrated_virtual_machine_scale_set_network_interface == null ||
    alltrue([
      for nic in var.orchestrated_virtual_machine_scale_set_network_interface : alltrue([
        for ip_config in nic.ip_configuration :
        ip_config.version == null || contains(["IPv4", "IPv6"], ip_config.version)
      ])
    ])
  )
  error_message = "The version must be either 'IPv4' or 'IPv6'."
}
```

This replicates the provider's `StringInSlice` validation.

### 3. Cross-Field Validation (Deferred from Task #74)
Implemented validation to prevent IPv6 from being set as a primary IP configuration:
```hcl
validation {
  condition = (
    var.orchestrated_virtual_machine_scale_set_network_interface == null ||
    alltrue([
      for nic in var.orchestrated_virtual_machine_scale_set_network_interface : alltrue([
        for ip_config in nic.ip_configuration :
        !(ip_config.primary == true && ip_config.version == "IPv6")
      ])
    ])
  )
  error_message = "An IPv6 Primary IP Configuration is unsupported - instead add a IPv4 IP Configuration as the Primary and make the IPv6 IP Configuration the secondary."
}
```

**Evidence from provider expand function:**
```go
primary := raw["primary"].(bool)
version := virtualmachinescalesets.IPVersion(raw["version"].(string))
if primary && version == virtualmachinescalesets.IPVersionIPvSix {
    return nil, fmt.Errorf("an IPv6 Primary IP Configuration is unsupported - instead add a IPv4 IP Configuration as the Primary and make the IPv6 IP Configuration the secondary")
}
```

This exactly replicates the provider's validation logic, ensuring users get the same error at plan time rather than during apply.

## Deferred Work Completion

### Work Deferred FROM Task #74
From `following.md`:

| Deferred By | Deferred To | Type | Description | Status |
|-------------|-------------|------|-------------|--------|
| #74 | #76 | Validation | Cross-field validation: When primary is true, version cannot be IPv6. Error message: "an IPv6 Primary IP Configuration is unsupported - instead add a IPv4 IP Configuration as the Primary and make the IPv6 IP Configuration the secondary" | ✅ Completed |

**Implementation:** Added validation block in `variables.tf` (shown in Special Handling section above) that implements the exact logic from the provider's expand function.

**Status Updated:** Changed from "Pending" to "✅ Completed" in `following.md`.

### Work Deferred TO Other Tasks
No work deferred to other tasks from this task.

## Critical Review & Edge Case Analysis

### Null Semantics
- **When version is null:** The `optional(string, "IPv4")` type modifier ensures the default value "IPv4" is applied, matching the provider's default behavior
- **When version is empty string:** Would fail enum validation, consistent with provider behavior
- **Idempotency:** The default value application is consistent across applies via the type system

### Edge Cases

1. **IPv6 as Primary IP Configuration**
   - **Scenario:** User sets `primary = true` and `version = "IPv6"`
   - **Handling:** Validation blocks this at plan time with the exact error message from the provider
   - **Safety:** Prevents resource creation failure

2. **Case Sensitivity**
   - **Scenario:** User provides "ipv4" instead of "IPv4"
   - **Handling:** The enum validation will reject it, matching provider behavior
   - **Note:** Azure API is case-sensitive for these values

3. **Default Value with Explicit null**
   - **Scenario:** User explicitly sets `version = null` in Terraform
   - **Handling:** `optional(string, "IPv4")` type modifier applies default
   - **Result:** Correct default "IPv4" is applied by the type system

4. **Multiple IP Configurations Mix**
   - **Scenario:** Multiple IP configurations with different versions (one IPv4 primary, one IPv6 secondary)
   - **Handling:** Each IP configuration is processed independently with its own version value
   - **Safety:** Validation ensures primary is never IPv6

### Boundary Conditions
- **Empty network_interface list:** No IP configurations to process, validation passes
- **Missing version field:** Default "IPv4" is applied via coalesce
- **All validations:** Properly handle null parent objects with null-check conditions

### Safe References
All references use safe navigation:
- `ip_config.version` - safely accessed within iteration
- `ip_config.primary` - checked in validation condition
- Null checks at parent level prevent errors when network_interface is null

## Checklist

- ✅ Property in correct local (`local.body`)
- ✅ Default value replicated using PREFERRED method (`optional(string, "IPv4")` in variable definition)
- ✅ Validation for enum values implemented in `variables.tf`
- ✅ Cross-field validation for primary + IPv6 implemented in `variables.tf`
- ✅ No ForceNew required (field not marked as ForceNew in schema)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work from following.md completed (Task #74 validation)
- ✅ Critical review completed (null semantics, edge cases, safe references)
- ✅ Edge Case Analysis documented
- ✅ Proof created with all required sections
- ✅ Track.md will be updated to "Pending for check"
- ✅ Implementation exactly matches provider behavior
- ✅ Method priority followed: Used optional() modifier (PREFERRED) instead of coalesce() (Fallback)

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2025-12-09
**Task:** #76 - network_interface.ip_configuration.version

### Issues Identified

#### Issue 1: Proof Document Inaccuracy

**Problem:**
The proof document's "Shadow Implementation" section (line 11) incorrectly documented the implementation as using `coalesce(ip_config.version, "IPv4")`, but the actual code implementation uses `ip_config.version` without coalesce.

**Executor's Original Documentation:**
```hcl
privateIPAddressVersion = coalesce(ip_config.version, "IPv4")  # <-
```

**Actual Implementation (migrate_main.tf line 202):**
```hcl
privateIPAddressVersion = ip_config.version
```

**Why This Matters:**
While the actual implementation is CORRECT, the proof document was misleading and did not accurately reflect what was implemented. This creates confusion and makes validation difficult.

**Provider's Actual Behavior:**
The provider schema shows:
```go
"version": {
    Type:     pluginsdk.TypeString,
    Optional: true,
    Default:  string(virtualmachinescalesets.IPVersionIPvFour),
    // ...
},
```

**Expected Behavior:**
According to executor.md lines 128-131, the method priority for defaults is:
1. **PREFER:** `optional(type, default)` in object type
2. **Fallback:** Apply default in locals if optional() syntax not possible

Since this field is nested in `list(object({...}))`, the `optional(string, "IPv4")` syntax IS possible and is the PREFERRED method.

**Root Cause:**
The proof document inaccurately described the implementation, claiming to use the fallback method (coalesce) when in fact the preferred method (optional modifier) was correctly used in the variable definition.

### Corrections Made

#### Fix 1: Corrected Proof Document

**Changed Files:**
- `76.network_interface.ip_configuration.version.md`: Corrected Shadow Implementation section, Default Value section, Null Semantics section, and Edge Cases section

**Corrected Documentation:**

1. **Shadow Implementation section:** Updated to show actual code `ip_config.version` instead of incorrect `coalesce(ip_config.version, "IPv4")`

2. **Special Handling - Default Value section:** Added comprehensive explanation showing both the variable definition using `optional(string, "IPv4")` and the implementation, clarifying that no coalesce is needed because the default is handled by the type system

3. **Null Semantics section:** Updated to explain that default is applied via `optional()` modifier, not `coalesce()`

4. **Edge Cases section:** Updated to explain that default is applied by the type system

5. **Checklist section:** Added item confirming method priority was followed

**Why This is EXACT:**
The actual implementation correctly uses the PREFERRED method from executor.md:
- Variable definition uses `optional(string, "IPv4")` at variables.tf line 548
- Implementation simply uses `ip_config.version` 
- Terraform's type system automatically applies the default value when null
- No coalesce() needed (would be redundant and violate method priority)

**Verification:**
- ✅ Variable definition: `version = optional(string, "IPv4")` (variables.tf line 548)
- ✅ Implementation: `privateIPAddressVersion = ip_config.version` (migrate_main.tf line 202)
- ✅ Enum validation: Implemented for "IPv4" and "IPv6" (variables.tf lines 688-699)
- ✅ Cross-field validation: IPv6 cannot be primary (variables.tf lines 701-712)
- ✅ No shared path merge issues: Each key appears only once at its level
- ✅ Deferred work completed: Task #74 validation implemented

### Final Validation Results

✅ **ForceNew Logic:** Not applicable - field does not have ForceNew
✅ **Stable Keys:** Not applicable - no replace_triggers_external_values for this field
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase)
✅ **Type Conversion:** Correct - string to string, no conversion needed
✅ **Null Handling:** Correctly handled via `optional(string, "IPv4")` modifier
✅ **Validations:** All provider validations implemented in variables.tf (enum values, cross-field primary+IPv6)
✅ **Deferred Work Completion:** Task #74 validation completed and documented, following.md updated
✅ **Deferred Work Recording:** No deferrals made from this task
✅ **Edge Cases:** All edge cases properly analyzed and handled
✅ **Method Priority:** PREFERRED method (optional modifier) correctly used instead of fallback (coalesce)
✅ **Shared Path Merge:** No duplicate keys in merge statements

### Compliance Statement

After documentation corrections, this implementation EXACTLY replicates the provider behavior as required by `executor.md`. The implementation code was already correct and followed the PREFERRED method for default values. Only the proof documentation needed correction to accurately reflect the implementation.

**Status:** CORRECTED AND APPROVED ✅

---
