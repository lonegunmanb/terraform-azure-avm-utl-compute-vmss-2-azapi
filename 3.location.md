# Task #3 - location - COMPLETED

## Summary

The `location` field is a required root-level argument that specifies the Azure region. It's normalized using `location.Normalize()` in the provider and has ForceNew behavior. It maps directly to azapi_resource's `location` field in `azapi_header`.

## Shadow Implementation

```hcl
# In migrate_main.tf
locals {
  azapi_header = {
    type      = "Microsoft.Compute/virtualMachineScaleSets@2024-11-01"
    name      = var.orchestrated_virtual_machine_scale_set_name
    location  = var.orchestrated_virtual_machine_scale_set_location # <-
    parent_id = var.orchestrated_virtual_machine_scale_set_resource_group_id
  }

  replace_triggers_external_values = {
    location                      = { value = var.orchestrated_virtual_machine_scale_set_location } # <-
    zone_balance                  = { value = var.orchestrated_virtual_machine_scale_set_zone_balance }
    zones                         = { value = local.zones_force_new_trigger }
    single_placement_group        = { value = local.single_placement_group_force_new_trigger }
    capacity_reservation_group_id = { value = var.orchestrated_virtual_machine_scale_set_capacity_reservation_group_id }
  }
}
```

## Create Phase Verification

**Pattern:** Single-phase creation

**Classification:** Create phase (before API call)

**Evidence from Create method:**

```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    // ...
    props := virtualmachinescalesets.VirtualMachineScaleSet{
        Location: location.Normalize(d.Get("location").(string)),
        // ...
    }
    // ...
    if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
        return fmt.Errorf("creating Orchestrated %s: %w", id, err)
    }
    // ...
}
```

**Decision:** The location field is set before the CreateOrUpdateThenPoll call, making it part of the Create phase. It should be included in `local.azapi_header.location`.

## Assignment Path Verification

**Predicted path:** `location` (root-level in azapi_resource)

**Go code evidence:**

```go
props := virtualmachinescalesets.VirtualMachineScaleSet{
    Location: location.Normalize(d.Get("location").(string)),
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        // ...
    },
}
```

The `Location` field is assigned at the root level of the `VirtualMachineScaleSet` struct, not inside `Properties`.

**Verified path:** `location` (root-level in azapi_resource, part of `azapi_header`)

**Path comparison:** Match - The location is correctly placed in `azapi_header.location` as it's a root-level Azure resource field.

## Provider Schema

**Schema definition:**

```go
"location": commonschema.Location(),
```

The `commonschema.Location()` returns a standard location schema with:
- Type: `TypeString`
- Required: `true`
- ForceNew: `true`
- StateFunc: Normalization applied
- DiffSuppressFunc: Case-insensitive comparison

**Field properties:**
- **Type:** String
- **Required:** Yes
- **Optional:** No
- **Computed:** No
- **ForceNew:** Yes
- **Sensitive:** No
- **Default:** None
- **Validation:** Location normalization via `location.Normalize()`

## Azure API Schema

**Resource Type:** `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

**Property Path:** `location` (root level)

**Type:** `String`

**Description:** "The location of the Azure resource."

**Azure API Documentation:**
- The location field is a root-level property in Azure Resource Manager resources
- It's immutable after creation (changing requires recreation)
- Azure normalizes location values (e.g., "East US" → "eastus")

## Hidden Fields

None. The location field has no associated hidden fields.

## Mapping

| AzureRM (snake_case) | AzAPI (camelCase) | Level |
|---------------------|-------------------|-------|
| location | location | Root (azapi_header) |

## Special Handling

### ForceNew Behavior

**Schema Evidence:**
```go
"location": commonschema.Location(),  // ForceNew is implicit in commonschema.Location()
```

The location field has `ForceNew: true`, meaning any change to location requires resource recreation.

**Implementation:**
```hcl
replace_triggers_external_values = {
  location = { value = var.orchestrated_virtual_machine_scale_set_location }
  # ...
}
```

The location is wrapped in a stable key structure to ensure the key always exists. Since location is ForceNew, any change to its value will trigger resource replacement.

### Validation

The variable already exists with proper validation in `variables.tf`:

```hcl
variable "orchestrated_virtual_machine_scale_set_location" {
  type        = string
  description = "(Required) The Azure location where the Virtual Machine Scale Set should exist. Changing this forces a new resource to be created."
  nullable    = false
}
```

**Analysis:**
- The provider uses `commonschema.Location()` which applies normalization via `location.Normalize()`
- The normalization is applied at the provider level, converting location names to normalized format (lowercase, no spaces)
- In AzAPI, location normalization is handled by the AzAPI provider itself when the location is passed
- No additional validation is needed in the Shadow Module as the Azure API will validate the location value

**No additional validation required** - The existing variable definition is sufficient. The AzAPI provider and Azure API handle location validation and normalization.

### Sensitive Fields

Not applicable. Location is not a sensitive field.

### Post-Creation Updates

Not applicable. Location cannot be updated after creation (ForceNew).

## Critical Review & Edge Cases

### Null Semantics
- **null value:** Not allowed (Required field, nullable = false)
- **Empty string:** Not allowed by Azure API (location cannot be empty)
- **Provider behavior:** The provider calls `location.Normalize()` which handles case normalization and spacing

### Boundary Conditions
- **Invalid location names:** Azure API will reject invalid locations
- **Case variations:** Normalized by location helper (e.g., "East US" → "eastus")
- **Display names vs. normalized names:** Provider normalizes to consistent format

### Idempotency
- Location values are normalized, ensuring idempotent behavior
- Multiple applies with the same location (even in different formats) will not trigger changes
- Example: "East US", "eastus", "east us" all normalize to the same value

### Safe References
- Direct variable reference: `var.orchestrated_virtual_machine_scale_set_location`
- No nested access required, no null checking needed
- Variable is non-nullable, so it will always have a value

### Edge Case Analysis

**1. Location Normalization:**
- **Provider behavior:** Uses `location.Normalize()` which converts display names to lowercase, removes spaces
- **AzAPI behavior:** The AzAPI provider also normalizes locations
- **Shadow Module behavior:** Pass the variable value directly - let AzAPI provider handle normalization
- **Conclusion:** No special handling needed; normalization is transparent

**2. ForceNew Trigger:**
- **Scenario:** User changes location from "eastus" to "westus"
- **Expected behavior:** Resource should be recreated
- **Implementation:** Location is in `replace_triggers_external_values` with stable key
- **Verification:** The value change will trigger replacement as intended

**3. Resource Already Exists:**
- **Scenario:** Import existing resource or update scenario
- **Expected behavior:** Location cannot be changed (ForceNew)
- **Implementation:** Any location change will trigger replacement via `replace_triggers_external_values`
- **Verification:** Consistent with provider behavior

## Checklist

- ✅ Property in correct local (`azapi_header.location`)
- ✅ ForceNew wrapped in `replace_triggers_external_values` with stable key
- ✅ All logic exactly replicated from provider (location normalization handled by AzAPI)
- ✅ Validations implemented (nullable = false is sufficient)
- ✅ Hidden fields checked (none found)
- ✅ Critical review completed (null, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis included
- ✅ Proof created
- ✅ Ready for track.md update to Pending

## Notes

- The location field already exists in `azapi_header` from Task #1 (name)
- This task adds the location to `replace_triggers_external_values` to ensure ForceNew behavior
- Location normalization is handled transparently by both the AzureRM and AzAPI providers
- No additional validation or transformation logic is needed in the Shadow Module

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-04
**Task:** #3 - location

### Validation Results

✅ **ForceNew Logic:** Simple ForceNew (schema `ForceNew: true`) - correctly wrapped with stable key
✅ **Stable Keys:** Key "location" in `replace_triggers_external_values` is always present
✅ **Phase Detection:** Field correctly placed in `local.azapi_header.location` (Create phase, root-level)
✅ **Type Conversion:** Correct - String to String, no conversion needed
✅ **Null Handling:** Correctly enforced via `nullable = false`
✅ **Validations:** Location normalization delegated to AzAPI provider (matches provider behavior)
✅ **Edge Cases:** All edge cases properly analyzed (normalization, ForceNew trigger, existing resources)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The location field:
- Is properly placed as a root-level field in `azapi_header.location`
- Has ForceNew behavior correctly implemented with stable keys
- Delegates normalization to AzAPI provider (matching AzureRM provider's delegation to location.Normalize())
- Uses non-nullable variable definition (Required field)

No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
