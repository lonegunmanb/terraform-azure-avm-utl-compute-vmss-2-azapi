# Task #126 - os_profile.windows_configuration.secret - Block Structure Skeleton

## Summary

Created block structure skeleton for `os_profile.windows_configuration.secret` nested block. This block enables provisioning certificates from Key Vault to Windows VMs. The skeleton creates the `secrets` array structure at the `osProfile` level (NOT inside `windowsConfiguration`) with comment placeholders for child fields (#127-130). No hidden fields were found in the expand function.

## Shadow Implementation

```hcl
locals {
  body = {
    properties = {
      virtualMachineProfile = {
        osProfile = merge(
          var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration != null && # <-
          var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.secret != null && # <-
          length(var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.secret) > 0 ? { # <-
            secrets = [ # <-
              for secret in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.secret : { # <-
                # sourceVault = ... # Task #127 # <-
                # vaultCertificates = ... # Task #128-130 # <-
              } # <-
            ] # <-
          } : {}, # <-
        )
      }
    }
  }
}
```

## Create Phase Verification

### Pattern Identification

Queried Create method to identify the creation pattern.

**Evidence from Create method:**

The secret block is processed during the single-phase creation. From the `resourceOrchestratedVirtualMachineScaleSetCreate` function:

```go
if len(winConfigRaw) > 0 && winConfigRaw[0] != nil {
    osType = virtualmachinescalesets.OperatingSystemTypesWindows
    winConfig := winConfigRaw[0].(map[string]interface{})
    vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(winConfig, customData)
    
    // Inside expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration:
    profile.Secrets = expandWindowsSecretsVMSS(config["secret"].([]interface{}))
    // ...
}

// Later assignment:
props.Properties.VirtualMachineProfile.OsProfile = vmssOsProfile
```

**Pattern:** Single-phase creation (Create phase only)

**Classification:** Create phase field - value set before the create API call

**Decision:** Implement in `local.body`

### Two-Phase Check

No two-phase pattern detected. The field is set once during Create and sent in the initial CreateOrUpdate call.

## Assignment Path Verification

### Predicted Path

Based on the Terraform schema `os_profile.windows_configuration.secret`, the Azure API path should be:
```
properties.virtualMachineProfile.osProfile.secrets
```

### Go Code Evidence

From the expand function `expandWindowsSecretsVMSS` in `shared_schema.go`:

```go
func expandWindowsSecretsVMSS(input []interface{}) *[]virtualmachinescalesets.VaultSecretGroup {
    output := make([]virtualmachinescalesets.VaultSecretGroup, 0)

    for _, raw := range input {
        v := raw.(map[string]interface{})

        keyVaultId := v["key_vault_id"].(string)
        certificatesRaw := v["certificate"].(*pluginsdk.Set).List()
        certificates := make([]virtualmachinescalesets.VaultCertificate, 0)
        for _, certificateRaw := range certificatesRaw {
            certificateV := certificateRaw.(map[string]interface{})

            store := certificateV["store"].(string)
            url := certificateV["url"].(string)
            certificates = append(certificates, virtualmachinescalesets.VaultCertificate{
                CertificateStore: pointer.To(store),
                CertificateURL:   pointer.To(url),
            })
        }

        output = append(output, virtualmachinescalesets.VaultSecretGroup{
            SourceVault: &virtualmachinescalesets.SubResource{
                Id: pointer.To(keyVaultId),
            },
            VaultCertificates: &certificates,
        })
    }

    return &output
}
```

**Critical Assignment in Create method:**

From `resourceOrchestratedVirtualMachineScaleSetCreate`:

```go
winConfig := winConfigRaw[0].(map[string]interface{})
// ...
profile.Secrets = expandWindowsSecretsVMSS(winConfig["secret"].([]interface{}))
// ...

props := virtualmachinescalesets.VirtualMachineScaleSet{
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        VirtualMachineProfile: &profile,  // <- profile contains Secrets
    },
}
```

### Verified Path

```
properties.virtualMachineProfile.osProfile.secrets[]
  .sourceVault.id
  .vaultCertificates[].certificateStore
  .vaultCertificates[].certificateUrl
```

**Important:** The `secret` block is at **parent osProfile level**, NOT inside `windowsConfiguration`. This placement is identical to Linux configuration secrets (Task #109), as both use the same `VaultSecretGroup` structure at the OSProfile level.

### Path Comparison

- **Predicted:** `properties.virtualMachineProfile.osProfile.secrets`
- **Verified:** `properties.virtualMachineProfile.osProfile.secrets`
- **Match:** ✅ Yes

## Provider Schema

From `query_terraform_schema` output:

```json
{
  "nesting_mode": "list",
  "block": {
    "attributes": {
      "key_vault_id": {
        "type": "string",
        "description_kind": "plain",
        "required": true
      }
    },
    "block_types": {
      "certificate": {
        "nesting_mode": "set",
        "block": {
          "attributes": {
            "store": {
              "type": "string",
              "description_kind": "plain",
              "required": true
            },
            "url": {
              "type": "string",
              "description_kind": "plain",
              "required": true
            }
          },
          "description_kind": "plain"
        },
        "min_items": 1
      }
    },
    "description_kind": "plain"
  }
}
```

**Key Schema Details:**
- **Type:** List of objects (nesting_mode: list)
- **Required Fields:**
  - `key_vault_id` (string, required)
  - `certificate` (set of objects, required, min_items: 1)
    - `store` (string, required) - **Windows-only field**
    - `url` (string, required)
- **Optional:** The `secret` block itself is optional
- **ForceNew:** Not explicitly marked, but certificates are typically immutable

From `variables.tf`:

```hcl
secret = optional(list(object({
  key_vault_id = string
  certificate = set(object({
    store = string
    url   = string
  }))
})))
```

## Azure API Schema

From Go SDK types in `virtualmachinescalesets` package:

```go
type VirtualMachineScaleSetOSProfile struct {
    // ...
    Secrets *[]VaultSecretGroup `json:"secrets,omitempty"`
}

type VaultSecretGroup struct {
    SourceVault       *SubResource         `json:"sourceVault,omitempty"`
    VaultCertificates *[]VaultCertificate  `json:"vaultCertificates,omitempty"`
}

type SubResource struct {
    Id *string `json:"id,omitempty"`
}

type VaultCertificate struct {
    CertificateStore *string `json:"certificateStore,omitempty"`  // Windows-specific
    CertificateURL   *string `json:"certificateUrl,omitempty"`
}
```

**API Path:**
```
properties.virtualMachineProfile.osProfile.secrets[]
  .sourceVault.id
  .vaultCertificates[].certificateStore
  .vaultCertificates[].certificateUrl
```

**Key Difference from Linux:** Windows certificates include `certificateStore` field (the Windows certificate store name), while Linux certificates only have the URL.

## Hidden Fields

### Analysis of Expand Function

From `expandWindowsSecretsVMSS`:

```go
output = append(output, virtualmachinescalesets.VaultSecretGroup{
    SourceVault: &virtualmachinescalesets.SubResource{
        Id: pointer.To(keyVaultId),  // From Terraform: key_vault_id
    },
    VaultCertificates: &certificates,  // From Terraform: certificate[].store and certificate[].url
})
```

**Hidden Fields:** None

All fields are directly mapped from Terraform schema:
- `key_vault_id` → `sourceVault.id`
- `certificate[].store` → `vaultCertificates[].certificateStore`
- `certificate[].url` → `vaultCertificates[].certificateUrl`

No additional hardcoded values, no computed fields, and no hidden API-only fields.

## Mapping

| Terraform Field | Azure API Field | Notes |
|----------------|-----------------|-------|
| `secret[]` | `secrets[]` | Array of secret groups |
| `secret.key_vault_id` | `secrets[].sourceVault.id` | Task #127 |
| `secret.certificate[]` | `secrets[].vaultCertificates[]` | Task #128 |
| `secret.certificate.store` | `secrets[].vaultCertificates[].certificateStore` | Task #129 - Windows-only |
| `secret.certificate.url` | `secrets[].vaultCertificates[].certificateUrl` | Task #130 |

**Naming Convention:**
- `secret` (snake_case) → `secrets` (camelCase)
- `key_vault_id` (snake_case) → nested: `sourceVault.id` (camelCase)
- `certificate` → `vaultCertificates` (camelCase)
- `store` → `certificateStore` (camelCase)
- `url` → `certificateUrl` (camelCase, note: URL capitalization)

## Special Handling

### Block Structure

**Nesting Mode:** List (can have multiple secret groups)

**Conditionality:** The `secrets` field is only present when:
1. `windows_configuration` is not null
2. `secret` is not null
3. `secret` list is not empty

**Implementation:**
```hcl
var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration != null &&
var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.secret != null && 
length(var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.secret) > 0 ? {
  secrets = [
    for secret in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.secret : {
      # child fields here
    }
  ]
} : {}
```

### Placement: osProfile Level (Not windowsConfiguration)

**Critical:** The `secret` block values are placed at the **parent `osProfile` level**, NOT inside `windowsConfiguration`. This is identical to Linux configuration (Task #109).

**Evidence from Create method:**
```go
profile.Secrets = expandWindowsSecretsVMSS(winConfig["secret"].([]interface{}))
// profile is of type VirtualMachineScaleSetVMProfile
// profile.OsProfile.Secrets is set at osProfile level
```

**This skeleton is placed correctly in `osProfile`, outside the `windowsConfiguration` merge.**

### ForceNew Behavior

No explicit `ForceNew: true` in schema, but from API behavior:
- Secrets are typically set at creation
- Modifying secrets after creation may trigger updates depending on Azure API behavior
- No DiffSuppressFunc or CustomizeDiff logic found

**Decision:** No special ForceNew handling required at the skeleton level. Child tasks will determine if individual fields need ForceNew triggers.

### Validation

No validation at the block structure level. Validations exist for child fields:
- `key_vault_id` must be a valid Key Vault resource ID (handled by schema via `commonschema.ResourceIDReferenceRequired(&commonids.KeyVaultId{})`)
- `certificate` must have at least 1 item (min_items: 1 in schema)
- `url` must be a valid Key Vault secret URL (validated by `keyVaultValidate.NestedItemId`)
- `store` must be a valid Windows certificate store name (no explicit validation in provider, but required by API)

These will be addressed in child tasks #127-130.

## Critical Review & Edge Cases

### Null Semantics

**`null` secret block:**
- When `var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.secret` is `null`, the condition evaluates to false, and the empty merge `{}` is returned
- Result: `secrets` field is omitted from the Azure API payload
- This is correct behavior - Azure doesn't require secrets

**Empty secret list:**
- When `secret` is an empty list `[]`, `length()` returns 0, condition fails
- Result: `secrets` field is omitted
- This prevents sending an empty array to the API

**Present but empty after filtering:**
- If all secrets are somehow invalid (shouldn't happen due to schema validation), the for loop produces an empty array
- Azure API may accept empty array or reject it - schema validation prevents this scenario

### Boundary Conditions

1. **Single secret with single certificate:** Valid and supported
2. **Multiple secrets:** Valid - each can reference a different Key Vault
3. **Single secret with multiple certificates:** Valid - one Key Vault, multiple certs to different stores
4. **No secrets:** Valid - field omitted from API call

### Idempotency

The implementation is idempotent:
- For loop processes secrets in list order (Terraform maintains list order)
- Each secret block is independently processed
- No state dependencies between iterations
- No side effects from the loop

**Note:** The child `certificate` field is a `TypeSet` in Terraform (with a hash function), which provides order independence within each secret group. This will be handled in Task #128.

### Safe References

**Variable Access Chain:**
```hcl
var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.secret
```

**Safety Checks:**
1. ✅ Parent check: `windows_configuration != null` (from parent merge in Task #113)
2. ✅ Field check: `secret != null`
3. ✅ Length check: `length(secret) > 0`

**Safe because:** The condition only evaluates if all parent objects exist and secret is a non-empty list.

### Edge Case: Mutual Exclusivity

From the parent `os_profile` block (Task #96), `linux_configuration` and `windows_configuration` are mutually exclusive. Only one can be present.

**Impact:** When `windows_configuration` is present, the Linux-specific secret structure (without `certificateStore`) is not applicable.

**Handling:** Correctly isolated - this skeleton only activates when `windows_configuration` is present.

### Edge Case: Certificate Set Ordering

The `certificate` field is defined as a `TypeSet` in Terraform schema:
```go
"certificate": {
    Type:     pluginsdk.TypeSet,
    Required: true,
    MinItems: 1,
    // ...
}
```

**Implication:** Terraform may reorder certificates within a secret group based on the set hash function.

**Azure API Behavior:** The API receives `vaultCertificates` as an array. Each certificate has a `certificateStore` field specifying the target Windows store, so order independence is acceptable.

**Handling:** Child Task #128 will need to convert the set to a list for the API. The expand function already handles this:
```go
certificatesRaw := v["certificate"].(*pluginsdk.Set).List()
```

### Edge Case: Windows-Specific Store Field

The key difference between Windows and Linux secrets is the `certificateStore` field:
- **Linux:** Certificates are provisioned to the VM filesystem
- **Windows:** Certificates are installed to specific Windows certificate stores (e.g., "My", "Root", "CA")

**Handling:** Task #129 will implement the `store` field mapping, which is required for Windows but not present in Linux secrets.

## Child Tasks Ready for Delegation

The following child tasks are now **READY** for implementation since the parent skeleton structure (#126) is complete:

| Task # | Field | Type | Notes |
|--------|-------|------|-------|
| 127 | os_profile.windows_configuration.secret.key_vault_id | Argument (Required) | Maps to `sourceVault.id` |
| 128 | os_profile.windows_configuration.secret.certificate | Block Skeleton (Required, min_items: 1) | Creates `vaultCertificates[]` array |
| 129 | os_profile.windows_configuration.secret.certificate.store | Argument (Required) | Windows-only field, depends on skeleton #128 |
| 130 | os_profile.windows_configuration.secret.certificate.url | Argument (Required) | Depends on skeleton #128 |

**Dependency Flow:**
- Task #127 can proceed immediately (sibling to #128)
- Task #128 must complete before Tasks #129 and #130
- Tasks #127 and #128 can work in parallel
- Tasks #129 and #130 can work in parallel after #128

**Implementation Notes for Child Tasks:**
- Task #127: Direct mapping, straightforward nested object assignment (identical to Linux Task #110)
- Task #128: Must convert TypeSet to list, create block skeleton for certificates array
- Task #129: Windows-specific field for certificate store name (e.g., "My", "Root")
- Task #130: Direct mapping within certificate loop (identical to Linux Task #112 but with additional `certificateStore`)

## Deferred Work Completion

Checked `following.md` for work deferred to Task #126: **None found**.

No deferred work to complete for this task.

## Completion Checklist

- ✅ Property in correct local (`local.body`)
- ✅ Block structure skeleton created with comment placeholders
- ✅ Conditional logic based on variable null check and length > 0
- ✅ Placement at correct osProfile level (NOT inside windowsConfiguration)
- ✅ ForceNew: Not applicable at skeleton level (no special handling needed)
- ✅ Validations: No validations at block level (child fields handle their own)
- ✅ Hidden fields: None found (all fields directly mapped from Terraform)
- ✅ Deferred work checked: None found for this task
- ✅ Critical review completed
- ✅ Edge case analysis included (placement, ordering, mutual exclusivity, Windows-specific store)
- ✅ Proof document created
- ✅ `track.md` will be updated to "Pending for check"
- ✅ Self-Review: Only skeleton structure created, no child implementations added

## Notes

1. **Placement Verified:** `secrets` is placed at `osProfile` level, NOT inside `windowsConfiguration`. This skeleton correctly implements this placement, matching Linux secrets (Task #109).

2. **List vs Set:** The `secret` block itself is a list (order preserved), but the nested `certificate` is a set (order independent within each secret). Task #128 will handle the set-to-list conversion.

3. **Windows vs Linux:** Windows secrets include `certificateStore` field (Task #129) which specifies the target Windows certificate store. Linux secrets only have the URL field.

4. **Key Vault Validation:** The provider validates Key Vault IDs using `commonschema.ResourceIDReferenceRequired(&commonids.KeyVaultId{})`. Task #127 should replicate this validation in `variables.tf` (same as Linux Task #110).

5. **Empty Array Prevention:** The skeleton explicitly checks `length() > 0` to prevent sending an empty `secrets` array to the Azure API.

6. **No Two-Phase Logic:** Secrets are set during Create phase only. No post-creation updates required.

7. **Integration with Parent:** This skeleton integrates with the `osProfile` merge structure created in Task #96 and extended in Task #113.

8. **Shared Structure:** Both Linux and Windows use the same `VaultSecretGroup` structure with `SourceVault` and `VaultCertificates`. The only difference is Windows certificates have an additional `CertificateStore` field.

9. **Certificate Store Names:** Common Windows certificate store names include "My" (personal), "Root" (trusted root), "CA" (intermediate certification authorities), "Trust", "TrustedPublisher", etc. No validation is performed by the provider, leaving it to the Azure API.

10. **Consistency with Linux Implementation:** This implementation maintains structural consistency with the Linux secrets implementation (Task #109), differing only in the additional `store` field for Windows certificates.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #126 - os_profile.windows_configuration.secret

### Validation Results

✅ **Block Structure Skeleton:** Correctly creates `secrets` array at osProfile level with comment placeholders for child tasks (#127, #128-130)
✅ **Placement:** Correctly placed at `osProfile` level (NOT inside `windowsConfiguration`), matching Azure API schema and Linux secrets (Task #109)
✅ **Conditionality:** All three required checks present (windows_configuration != null, secret != null, length > 0)
✅ **Phase Detection:** Correctly identified as Create phase field, placed in `local.body`
✅ **Type Conversion:** Proper `for` loop for list iteration
✅ **Null Handling:** Correctly omits `secrets` field when conditions not met
✅ **Hidden Fields:** None found - all fields directly mapped from Terraform schema
✅ **Validations:** No validations at block skeleton level (child fields handle their own)
✅ **Deferred Work Completion:** No deferred work for this task (checked following.md)
✅ **Edge Cases:** Proper analysis of null semantics, boundary conditions, idempotency, safe references, and Windows-specific store field

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The skeleton creates only the structure for the `secrets` array at the correct osProfile level with proper conditionality. No hidden fields were added, and all child field implementations are correctly deferred to Tasks #127-130 via comment placeholders.

**Status:** APPROVED ✅

---
