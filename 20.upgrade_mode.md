# Task #20: upgrade_mode - Implementation Proof

## Summary

Implemented the `upgrade_mode` root-level argument for `azurerm_orchestrated_virtual_machine_scale_set` in the Shadow Module. The field maps to `properties.upgradePolicy.mode` in the Azure API, has a default value of "Manual", requires validation for enum values ("Automatic", "Manual", "Rolling"), includes cross-field validations with rolling_upgrade_policy, and is marked as ForceNew.

## Shadow Implementation

### variables.tf

```hcl
variable "orchestrated_virtual_machine_scale_set_upgrade_mode" {
  type        = string
  default     = "Manual"  # <-
  description = "(Optional) Specifies how upgrades (e.g. changing the Image/SKU) should be performed to Virtual Machine Instances. Possible values are `Automatic`, `Manual` and `Rolling`. Defaults to `Manual`. Changing this forces a new resource to be created."

  validation {  # <-
    condition = contains([
      "Automatic",
      "Manual",
      "Rolling"
    ], var.orchestrated_virtual_machine_scale_set_upgrade_mode)
    error_message = "The upgrade_mode must be one of 'Automatic', 'Manual', or 'Rolling'."
  }

  validation {  # <-
    condition = !(
      var.orchestrated_virtual_machine_scale_set_upgrade_mode == "Manual" &&
      var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy != null
    )
    error_message = "`rolling_upgrade_policy` cannot be specified when `upgrade_mode` is set to `Manual`."
  }

  validation {  # <-
    condition = !(
      var.orchestrated_virtual_machine_scale_set_upgrade_mode == "Rolling" &&
      var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy == null
    )
    error_message = "`rolling_upgrade_policy` is required when `upgrade_mode` is set to `Rolling`."
  }
}
```

### migrate_main.tf

```hcl
locals {
  replace_triggers_external_values = {
    location                      = { value = var.orchestrated_virtual_machine_scale_set_location }
    platform_fault_domain_count   = { value = var.orchestrated_virtual_machine_scale_set_platform_fault_domain_count }
    zone_balance                  = { value = var.orchestrated_virtual_machine_scale_set_zone_balance }
    capacity_reservation_group_id = { value = var.orchestrated_virtual_machine_scale_set_capacity_reservation_group_id }
    eviction_policy               = { value = var.orchestrated_virtual_machine_scale_set_eviction_policy }
    extension_operations_enabled  = { value = var.orchestrated_virtual_machine_scale_set_extension_operations_enabled }
    priority                      = { value = var.orchestrated_virtual_machine_scale_set_priority }
    proximity_placement_group_id  = { value = var.orchestrated_virtual_machine_scale_set_proximity_placement_group_id }
    network_interface_name        = { value = var.orchestrated_virtual_machine_scale_set_network_interface != null ? jsonencode([for nic in var.orchestrated_virtual_machine_scale_set_network_interface : nic.name]) : "" }
    single_placement_group        = local.single_placement_group_force_new_trigger
    zones                         = local.zones_force_new_trigger
    upgrade_mode                  = { value = var.orchestrated_virtual_machine_scale_set_upgrade_mode }  # <-
  }

  body = merge(
    {
      properties = merge(
        {
          orchestrationMode = "Flexible"
        },
        {
          platformFaultDomainCount = var.orchestrated_virtual_machine_scale_set_platform_fault_domain_count
        },
        {  # <-
          upgradePolicy = {  # <-
            mode = var.orchestrated_virtual_machine_scale_set_upgrade_mode  # <-
          }  # <-
        },  # <-
        var.orchestrated_virtual_machine_scale_set_zone_balance != null ? {
          zoneBalance = var.orchestrated_virtual_machine_scale_set_zone_balance
        } : {},
        # ... rest of properties
      )
    },
    # ... rest of body
  )
}
```

## Create Phase Verification

**Pattern:** Single-phase Create

**Classification:** Create phase field (set before CreateOrUpdate call)

### Evidence from Create Method

From `resourceOrchestratedVirtualMachineScaleSetCreate`:

```go
upgradeMode := virtualmachinescalesets.UpgradeMode(d.Get("upgrade_mode").(string))
rollingUpgradePolicy, err := ExpandVirtualMachineScaleSetRollingUpgradePolicy(d.Get("rolling_upgrade_policy").([]interface{}), len(zones) > 0, false)
if err != nil {
	return fmt.Errorf("expanding `rolling_upgrade_policy`: %w", err)
}

props.Properties.UpgradePolicy = &virtualmachinescalesets.UpgradePolicy{
	Mode:                 pointer.To(upgradeMode),
	RollingUpgradePolicy: rollingUpgradePolicy,
}

// ... later in the method ...

log.Printf("[DEBUG] Creating Orchestrated %s.", id)
if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
	return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Decision:** This is a **Create phase field**. The upgrade_mode is set on the props.Properties.UpgradePolicy struct before the `CreateOrUpdateThenPoll` call. There is no two-phase pattern. The field goes into `local.body`.

## Assignment Path Verification

### Predicted Path
`body.properties.upgradePolicy.mode`

### Go Code Evidence

```go
upgradeMode := virtualmachinescalesets.UpgradeMode(d.Get("upgrade_mode").(string))

props.Properties.UpgradePolicy = &virtualmachinescalesets.UpgradePolicy{
	Mode:                 pointer.To(upgradeMode),
	RollingUpgradePolicy: rollingUpgradePolicy,
}
```

**Assignment trace:**
1. `upgradeMode` ← Value read from state and cast to UpgradeMode type
2. `props.Properties.UpgradePolicy.Mode = pointer.To(upgradeMode)` ← Set on UpgradePolicy struct
3. `props.Properties.UpgradePolicy` ← Assigned to Properties
4. Final JSON path: `properties.upgradePolicy.mode`

### Verified Path
`body.properties.upgradePolicy.mode` ✅

### Path Comparison
Predicted path matches verified path: **MATCH** ✅

## Provider Schema

From `resourceOrchestratedVirtualMachineScaleSet()` schema:

```go
"upgrade_mode": {
	Type:     pluginsdk.TypeString,
	Optional: true,
	ForceNew: true,
	Default:  string(virtualmachinescalesets.UpgradeModeManual),
	ValidateFunc: validation.StringInSlice([]string{
		string(virtualmachinescalesets.UpgradeModeAutomatic),
		string(virtualmachinescalesets.UpgradeModeManual),
		string(virtualmachinescalesets.UpgradeModeRolling),
	}, false),
},
```

**Key attributes:**
- **Type:** String
- **Optional:** true
- **ForceNew:** true ← Forces replacement on change
- **Default:** "Manual" (UpgradeModeManual)
- **ValidateFunc:** StringInSlice with values ["Automatic", "Manual", "Rolling"]

## Azure API Schema

### Schema Query Result
From `properties.upgradePolicy.mode`:
```
String
```

### Documentation Query Result
```
"Specifies the mode of an upgrade to virtual machines in the scale set.<br /><br /> Possible values are:<br /><br /> **Manual** - You control the application of updates to virtual machines in the scale set. You do this by using the manualUpgrade action.<br /><br /> **Automatic** - All virtual machines in the scale set are automatically updated at the same time. (Possible values: Automatic,Manual,Rolling)"
```

**API Path:** `body.properties.upgradePolicy.mode`

## Hidden Fields

No hidden fields detected for upgrade_mode itself. The upgradePolicy object contains other fields (like rollingUpgradePolicy) that are handled by separate tasks.

## Mapping

| Provider (snake_case) | Azure API (camelCase) | Notes |
|----------------------|----------------------|-------|
| upgrade_mode | mode | Field is nested under upgradePolicy |

**Value mapping:**
- Provider: "Automatic" → API: "Automatic"
- Provider: "Manual" → API: "Manual"  
- Provider: "Rolling" → API: "Rolling"

## Special Handling

### 1. Default Value
**Provider behavior:** Has explicit default value `Default: string(virtualmachinescalesets.UpgradeModeManual)` which translates to "Manual".

**Implementation:** Set default in variable definition:
```hcl
variable "orchestrated_virtual_machine_scale_set_upgrade_mode" {
  type    = string
  default = "Manual"  # Exact replication of provider default
  # ...
}
```

### 2. Validation - Enum Values
**Provider behavior:** Uses `validation.StringInSlice([]string{"Automatic", "Manual", "Rolling"}, false)` to validate enum values.

**Implementation:** Replicated in variables.tf:
```hcl
validation {
  condition = contains([
    "Automatic",
    "Manual",
    "Rolling"
  ], var.orchestrated_virtual_machine_scale_set_upgrade_mode)
  error_message = "The upgrade_mode must be one of 'Automatic', 'Manual', or 'Rolling'."
}
```

### 3. Validation - Cross-Field with rolling_upgrade_policy
**Provider behavior:** CustomizeDiff validates relationship between upgrade_mode and rolling_upgrade_policy:

From schema CustomizeDiff:

```go
upgradeMode := virtualmachinescalesets.UpgradeMode(diff.Get("upgrade_mode").(string))
rollingUpgradePolicyRaw := diff.Get("rolling_upgrade_policy").([]interface{})

if upgradeMode == virtualmachinescalesets.UpgradeModeManual && len(rollingUpgradePolicyRaw) > 0 {
	return fmt.Errorf("`rolling_upgrade_policy` cannot be specified when `upgrade_mode` is set to `%s`", string(upgradeMode))
}

if upgradeMode == virtualmachinescalesets.UpgradeModeRolling && len(rollingUpgradePolicyRaw) == 0 {
	return fmt.Errorf("`rolling_upgrade_policy` is required when `upgrade_mode` is set to `%s`", string(upgradeMode))
}
```

**Implementation:** Two cross-variable validations in variables.tf (allowed in Terraform 1.9+):

```hcl
validation {
  condition = !(
    var.orchestrated_virtual_machine_scale_set_upgrade_mode == "Manual" &&
    var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy != null
  )
  error_message = "`rolling_upgrade_policy` cannot be specified when `upgrade_mode` is set to `Manual`."
}

validation {
  condition = !(
    var.orchestrated_virtual_machine_scale_set_upgrade_mode == "Rolling" &&
    var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy == null
  )
  error_message = "`rolling_upgrade_policy` is required when `upgrade_mode` is set to `Rolling`."
}
```

### 4. ForceNew Behavior
**Provider behavior:** Marked as `ForceNew: true` in schema - any change forces resource replacement.

**Implementation:** Added to `replace_triggers_external_values`:
```hcl
upgrade_mode = { value = var.orchestrated_virtual_machine_scale_set_upgrade_mode }
```

**No additional CustomizeDiff ForceNew logic:** The CustomizeDiff blocks handle validation only, not ForceNew behavior. It's simple ForceNew behavior from schema.

### 5. Related Validation - Health Extension Requirement
**Provider behavior:** When upgrade_mode is "Rolling", health extension is required:

From Create method:
```go
// Virtual Machine Scale Set with Flexible Orchestration Mode and 'Rolling' upgradeMode must have Health Extension Present
if upgradeMode == virtualmachinescalesets.UpgradeModeRolling && !hasHealthExtension {
	return fmt.Errorf("health extension is required when `upgrade_mode` is set to `%s`", string(upgradeMode))
}
```

**Note:** This validation involves detecting health extensions from the extension block. This is outside the scope of this task (Task #20) and will be handled when the extension block is implemented in future tasks. The rolling_upgrade_policy relationship is within scope and has been implemented.

## Critical Review & Edge Case Analysis

### Null Semantics
**Question:** What does null mean for upgrade_mode?

**Answer:** upgrade_mode is not nullable in the provider schema. It has a default value of "Manual" and is always set. The variable is defined with `default = "Manual"`, so it will never be null.

**Implementation:** Variable has non-null default value, ensuring upgrade_mode is always present in the API request.

### Edge Cases

1. **Empty string value:**
   - **Provider behavior:** Would fail validation (StringInSlice only allows "Automatic", "Manual", or "Rolling")
   - **Shadow Module:** Validation block prevents empty strings, replicating provider behavior ✅

2. **Case sensitivity:**
   - **Provider behavior:** Validation is case-sensitive (`false` parameter in StringInSlice)
   - **Shadow Module:** `contains()` is case-sensitive, replicating exact behavior ✅

3. **Cross-field validation with rolling_upgrade_policy:**
   - **Provider behavior:** 
     - When upgrade_mode is "Manual", rolling_upgrade_policy must NOT be set
     - When upgrade_mode is "Rolling", rolling_upgrade_policy IS required
   - **Shadow Module:** Both validations implemented in variables.tf validation blocks ✅

4. **Value transitions:**
   - **Provider behavior:** Any change to upgrade_mode triggers ForceNew (replacement)
   - **Shadow Module:** Tracked in replace_triggers_external_values, any value change triggers replacement ✅

5. **Default value interaction:**
   - **Provider behavior:** Default is "Manual", so rolling_upgrade_policy is not expected by default
   - **Shadow Module:** Default is "Manual", matching provider behavior exactly ✅

### Idempotency
**Question:** Is the implementation idempotent?

**Answer:** Yes. The upgrade_mode value is directly assigned, no transformations or order-dependent operations. Same input always produces same output.

### Safe References
**Question:** Are all references null-safe?

**Answer:** Yes. upgrade_mode is never null (has default value), so direct reference is safe:
```hcl
upgradePolicy = {
  mode = var.orchestrated_virtual_machine_scale_set_upgrade_mode
}
```

The cross-field validation references rolling_upgrade_policy with null check:
```hcl
var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy != null
```

### Boundary Conditions
1. **Only three valid values:** Validation correctly enforces "Automatic", "Manual", or "Rolling" only ✅
2. **Default value:** "Manual" is applied by default, matching provider ✅
3. **ForceNew behavior:** Any change triggers replacement via replace_triggers_external_values ✅
4. **Cross-field requirements:** Validations ensure rolling_upgrade_policy is set/unset correctly based on upgrade_mode ✅

## Checklist

- ✅ Property in correct local (`local.body.properties.upgradePolicy.mode`)
- ✅ ForceNew wrapped: `{ value = var.orchestrated_virtual_machine_scale_set_upgrade_mode }`
- ✅ ALL logic EXACTLY replicated from provider (default value, enum validation, cross-field validations, ForceNew)
- ✅ Validations IMPLEMENTED in variables.tf (enum validation + two cross-field validations)
- ✅ Hidden fields checked (none found)
- ✅ Critical review completed (null semantics, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis included in proof
- ✅ Proof created (this document)
- ✅ Ready for `track.md` update to Pending for check
- ✅ Self-Review: Only implemented upgrade_mode field (Task #20), no other fields added

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-05
**Task:** #20 - upgrade_mode

### Validation Results

✅ **ForceNew Logic:** Simple ForceNew from schema (`ForceNew: true`) - correctly wrapped as `{ value = var.orchestrated_virtual_machine_scale_set_upgrade_mode }`
✅ **Stable Keys:** Key `upgrade_mode` is always present in `replace_triggers_external_values` map
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase - set before CreateOrUpdateThenPoll call)
✅ **Type Conversion:** String to String, no conversion needed
✅ **Null Handling:** Non-nullable with default value "Manual", correctly matches provider behavior
✅ **Validations:** All provider validations exactly replicated in variables.tf:
  - Enum validation: ["Automatic", "Manual", "Rolling"] ✅
  - Cross-field validation 1: Manual mode cannot have rolling_upgrade_policy ✅
  - Cross-field validation 2: Rolling mode requires rolling_upgrade_policy ✅
✅ **Edge Cases:** All edge cases properly analyzed and handled (empty string, case sensitivity, value transitions, default interactions)
✅ **Assignment Path:** Correctly mapped to `body.properties.upgradePolicy.mode` with proper struct nesting
✅ **Default Value:** "Manual" default exactly matches provider `Default: string(virtualmachinescalesets.UpgradeModeManual)`

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. 

**Evidence:**
- Provider schema: `ForceNew: true, Default: "Manual", ValidateFunc: StringInSlice(["Automatic", "Manual", "Rolling"])`
- Provider CustomizeDiff: Two cross-field validations with rolling_upgrade_policy
- Implementation: All validations in variables.tf, ForceNew in replace_triggers_external_values, default value set, correct assignment path

No deviations, simplifications, or "safer alternatives" were found. The implementation is an exact replication of the provider logic.

**Status:** APPROVED ✅

---
