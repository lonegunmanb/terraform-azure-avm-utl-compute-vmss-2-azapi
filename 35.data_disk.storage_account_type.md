# Task #35 - data_disk.storage_account_type

## Summary

Implemented `storage_account_type` field within the `data_disk` block. This required field specifies the storage account type for the managed disk and is directly assigned to `managedDisk.storageAccountType` in the Azure API.

## Shadow Implementation

```hcl
locals {
  body = {
    properties = {
      virtualMachineProfile = {
        storageProfile = {
          dataDisks = [
            for data_disk in var.orchestrated_virtual_machine_scale_set_data_disk : {
              caching = data_disk.caching
              managedDisk = { # <-
                storageAccountType = data_disk.storage_account_type # <-
              } # <-
            }
          ]
        }
      }
    }
  }
}
```

```hcl
variable "orchestrated_virtual_machine_scale_set_data_disk" {
  type = list(object({
    storage_account_type = string # <-
    # ... other fields
  }))

  validation { # <-
    condition = ( # <-
      var.orchestrated_virtual_machine_scale_set_data_disk == null || # <-
      alltrue([ # <-
        for disk in var.orchestrated_virtual_machine_scale_set_data_disk : # <-
        contains(["Premium_LRS", "PremiumV2_LRS", "Premium_ZRS", "Standard_LRS", "StandardSSD_LRS", "StandardSSD_ZRS", "UltraSSD_LRS"], disk.storage_account_type) # <-
      ]) # <-
    ) # <-
    error_message = "The storage_account_type must be one of: Premium_LRS, PremiumV2_LRS, Premium_ZRS, Standard_LRS, StandardSSD_LRS, StandardSSD_ZRS, UltraSSD_LRS." # <-
  } # <-
}
```

## Create Phase Verification

**Pattern:** Single-phase creation

**Evidence from Create method:**
```go
if v, ok := d.GetOk("data_disk"); ok {
    ultraSSDEnabled := d.Get("additional_capabilities.0.ultra_ssd_enabled").(bool)
    dataDisks, err := ExpandOrchestratedVirtualMachineScaleSetDataDisk(v.([]interface{}), ultraSSDEnabled)
    if err != nil {
        return fmt.Errorf("expanding `data_disk`: %w", err)
    }
    virtualMachineProfile.StorageProfile.DataDisks = dataDisks
}

// ... later in the same function ...
if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Classification:** Create phase - The `data_disk` block is expanded and assigned to `virtualMachineProfile.StorageProfile.DataDisks` before the `CreateOrUpdateThenPoll` call.

**Decision:** Implement in `local.body`

## Assignment Path Verification

**Predicted Path:** `properties.virtualMachineProfile.storageProfile.dataDisks[*].managedDisk.storageAccountType`

**Tracing Assignment:**

From `ExpandOrchestratedVirtualMachineScaleSetDataDisk`:
```go
func ExpandOrchestratedVirtualMachineScaleSetDataDisk(input []interface{}, ultraSSDEnabled bool) (*[]virtualmachinescalesets.VirtualMachineScaleSetDataDisk, error) {
    disks := make([]virtualmachinescalesets.VirtualMachineScaleSetDataDisk, 0)

    for _, v := range input {
        raw := v.(map[string]interface{})

        storageAccountType := virtualmachinescalesets.StorageAccountTypes(raw["storage_account_type"].(string))
        disk := virtualmachinescalesets.VirtualMachineScaleSetDataDisk{
            Caching: pointer.To(virtualmachinescalesets.CachingTypes(raw["caching"].(string))),
            ManagedDisk: &virtualmachinescalesets.VirtualMachineScaleSetManagedDiskParameters{
                StorageAccountType: pointer.To(storageAccountType), // <- Assigned here
            },
            // ... other fields
        }
        disks = append(disks, disk)
    }

    return &disks, nil
}
```

**Assignment Steps:**
1. `raw["storage_account_type"].(string)` → Reads value from Terraform config
2. `virtualmachinescalesets.StorageAccountTypes(...)` → Type conversion
3. `StorageAccountType: pointer.To(storageAccountType)` → Assigned to `ManagedDisk.StorageAccountType`
4. `ManagedDisk: &virtualmachinescalesets.VirtualMachineScaleSetManagedDiskParameters{...}` → Wrapped in ManagedDisk struct
5. `disk := virtualmachinescalesets.VirtualMachineScaleSetDataDisk{...}` → Wrapped in DataDisk struct
6. `virtualMachineProfile.StorageProfile.DataDisks = dataDisks` → Assigned to StorageProfile.DataDisks
7. `props.Properties.VirtualMachineProfile = &virtualMachineProfile` → Wrapped in VirtualMachineProfile

**Verified Path:** `properties.virtualMachineProfile.storageProfile.dataDisks[*].managedDisk.storageAccountType` ✅

**Path Comparison:** Predicted path matches verified path.

## Provider Schema

```go
"storage_account_type": {
    Type:     pluginsdk.TypeString,
    Required: true,
    ValidateFunc: validation.StringInSlice([]string{
        string(virtualmachinescalesets.StorageAccountTypesPremiumLRS),
        string(virtualmachinescalesets.StorageAccountTypesPremiumVTwoLRS),
        string(virtualmachinescalesets.StorageAccountTypesPremiumZRS),
        string(virtualmachinescalesets.StorageAccountTypesStandardLRS),
        string(virtualmachinescalesets.StorageAccountTypesStandardSSDLRS),
        string(virtualmachinescalesets.StorageAccountTypesStandardSSDZRS),
        string(virtualmachinescalesets.StorageAccountTypesUltraSSDLRS),
    }, false),
},
```

**Key Properties:**
- **Type:** String
- **Required:** Yes
- **ValidateFunc:** StringInSlice with 7 allowed values
- **ForceNew:** No
- **DiffSuppressFunc:** No
- **Computed:** No

## Azure API Schema

**Resource Type:** `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

**Property Path:** `body.properties.virtualMachineProfile.storageProfile.dataDisks[*].managedDisk.storageAccountType`

**Type:** String (optional in API, but required by provider logic)

**Valid Values:** The Azure API accepts the following storage account types:
- `Premium_LRS`
- `PremiumV2_LRS`
- `Premium_ZRS`
- `Standard_LRS`
- `StandardSSD_LRS`
- `StandardSSD_ZRS`
- `UltraSSD_LRS`

## Hidden Fields

None. The expand function directly assigns the value from the Terraform configuration without any additional fields or transformations.

## Mapping

| AzureRM (Terraform) | Azure API | Notes |
|---------------------|-----------|-------|
| `data_disk[*].storage_account_type` | `dataDisks[*].managedDisk.storageAccountType` | String, direct mapping with type conversion |

**Naming Convention:**
- Terraform: `storage_account_type` (snake_case)
- Azure API: `storageAccountType` (camelCase)

## Special Handling

### Validation

**Implemented in variables.tf:**

```hcl
validation {
  condition = (
    var.orchestrated_virtual_machine_scale_set_data_disk == null ||
    alltrue([
      for disk in var.orchestrated_virtual_machine_scale_set_data_disk :
      contains(["Premium_LRS", "PremiumV2_LRS", "Premium_ZRS", "Standard_LRS", "StandardSSD_LRS", "StandardSSD_ZRS", "UltraSSD_LRS"], disk.storage_account_type)
    ])
  )
  error_message = "The storage_account_type must be one of: Premium_LRS, PremiumV2_LRS, Premium_ZRS, Standard_LRS, StandardSSD_LRS, StandardSSD_ZRS, UltraSSD_LRS."
}
```

**Provider Schema Evidence:**
```go
ValidateFunc: validation.StringInSlice([]string{
    string(virtualmachinescalesets.StorageAccountTypesPremiumLRS),      // "Premium_LRS"
    string(virtualmachinescalesets.StorageAccountTypesPremiumVTwoLRS),  // "PremiumV2_LRS"
    string(virtualmachinescalesets.StorageAccountTypesPremiumZRS),      // "Premium_ZRS"
    string(virtualmachinescalesets.StorageAccountTypesStandardLRS),     // "Standard_LRS"
    string(virtualmachinescalesets.StorageAccountTypesStandardSSDLRS),  // "StandardSSD_LRS"
    string(virtualmachinescalesets.StorageAccountTypesStandardSSDZRS),  // "StandardSSD_ZRS"
    string(virtualmachinescalesets.StorageAccountTypesUltraSSDLRS),     // "UltraSSD_LRS"
}, false),
```

**Rationale:** The provider enforces this validation to ensure only valid storage account types are specified. This validation MUST be implemented in variables.tf to replicate the exact provider behavior.

### Related Validation (Cross-Field)

Note: There are cross-field validations related to `ultra_ssd_disk_iops_read_write` and `ultra_ssd_disk_mbps_read_write` that check `storage_account_type`:

```go
if iops > 0 && !ultraSSDEnabled && storageAccountType != virtualmachinescalesets.StorageAccountTypesPremiumVTwoLRS {
    return nil, fmt.Errorf("`ultra_ssd_disk_iops_read_write` can only be set when `storage_account_type` is set to `PremiumV2_LRS` or `UltraSSD_LRS`")
}

if mbps > 0 && !ultraSSDEnabled && storageAccountType != virtualmachinescalesets.StorageAccountTypesPremiumVTwoLRS {
    return nil, fmt.Errorf("`ultra_ssd_disk_mbps_read_write` can only be set when `storage_account_type` is set to `PremiumV2_LRS` or `UltraSSD_LRS`")
}
```

These cross-field validations will be implemented in Task #40 and Task #41 respectively, as they are the "owning" tasks for those fields.

### ForceNew

**Not applicable** - The schema does not specify `ForceNew: true` for this field, and there is no `CustomizeDiff` logic that forces replacement based on this field.

### Sensitive

**Not applicable** - This field is not marked as Sensitive.

## Critical Review & Edge Case Analysis

### Null Semantics

**Field-level null:** The field is marked as `Required: true` in the provider schema, so it cannot be null within a data_disk object. However, it's defined as non-optional `string` in the variable type, which correctly enforces this requirement.

**Parent-level null:** When the parent `data_disk` list is null, this field is not evaluated.

**Azure API behavior:** The Azure API expects this field when a data disk is defined. The provider enforces this by making the field required.

### Boundary Conditions

**Valid values:** Only the 7 storage account types listed in the validation are accepted.

**Invalid values:** Any other string will be rejected by the validation at plan time, preventing API errors.

### Idempotency

**Direct assignment:** The value is directly assigned without transformation, ensuring idempotent behavior.

**No ordering concerns:** As a scalar string value within each disk object, there are no ordering issues.

### Safe References

**Parent check:** The field is only accessed within the `for data_disk in var.orchestrated_virtual_machine_scale_set_data_disk` loop, which is protected by the parent null check `var.orchestrated_virtual_machine_scale_set_data_disk != null`.

**Field access:** The field `data_disk.storage_account_type` is safely accessed because the variable type definition ensures it exists as a non-optional string.

### Edge Cases

1. **Empty string:** The validation prevents empty strings by requiring the value to be in the allowed list.

2. **Case sensitivity:** The validation uses exact string matching (`contains()` with specific casing), matching the provider's case-sensitive validation.

3. **Nested object creation:** The `managedDisk` object is created for each disk, with `storageAccountType` as a required field. This matches the provider's behavior of always creating the `ManagedDisk` struct with this field.

4. **Multi-disk scenario:** Each disk in the list independently specifies its storage account type, allowing different storage types across disks (as intended by the provider).

## Completion Checklist

- ✅ Field added to correct local (local.body)
- ✅ Correct mapping (storage_account_type → storageAccountType)
- ✅ Correct nesting (within managedDisk object)
- ✅ Validation implemented in variables.tf
- ✅ ALL provider logic EXACTLY replicated (direct assignment, enum validation)
- ✅ No ForceNew required (not in schema, no CustomizeDiff)
- ✅ Hidden fields checked (none)
- ✅ Critical review completed (null, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis documented
- ✅ Proof created
- ✅ Ready for track.md update
- ✅ Self-Review: Only added storage_account_type field - no other fields added

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-08
**Task:** #35 - data_disk.storage_account_type

### Validation Results

✅ **ForceNew Logic:** Not applicable - field does not have ForceNew in schema, no CustomizeDiff logic
✅ **Stable Keys:** All keys in data structure are stable (no conditional key addition/removal)
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase)
✅ **Type Conversion:** Correct direct mapping from string to string with camelCase conversion
✅ **Null Handling:** Correctly propagates null semantics - parent-level null check protects field access
✅ **Validations:** ALL provider validations implemented - StringInSlice with 7 allowed values replicated exactly in variables.tf
✅ **Assignment Path:** Correctly traces to `properties.virtualMachineProfile.storageProfile.dataDisks[*].managedDisk.storageAccountType`
✅ **Sensitive/WriteOnly:** Correctly placed in `body` (not Sensitive or WriteOnly)
✅ **Scope Compliance:** Only implements storage_account_type field, no extra fields added
✅ **Edge Cases:** All edge cases properly analyzed (empty string prevented by validation, case-sensitive matching, multi-disk support)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The validation logic precisely matches the provider's `StringInSlice` validation with all 7 allowed storage account types. The field is correctly nested within the `managedDisk` object structure, properly mapped with camelCase naming, and appropriately placed in the Create phase. Cross-field validations that reference this field are correctly deferred to the owning tasks (Tasks #40 and #41). No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
