# Task #123: os_profile.windows_configuration.additional_unattend_content - Block Skeleton

## Summary

Created the block skeleton structure for `additional_unattend_content` nested block within `windows_configuration`. This block is a list that allows configuring additional unattended content for Windows setup. The skeleton creates a conditional list transformation with placeholder comments for child fields (content and setting) to be implemented in Tasks #124-125.

## Shadow Implementation

```hcl
locals {
  body = merge(
    {
      properties = merge(
        # ... other properties ...
        var.orchestrated_virtual_machine_scale_set_sku_name != null ? {
          virtualMachineProfile = merge(
            # ... other virtualMachineProfile properties ...
            var.orchestrated_virtual_machine_scale_set_os_profile != null ? {
              osProfile = merge(
                # ... other osProfile properties ...
                var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration != null ? merge(
                  # ... parent osProfile level fields ...
                  {
                    windowsConfiguration = merge(
                      # ... other windowsConfiguration properties ...
                      var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.additional_unattend_content != null ? { # <-
                        additionalUnattendContent = [ # <-
                          for content in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.additional_unattend_content : { # <-
                            # content = ... # Task #124 # <-
                            # setting = ... # Task #125 # <-
                          } # <-
                        ] # <-
                      } : {}, # <-
                      {
                        # winRM = { # Task #131-133
                        #   listeners = ... # Task #131-133
                        # }
                        # secrets = ... # Task #126-130
                      }
                    )
                  }
                ) : {}
              )
            } : {}
          )
        } : {}
      )
    }
  )
}
```

## Create Phase Verification

### Query Results

Queried the Create method using `query_terraform_block_implementation_source_code` with `entrypoint_name=create`.

**Pattern:** Single-phase creation

From the Create method:

```go
osProfileRaw := d.Get("os_profile").([]interface{})

if len(osProfileRaw) > 0 && osProfileRaw[0] != nil {
    osProfile := osProfileRaw[0].(map[string]interface{})
    winConfigRaw = osProfile["windows_configuration"].([]interface{})
    customData := ""

    if v := osProfile["custom_data"]; v != nil {
        customData = v.(string)
    }

    if len(winConfigRaw) > 0 && winConfigRaw[0] != nil {
        osType = virtualmachinescalesets.OperatingSystemTypesWindows
        winConfig := winConfigRaw[0].(map[string]interface{})
        vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(winConfig, customData)
        // ... validation logic ...
    }

    if vmssOsProfile != nil {
        osProfile.AllowExtensionOperations = pointer.To(extensionOperationsEnabled)
    }

    virtualMachineProfile.OsProfile = vmssOsProfile
}

props := virtualmachinescalesets.VirtualMachineScaleSet{
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        VirtualMachineProfile: &virtualMachineProfile,
        // ...
    },
}

if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Classification:** Create phase - the field is processed during the expand function call before the CreateOrUpdateThenPoll call.

**Decision:** Place in `local.body` (not in `post_creation_updates`).

## Assignment Path Verification

### Predicted Path

```
properties.virtualMachineProfile.osProfile.windowsConfiguration.additionalUnattendContent
```

### Go Code Evidence

From Task #113 proof document, the expand function sets additionalUnattendContent inside windowsConfiguration:

```go
func expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(input map[string]interface{}, customData string) *virtualmachinescalesets.VirtualMachineScaleSetOSProfile {
    osProfile := &virtualmachinescalesets.VirtualMachineScaleSetOSProfile{}
    winConfig := &virtualmachinescalesets.WindowsConfiguration{}
    
    // ... other fields ...
    
    if v, ok := input["additional_unattend_content"].([]interface{}); ok && len(v) > 0 {
        winConfig.AdditionalUnattendContent = expandAdditionalUnattendContentVMSS(v)
    }
    
    // ... other fields ...
    
    osProfile.WindowsConfiguration = winConfig
    
    return osProfile
}
```

Tracing the assignment:
1. `winConfig.AdditionalUnattendContent = expandAdditionalUnattendContentVMSS(v)` - sets on `WindowsConfiguration`
2. `osProfile.WindowsConfiguration = winConfig` - assigns to `VirtualMachineScaleSetOSProfile.WindowsConfiguration`
3. `virtualMachineProfile.OsProfile = vmssOsProfile` - assigns to `VirtualMachineProfile.OsProfile`
4. `props.Properties.VirtualMachineProfile = &virtualMachineProfile` - assigns to props

### Verified Path

```
properties.virtualMachineProfile.osProfile.windowsConfiguration.additionalUnattendContent
```

### Path Comparison

✅ **MATCH** - Predicted path matches verified path exactly.

## Provider Schema

From the schema query and Task #113 proof document:

```go
"additional_unattend_content": additionalUnattendContentSchema(),

func additionalUnattendContentSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        ForceNew: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "content": {
                    Type:      pluginsdk.TypeString,
                    Required:  true,
                    ForceNew:  true,
                    Sensitive: true,
                },
                "setting": {
                    Type:     pluginsdk.TypeString,
                    Required: true,
                    ForceNew: true,
                    ValidateFunc: validation.StringInSlice([]string{
                        string(virtualmachines.SettingNamesAutoLogon),
                        string(virtualmachines.SettingNamesFirstLogonCommands),
                    }, false),
                },
            },
        },
    }
}
```

**Key Attributes:**
- **Type:** `TypeList` (ordered collection)
- **Optional:** `true`
- **ForceNew:** `true` (entire block)
- **Child Fields:**
  - `content` (Required, ForceNew, Sensitive)
  - `setting` (Required, ForceNew, validated enum)

## Azure API Schema

From the Azure API schema query in Task #113 proof document:

```
"additionalUnattendContent": List(ObjectWithOptionalAttrs(map[string]Type{
    "componentName": String,
    "content": String,
    "passName": String,
    "settingName": String
}, []string{"componentName", "content", "passName", "settingName"}))
```

**Property Path:** `body.properties.virtualMachineProfile.osProfile.windowsConfiguration.additionalUnattendContent`

**API Type:** List of objects with 4 optional fields.

**Exposed vs Hidden Fields:**
- Exposed in Terraform: `content`, `setting` (maps to `settingName`)
- Hidden (hardcoded in provider): `componentName`, `passName`

## Hidden Fields Detection

### From Expand Function Analysis

From the provider's expand function for additional_unattend_content (referenced in Task #113):

The Azure API has **TWO hidden fields** that are NOT exposed in Terraform schema but are hardcoded in the expand function:

1. **`componentName`** - Hardcoded to `"Microsoft-Windows-Shell-Setup"`
2. **`passName`** - Hardcoded to `"OobeSystem"`

**Evidence:** The expand function `expandAdditionalUnattendContentVMSS` hardcodes these values:

```go
func expandAdditionalUnattendContentVMSS(input []interface{}) *[]virtualmachinescalesets.AdditionalUnattendContent {
    output := make([]virtualmachinescalesets.AdditionalUnattendContent, 0)

    for _, v := range input {
        raw := v.(map[string]interface{})

        content := virtualmachinescalesets.AdditionalUnattendContent{
            ComponentName: pointer.To(virtualmachinescalesets.ComponentNamesWindowsNegativeShellNegativeSetup),  // Hardcoded
            Content:       pointer.To(raw["content"].(string)),
            PassName:      pointer.To(virtualmachinescalesets.PassNamesOobeSystem),  // Hardcoded
            SettingName:   pointer.To(virtualmachinescalesets.SettingNames(raw["setting"].(string))),
        }
        
        output = append(output, content)
    }

    return &output
}
```

**Status:** These hidden fields will be added when implementing child task #124 (content), as that task needs to build the complete object structure.

**Implementation Note for Task #124:** The child task must include:
```hcl
componentName = "Microsoft-Windows-Shell-Setup"
passName = "OobeSystem"
```

### Hidden Fields Summary

This skeleton task does NOT implement the hidden fields. They will be added in Task #124 when building the complete object structure, because they are part of each list item along with the user-provided `content` and `setting` fields.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Task # |
|---|---|---|
| additional_unattend_content | additionalUnattendContent | #123 (skeleton) |
| content | content | #124 |
| setting | settingName | #125 |
| (hidden) | componentName | #124 (hardcoded: "Microsoft-Windows-Shell-Setup") |
| (hidden) | passName | #124 (hardcoded: "OobeSystem") |

**Note:** The hidden fields `componentName` and `passName` are hardcoded constants in the provider and will be added in Task #124.

## Special Handling

### Block Type: List

The block is a `TypeList` (ordered collection), not a set. This means:
- Order matters and is preserved
- Duplicates are allowed
- Use `for` list comprehension (not `for` with explicit keys)

### ForceNew Behavior

The entire block and both child fields are marked `ForceNew: true`. Any change to `additional_unattend_content` requires resource replacement.

**Implementation:** Will be handled in parent `replace_triggers_external_values` in Task #113 (already completed). Individual child fields don't need separate ForceNew tracking since the entire block is ForceNew.

### Sensitive Field

The `content` field is marked `Sensitive: true`. Task #124 will need to handle this with an independent ephemeral variable following the nested block sensitive field pattern from executor.md.

### Hardcoded Constants

The Azure API requires two additional fields that are NOT exposed in Terraform schema:
- `componentName`: Must be `"Microsoft-Windows-Shell-Setup"`
- `passName`: Must be `"OobeSystem"`

These are hardcoded in the provider's expand function and will be added in Task #124.

### Validation

The `setting` field has validation (Task #125):
- Must be one of: `"AutoLogon"` or `"FirstLogonCommands"`
- Corresponds to enum: `virtualmachines.SettingNamesAutoLogon`, `virtualmachines.SettingNamesFirstLogonCommands`

## Validation

### Category 1 - Value Constraints

No direct value constraints for the block skeleton itself. Child fields have their own validations:
- Task #124 (`content`): No specific validation beyond being a string (required)
- Task #125 (`setting`): Enum validation (AutoLogon, FirstLogonCommands)

### Category 2 - Cross-Field Constraints

None at the block skeleton level.

### Category 3 - Custom Logic

No custom validation logic required for the block skeleton.

## Deferred Work

### Checking following.md

Checked `following.md` - file does not exist yet, so no deferred work to complete.

### New Deferrals

None. This skeleton task does not defer any work to other tasks.

## Critical Review & Edge Case Analysis

### Null Semantics

- **`null` value:** When `additional_unattend_content` is `null`, the entire `additionalUnattendContent` key is omitted from the Azure API payload (via conditional merge with empty object)
- **Empty list:** If user provides an empty list `[]`, the block is non-null but the list iteration produces no items. The Azure API will receive an empty array.
- **Behavior:** Both `null` and empty list are valid and have same effect (no additional unattend content)

### Boundary Conditions

- **Minimum items:** No `MinItems` constraint in schema. An empty list is valid.
- **Maximum items:** No `MaxItems` constraint. Multiple items are allowed.
- **List ordering:** Since this is a `TypeList`, order is preserved. Windows setup may process items in order.

### Idempotency

- **List transformation:** The `for` comprehension preserves order and produces consistent output for the same input
- **Conditional merge:** The `!= null` check ensures deterministic behavior - block is either present or absent
- **No ordering issues:** List order is preserved, ensuring idempotent applications

### Safe References

- **Null safety:** The conditional check `var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.additional_unattend_content != null` protects against null reference errors
- **Parent existence:** This block is nested inside `windows_configuration`, which is already checked for null in Task #113
- **Variable reference:** Uses the full qualified path which is safe since parent checks are in place

### Edge Case: Empty vs Null

- **Null list:** Block not configured → Azure API receives no `additionalUnattendContent` field
- **Empty list `[]`:** Block configured but no items → Azure API receives `additionalUnattendContent: []`
- **Terraform behavior:** Both are valid, but empty list explicitly sets the field while null omits it
- **Impact:** Functionally equivalent for Windows setup, but different in API semantics

### Edge Case: Sensitive Content Security

Task #124 must handle the `content` field as sensitive using independent ephemeral variables. The list transformation in this skeleton is compatible with this pattern.

### Edge Case: Multiple Items

Windows allows multiple additional unattend content items (e.g., both AutoLogon and FirstLogonCommands). The list structure correctly supports this.

### Edge Case: Hardcoded Fields

The hidden fields (`componentName`, `passName`) are consistent across all items in the list. Task #124 must replicate these exact constant values in each list item.

## Child Tasks Ready for Delegation

The following child tasks are now **READY** for implementation as the parent skeleton structure is in place:

| Task # | Field | Type | Required | Dependent On | Notes |
|--------|-------|------|----------|--------------|-------|
| 124 | os_profile.windows_configuration.additional_unattend_content.content | Argument | Yes | Skeleton #123 ✅ | Sensitive field - needs independent ephemeral variable |
| 125 | os_profile.windows_configuration.additional_unattend_content.setting | Argument | Yes | Skeleton #123 ✅ | Enum validation required |

**Implementation Notes for Child Tasks:**

1. **Task #124 (content):** 
   - Must create independent ephemeral variable in `migrate_variables.tf`
   - Must add version variable with validation
   - Must include hidden fields: `componentName = "Microsoft-Windows-Shell-Setup"` and `passName = "OobeSystem"`
   - Place value in `sensitive_body` (not `body`)

2. **Task #125 (setting):**
   - Maps to `settingName` in Azure API
   - Must validate enum: ["AutoLogon", "FirstLogonCommands"]
   - Place in regular `body` (not sensitive)

Both tasks must work within the list comprehension established by this skeleton.

## Completion Checklist

- ✅ Property in correct local (`local.body`)
- ✅ Block structure skeleton created with comment placeholders for child fields
- ✅ Conditional logic based on variable null check
- ✅ ForceNew: Handled at parent level (entire block is ForceNew)
- ✅ Validations: No validations at block skeleton level
- ✅ Hidden fields identified and documented (componentName, passName)
- ✅ Deferred work: Checked following.md (none to complete, none to defer)
- ✅ Critical review completed
- ✅ Edge case analysis included
- ✅ Proof document created
- ✅ `track.md` will be updated to "Pending for check"
- ✅ Self-Review: Only skeleton structure created, no child field implementations

## Notes

1. **Skeleton Only:** This task creates ONLY the block structure framework with list comprehension. Child fields (#124-125) will be implemented in their respective tasks.

2. **List vs Set:** This is a `TypeList`, not a `TypeSet`. Order is preserved and matters for Windows setup processing.

3. **Hidden Fields Strategy:** The two hardcoded Azure API fields (`componentName`, `passName`) will be added by Task #124 when building the complete object structure for each list item.

4. **Sensitive Field Handling:** Task #124 must follow the nested block sensitive field pattern with independent ephemeral variables as documented in executor.md.

5. **ForceNew Scope:** The entire block is ForceNew, so any change to additional_unattend_content (add/remove/modify items) triggers replacement. This is already tracked at the parent level.

6. **Integration with Windows Configuration:** This block is part of windowsConfiguration (not parent osProfile level), consistent with Task #113 structure.

7. **Azure Setup Process:** Additional unattend content is processed during Windows OOBE (Out of Box Experience) setup, allowing automation of first logon and auto logon scenarios.

8. **Multiple Items Support:** The list structure correctly supports multiple unattend content items, which is a valid Windows configuration (e.g., both AutoLogon and FirstLogonCommands).

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #123 - os_profile.windows_configuration.additional_unattend_content

### Validation Results

✅ **Block Skeleton Structure:** Correctly created with list comprehension and comment placeholders for child fields (Tasks #124-125)
✅ **Conditional Logic:** Proper null check with merge pattern (empty object fallback)
✅ **Placement:** Correctly placed in `local.body` (Create phase) at verified path: `properties.virtualMachineProfile.osProfile.windowsConfiguration.additionalUnattendContent`
✅ **Type Handling:** TypeList properly handled with list comprehension preserving order
✅ **Mapping:** Correct snake_case → camelCase conversion (additional_unattend_content → additionalUnattendContent)
✅ **Shared Path Merge:** No duplicate parent keys - `windowsConfiguration` appears only once, all children properly merged inside
✅ **Null Handling:** Safe null semantics - null omits field, empty list produces empty array
✅ **Hidden Fields Documentation:** ComponentName and passName documented for Task #124
✅ **Deferred Work Completion:** No deferred work for this task in following.md
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** Comprehensive analysis of null/empty list, multiple items, and list ordering

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The block skeleton correctly establishes the list comprehension structure for child tasks #124-125 to complete. No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
