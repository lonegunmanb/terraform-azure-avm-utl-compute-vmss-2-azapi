# Task #120: os_profile.windows_configuration.patch_mode

## Summary

Implemented the `patch_mode` argument for Windows configuration in the Shadow Module. This field controls the mode of in-guest patching for Windows virtual machines, with allowed values "AutomaticByOS" (default), "AutomaticByPlatform", and "Manual". The field maps to `patchSettings.patchMode` in the Azure API.

## Shadow Implementation

```hcl
# variables.tf
variable "orchestrated_virtual_machine_scale_set_os_profile" {
  type = object({
    windows_configuration = optional(object({
      patch_mode = optional(string, "AutomaticByOS") # <-
    }))
  })

  validation { # <-
    condition = var.orchestrated_virtual_machine_scale_set_os_profile == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_mode == null || contains(["AutomaticByOS", "AutomaticByPlatform", "Manual"], var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_mode) # <-
    error_message = "The patch_mode must be one of 'AutomaticByOS', 'AutomaticByPlatform', or 'Manual'." # <-
  } # <-

  validation { # <-
    condition = var.orchestrated_virtual_machine_scale_set_os_profile == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_mode != "AutomaticByPlatform" || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.provision_vm_agent != false # <-
    error_message = "When patch_mode is set to 'AutomaticByPlatform', provision_vm_agent must be set to true." # <-
  } # <-
}

# migrate_main.tf
locals {
  body = {
    properties = merge(
      var.orchestrated_virtual_machine_scale_set_os_profile != null ? {
        virtualMachineProfile = merge(
          {
            osProfile = merge(
              var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration != null ? merge( # <-
                { # <-
                  windowsConfiguration = merge( # <-
                    { # <-
                      enableAutomaticUpdates = var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.enable_automatic_updates # <-
                    }, # <-
                    { # <-
                      patchSettings = merge( # <-
                        { # <-
                          enableHotpatching = var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.hotpatching_enabled # <-
                        }, # <-
                        var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_assessment_mode != null ? { # <-
                          assessmentMode = var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_assessment_mode # <-
                        } : {}, # <-
                        { # <-
                          patchMode = var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_mode # <-
                        } # <-
                      ) # <-
                    } # <-
                  ) # <-
                } # <-
              ) : {} # <-
            )
          }
        )
      } : {}
    )
  }
}
```

## Create Phase Verification

### Pattern Identification

**Queried Create Method:**

Based on the Windows configuration expand function `expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration`:

```go
func expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(input map[string]interface{}, customData string) *virtualmachinescalesets.VirtualMachineScaleSetOSProfile {
    osProfile := virtualmachinescalesets.VirtualMachineScaleSetOSProfile{}
    winConfig := virtualmachinescalesets.WindowsConfiguration{}
    patchSettings := virtualmachinescalesets.PatchSettings{}

    if len(input) > 0 {
        // ... other fields ...
        
        patchSettings.AssessmentMode = pointer.To(virtualmachinescalesets.WindowsPatchAssessmentMode(input["patch_assessment_mode"].(string)))
        patchSettings.PatchMode = pointer.To(virtualmachinescalesets.WindowsVMGuestPatchMode(input["patch_mode"].(string)))
        patchSettings.EnableHotpatching = pointer.To(input["hotpatching_enabled"].(bool))
        winConfig.PatchSettings = &patchSettings
    }

    osProfile.WindowsConfiguration = &winConfig

    return &osProfile
}
```

And from Create method:
```go
if len(winConfigRaw) > 0 && winConfigRaw[0] != nil {
    osType = virtualmachinescalesets.OperatingSystemTypesWindows
    winConfig := winConfigRaw[0].(map[string]interface{})
    vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(winConfig, customData)

    // Later assignment
    virtualMachineProfile.OsProfile = vmssOsProfile
}

// Final assignment in single phase
props.Properties.VirtualMachineProfile = &virtualMachineProfile
client.CreateOrUpdateThenPoll(ctx, id, props, ...)
```

**Pattern:** Single-phase creation. The field is set during the Create phase before the `CreateOrUpdateThenPoll` call.

**Classification:** Create phase → Assign to `local.body`

### Decision

The `patch_mode` field will be added to `local.body` as it's set during the single-phase create operation. No two-phase pattern detected.

## Assignment Path Verification

### Predicted Path

`body.properties.virtualMachineProfile.osProfile.windowsConfiguration.patchSettings.patchMode`

### Go Code Evidence

From the expand function chain:

```go
// Step 1: expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration
patchSettings.AssessmentMode = pointer.To(virtualmachinescalesets.WindowsPatchAssessmentMode(input["patch_assessment_mode"].(string)))
patchSettings.PatchMode = pointer.To(virtualmachinescalesets.WindowsVMGuestPatchMode(input["patch_mode"].(string)))
patchSettings.EnableHotpatching = pointer.To(input["hotpatching_enabled"].(bool))
winConfig.PatchSettings = &patchSettings
osProfile.WindowsConfiguration = &winConfig
return &osProfile

// Step 2: In Create method
virtualMachineProfile.OsProfile = vmssOsProfile

// Step 3: In Create method
props.Properties.VirtualMachineProfile = &virtualMachineProfile

// Step 4: API call
client.CreateOrUpdateThenPoll(ctx, id, props, ...)
```

**Verified Path:** `properties.virtualMachineProfile.osProfile.windowsConfiguration.patchSettings.patchMode`

**Path Comparison:** ✅ Match - predicted path is correct

## Provider Schema

**Query:** Based on provider source code (schema for windows_configuration)

**Field Properties:**
- Type: String
- Optional: true
- Default: "AutomaticByOS" (WindowsVMGuestPatchModeAutomaticByOS)
- ForceNew: false (not specified)
- Sensitive: false
- Computed: false
- ValidateFunc: StringInSlice with values ["AutomaticByOS", "AutomaticByPlatform", "Manual"]

From Go source:
```go
"patch_mode": {
    Type:     pluginsdk.TypeString,
    Optional: true,
    Default:  string(virtualmachinescalesets.WindowsVMGuestPatchModeAutomaticByOS),
    ValidateFunc: validation.StringInSlice([]string{
        string(virtualmachinescalesets.WindowsVMGuestPatchModeAutomaticByOS),
        string(virtualmachinescalesets.WindowsVMGuestPatchModeAutomaticByPlatform),
        string(virtualmachinescalesets.WindowsVMGuestPatchModeManual),
    }, false),
},
```

## Azure API Schema

**Query:** `query_azapi_resource_schema(resource_type="Microsoft.Compute/virtualMachineScaleSets", api_version="2024-11-01", path="body.properties.virtualMachineProfile.osProfile.windowsConfiguration.patchSettings.patchMode")`

**Result:** String

**API Property:** `properties.virtualMachineProfile.osProfile.windowsConfiguration.patchSettings.patchMode`

**Type:** String (optional)

**Valid Values:** "AutomaticByOS", "AutomaticByPlatform", "Manual"

## Hidden Fields

None. The field is directly exposed in the Terraform schema.

## Mapping

**Terraform (snake_case):** `patch_mode`

**Azure API (camelCase):** `patchMode`

**Mapping Rule:** Direct mapping with case conversion (snake_case → camelCase)

## Special Handling

### Validation (Category 1 - Value Constraints)

**Implemented in variables.tf:**

1. **Value constraint validation:**
   ```hcl
   validation {
     condition = var.orchestrated_virtual_machine_scale_set_os_profile == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_mode == null || contains(["AutomaticByOS", "AutomaticByPlatform", "Manual"], var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_mode)
     error_message = "The patch_mode must be one of 'AutomaticByOS', 'AutomaticByPlatform', or 'Manual'."
   }
   ```

   **Evidence:** Provider schema specifies ValidateFunc with StringInSlice for three allowed values

### Validation (Category 2 - Cross-Field Constraints)

**Implemented in variables.tf:**

2. **Cross-field validation with provision_vm_agent:**
   ```hcl
   validation {
     condition = var.orchestrated_virtual_machine_scale_set_os_profile == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_mode != "AutomaticByPlatform" || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.provision_vm_agent != false
     error_message = "When patch_mode is set to 'AutomaticByPlatform', provision_vm_agent must be set to true."
   }
   ```

   **Evidence:** From Create method validation logic:
   ```go
   if patchMode == string(virtualmachinescalesets.WindowsVMGuestPatchModeAutomaticByPlatform) {
       if !provisionVMAgent {
           return fmt.Errorf("when `patch_mode` is set to `%s`, `provision_vm_agent` must be set to `true`", patchMode)
       }

       if !hasHealthExtension {
           return fmt.Errorf("when `patch_mode` is set to `%s`, an application health extension must be configured", patchMode)
       }
   }
   ```

   **Note on Health Extension Validation:** The health extension validation (`!hasHealthExtension` check) is referenced in `following.md` Task #118 as deferred work involving multiple tasks. This validation requires checking the `extension` block for health extensions, which is cross-block logic that cannot be implemented in the `os_profile` variable validation. The Azure API will enforce this validation during resource creation.

### Default Value

**Default:** "AutomaticByOS"

**Implementation:**
- Set in `variables.tf`: `optional(string, "AutomaticByOS")`
- This matches provider default: `Default: string(virtualmachinescalesets.WindowsVMGuestPatchModeAutomaticByOS)`

### ForceNew

Not applicable. The provider schema does not specify ForceNew for this field, and no CustomizeDiff logic was found for this field.

### Sensitive

Not applicable. The field is not sensitive.

### Post-Creation Update

Not applicable. The field is set in the Create phase.

## Deferred Work Completion

Checked `following.md` - Task #118 references this task as part of complex hotpatching validations. The validation deferred from Task #118 involves:
1. When using hotpatch-enabled images: `patch_mode` must be `AutomaticByPlatform`
2. When NOT using hotpatch-enabled images and `patch_mode` is `AutomaticByPlatform`: health extension required

The health extension validation is noted in this task but cannot be fully implemented here due to cross-block constraints. The image-based validation referenced in Task #118 requires image reference parsing logic that will be implemented when Task #118 processes all deferred validations together.

**Status:** Task #120 completes its core implementation. Complex cross-block validations remain tracked in `following.md` Task #118.

## Critical Review & Edge Case Analysis

### Null Semantics

- **null value:** Field is omitted from config, provider applies default "AutomaticByOS"
- **Shadow Module:** `optional(string, "AutomaticByOS")` applies same default
- Result: Semantically identical ✅

### Edge Cases

1. **Empty string:** Rejected by validation - must be one of the allowed values
2. **Invalid value:** Rejected by validation - must be "AutomaticByOS", "AutomaticByPlatform", or "Manual"
3. **AutomaticByPlatform without provisionVMAgent:** Rejected by cross-field validation
4. **AutomaticByPlatform without health extension:** Cannot validate (cross-block), Azure API will enforce
5. **Hotpatching scenarios:** Tracked in `following.md` Task #118 for deferred implementation

### Idempotency

✅ The implementation is idempotent:
- Same input always produces same output
- No order-dependent operations
- Deterministic conditional logic
- Default value consistently applied

### Safe References

✅ All references are safe:
- Parent block (`windows_configuration`) existence is checked before accessing `patch_mode`
- Cross-field validation safely checks provision_vm_agent using `!= false` instead of `== true` to handle null values correctly (similar to Task #119 pattern)
- Nested merge ensures `patchSettings` key remains stable

### Structural Considerations

**Merge Strategy:**
The implementation uses nested `merge()` within the existing `patchSettings` object:
1. `patchSettings` appears exactly once at the top level of windowsConfiguration
2. Three fields are merged within patchSettings: `enableHotpatching`, `assessmentMode` (conditional), and `patchMode` (always present)
3. This matches the corrected structure from Task #119 after checker validation

**Key Stability:**
- `patchSettings` key: Always present (stable)
- `enableHotpatching`: Always present (from Task #118)
- `assessmentMode`: Conditionally present (from Task #119)
- `patchMode`: Always present (this task) - uses default value when null, so never omitted

This ensures the structure remains stable across applies.

## Checklist

- ✅ Property in correct local (body)
- ✅ ForceNew wrapped: N/A (not ForceNew)
- ✅ ALL logic EXACTLY replicated from provider (validations match provider behavior, health extension validation noted as cross-block constraint)
- ✅ Validations IMPLEMENTED in variables.tf (value constraint + cross-field validation with provision_vm_agent)
- ✅ TODO comment: N/A (not a sensitive field)
- ✅ Hidden fields checked: None
- ✅ Deferred work in following.md: Acknowledged Task #118 complex validations
- ✅ Deferred work from following.md: Acknowledged but cannot fully implement health extension validation (cross-block)
- ✅ Critical review (null, edge, idempotent, safe refs): Completed
- ✅ Edge Case Analysis in proof: Included above
- ✅ Proof created: This document
- ✅ track.md will be updated: To "Pending for check"
- ✅ Self-Review: Implementation only covers patch_mode for Windows configuration, no other fields added
- ✅ Default value: "AutomaticByOS" matches provider default exactly

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #120 - os_profile.windows_configuration.patch_mode

### Validation Results

✅ **ForceNew Logic:** Not applicable - field is not ForceNew
✅ **Stable Keys:** All keys in windowsConfiguration.patchSettings are stable (enableHotpatching, assessmentMode conditional, patchMode always present)
✅ **Phase Detection:** Field correctly placed in local.body (Create phase)
✅ **Type Conversion:** String to String - direct mapping
✅ **Null Handling:** Default value "AutomaticByOS" applied via optional(string, "AutomaticByOS")
✅ **Validations:** All provider validations implemented correctly:
  - Value constraint: StringInSlice with ["AutomaticByOS", "AutomaticByPlatform", "Manual"] ✅
  - Cross-field validation: When patch_mode = "AutomaticByPlatform", provision_vm_agent must not be false ✅
✅ **Deferred Work Completion:** Task #118 deferred complex hotpatching validations acknowledged appropriately - health extension validation cannot be implemented here due to cross-block constraints (correct decision)
✅ **Deferred Work Recording:** N/A - no new deferrals made
✅ **Edge Cases:** All edge cases properly analyzed and handled (null semantics, invalid values, cross-field constraints)
✅ **Shared Path Merge:** No duplicate parent keys - windowsConfiguration appears once, patchSettings appears once within it
✅ **Default Value:** "AutomaticByOS" matches provider default exactly using preferred optional() syntax

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found. All validations are implemented in variables.tf as required. The default value uses the preferred `optional(string, "AutomaticByOS")` syntax. The nested merge structure is correct with no duplicate parent keys.

**Status:** APPROVED ✅

---

