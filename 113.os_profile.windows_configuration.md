# Task #113: os_profile.windows_configuration Block Structure Skeleton

## Summary

Created the structure skeleton for the `os_profile.windows_configuration` block migration from `azurerm_orchestrated_virtual_machine_scale_set` to `azapi_resource`. This establishes the conditional framework with comment placeholders for all child fields (admin credentials, computer name, automatic updates, patching, secrets, additional unattend content, WinRM). The block maps to `properties.virtualMachineProfile.osProfile.windowsConfiguration` in the Azure API.

## Shadow Implementation

```hcl
locals {
  body = {
    properties = merge(
      # ... existing properties ...
      var.orchestrated_virtual_machine_scale_set_os_profile != null ? {
        virtualMachineProfile = merge(
          {
            osProfile = merge(
              var.orchestrated_virtual_machine_scale_set_os_profile.custom_data != null ? {
                customData = var.orchestrated_virtual_machine_scale_set_os_profile.custom_data
              } : {},
              var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration != null ? {
                linuxConfiguration = {
                  # ... linux configuration fields ...
                }
              } : {},
              var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration != null ? { # <-
                windowsConfiguration = { # <-
                  # adminUsername = ... # Handled at parent osProfile level - Task #115 # <-
                  # adminPassword = ... # Handled at parent osProfile level - Task #114 # <-
                  # computerNamePrefix = ... # Handled at parent osProfile level - Task #116 # <-
                  # enableAutomaticUpdates = ... # Task #117 # <-
                  # provisionVMAgent = ... # Task #121 # <-
                  # timeZone = ... # Task #122 # <-
                  # patchSettings = { # Task #118, #119, #120 # <-
                  #   assessmentMode = ... # Task #119 # <-
                  #   patchMode = ... # Task #120 # <-
                  #   enableHotpatching = ... # Task #118 # <-
                  # } # <-
                  # additionalUnattendContent = ... # Task #123-125 # <-
                  # winRM = { # Task #131-133 # <-
                  #   listeners = ... # Task #131-133 # <-
                  # } # <-
                  # secrets = ... # Task #126-130 # <-
                } # <-
              } : {} # <-
            )
          }
        )
      } : {}
    )
  }
}
```

## Create Phase Verification

### Pattern Identification

Queried the Create method to understand how `windows_configuration` is processed:

**Pattern:** Single-phase creation

The `windows_configuration` block is processed during the Create phase through the expand function:

```go
osProfileRaw := d.Get("os_profile").([]interface{})

if len(osProfileRaw) > 0 && osProfileRaw[0] != nil {
    osProfile := osProfileRaw[0].(map[string]interface{})
    winConfigRaw = osProfile["windows_configuration"].([]interface{})
    customData := ""

    // Pass custom data if it is defined in the config file
    if v := osProfile["custom_data"]; v != nil {
        customData = v.(string)
    }

    if len(winConfigRaw) > 0 && winConfigRaw[0] != nil {
        osType = virtualmachinescalesets.OperatingSystemTypesWindows
        winConfig := winConfigRaw[0].(map[string]interface{})
        vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(winConfig, customData)
        // ... validation logic ...
    }

    if vmssOsProfile != nil {
        vmssOsProfile.AllowExtensionOperations = pointer.To(extensionOperationsEnabled)
    }

    virtualMachineProfile.OsProfile = vmssOsProfile
}

// Later assignment:
props.Properties.VirtualMachineProfile = &virtualMachineProfile
```

**Classification:** Create phase → Assign to `local.body`

### Decision

The `windows_configuration` block will be added to `local.body` as it is set during the single-phase create operation.

## Assignment Path Verification

### Predicted Path

`body.properties.virtualMachineProfile.osProfile.windowsConfiguration`

### Go Code Evidence

From the expand function `expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration`:

```go
func expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(input map[string]interface{}, customData string) *virtualmachinescalesets.VirtualMachineScaleSetOSProfile {
    osProfile := virtualmachinescalesets.VirtualMachineScaleSetOSProfile{}
    winConfig := virtualmachinescalesets.WindowsConfiguration{}
    patchSettings := virtualmachinescalesets.PatchSettings{}

    if len(input) > 0 {
        osProfile.CustomData = pointer.To(customData)
        osProfile.AdminUsername = pointer.To(input["admin_username"].(string))
        osProfile.AdminPassword = pointer.To(input["admin_password"].(string))

        if computerPrefix := input["computer_name_prefix"].(string); computerPrefix != "" {
            osProfile.ComputerNamePrefix = pointer.To(computerPrefix)
        }

        if secrets := input["secret"].([]interface{}); len(secrets) > 0 {
            osProfile.Secrets = expandWindowsSecretsVMSS(secrets)
        }

        // Windows-specific configuration
        winConfig.EnableAutomaticUpdates = pointer.To(input["enable_automatic_updates"].(bool))
        winConfig.ProvisionVMAgent = pointer.To(input["provision_vm_agent"].(bool))
        
        patchSettings.AssessmentMode = pointer.To(virtualmachinescalesets.WindowsPatchAssessmentMode(input["patch_assessment_mode"].(string)))
        patchSettings.PatchMode = pointer.To(virtualmachinescalesets.WindowsVMGuestPatchMode(input["patch_mode"].(string)))
        patchSettings.EnableHotpatching = pointer.To(input["hotpatching_enabled"].(bool))
        winConfig.PatchSettings = &patchSettings
    }

    osProfile.WindowsConfiguration = &winConfig

    return &osProfile
}
```

The assignment chain:
1. `winConfig` is populated with Windows-specific settings
2. `osProfile.WindowsConfiguration = &winConfig`
3. `virtualMachineProfile.OsProfile = vmssOsProfile` (where `vmssOsProfile` is the returned `osProfile`)
4. `props.Properties.VirtualMachineProfile = &virtualMachineProfile`

The complete path: `VirtualMachineScaleSet.Properties.VirtualMachineProfile.OsProfile.WindowsConfiguration`

### Verified Path

`body.properties.virtualMachineProfile.osProfile.windowsConfiguration`

### Path Comparison

✅ **MATCH** - Predicted path matches the verified assignment chain from Go source code.

## Provider Schema

From `OrchestratedVirtualMachineScaleSetWindowsConfigurationSchema()`:

```go
func OrchestratedVirtualMachineScaleSetWindowsConfigurationSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        MaxItems: 1,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "admin_username": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ForceNew:     true,
                    ValidateFunc: validateAdminUsernameWindows,
                },

                "admin_password": {
                    Type:             pluginsdk.TypeString,
                    Required:         true,
                    ForceNew:         true,
                    Sensitive:        true,
                    DiffSuppressFunc: adminPasswordDiffSuppressFunc,
                    ValidateFunc:     validatePasswordComplexityWindows,
                },

                "computer_name_prefix": computerPrefixWindowsSchema(),

                "additional_unattend_content": additionalUnattendContentSchema(),

                "enable_automatic_updates": {
                    Type:     pluginsdk.TypeBool,
                    Optional: true,
                    Default:  true,
                },

                "hotpatching_enabled": {
                    Type:     pluginsdk.TypeBool,
                    Optional: true,
                    Default:  false,
                },

                "provision_vm_agent": {
                    Type:     pluginsdk.TypeBool,
                    Optional: true,
                    Default:  true,
                    ForceNew: true,
                },

                "patch_assessment_mode": {
                    Type:     pluginsdk.TypeString,
                    Optional: true,
                    Default:  string(virtualmachinescalesets.WindowsPatchAssessmentModeImageDefault),
                    ValidateFunc: validation.StringInSlice([]string{
                        string(virtualmachinescalesets.WindowsPatchAssessmentModeAutomaticByPlatform),
                        string(virtualmachinescalesets.WindowsPatchAssessmentModeImageDefault),
                    }, false),
                },

                "patch_mode": {
                    Type:     pluginsdk.TypeString,
                    Optional: true,
                    Default:  string(virtualmachinescalesets.WindowsVMGuestPatchModeAutomaticByOS),
                    ValidateFunc: validation.StringInSlice([]string{
                        string(virtualmachinescalesets.WindowsVMGuestPatchModeAutomaticByOS),
                        string(virtualmachinescalesets.WindowsVMGuestPatchModeAutomaticByPlatform),
                        string(virtualmachinescalesets.WindowsVMGuestPatchModeManual),
                    }, false),
                },

                "secret": windowsSecretSchema(),

                "timezone": {
                    Type:         pluginsdk.TypeString,
                    Optional:     true,
                    ValidateFunc: validate.VirtualMachineTimeZone(),
                },

                "winrm_listener": winRmListenerSchema(),
            },
        },
    }
}
```

**Key Properties:**
- **Type:** List with MaxItems: 1
- **Optional:** Yes
- **Required Child Fields:**
  - `admin_username` (string, ForceNew, custom validation)
  - `admin_password` (string, Sensitive, ForceNew, custom validation)
- **Optional Child Fields:**
  - `computer_name_prefix` (string)
  - `additional_unattend_content` (list/block, ForceNew)
  - `enable_automatic_updates` (bool, default: true)
  - `hotpatching_enabled` (bool, default: false)
  - `provision_vm_agent` (bool, default: true, ForceNew)
  - `patch_assessment_mode` (string, default: "ImageDefault")
  - `patch_mode` (string, default: "AutomaticByOS")
  - `secret` (list/block)
  - `timezone` (string)
  - `winrm_listener` (set/block, ForceNew)

### Additional Unattend Content Schema

```go
func additionalUnattendContentSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        ForceNew: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "content": {
                    Type:      pluginsdk.TypeString,
                    Required:  true,
                    ForceNew:  true,
                    Sensitive: true,
                },
                "setting": {
                    Type:     pluginsdk.TypeString,
                    Required: true,
                    ForceNew: true,
                    ValidateFunc: validation.StringInSlice([]string{
                        string(virtualmachines.SettingNamesAutoLogon),
                        string(virtualmachines.SettingNamesFirstLogonCommands),
                    }, false),
                },
            },
        },
    }
}
```

### Windows Secrets Schema

```go
func windowsSecretSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "key_vault_id": commonschema.ResourceIDReferenceRequired(&commonids.KeyVaultId{}),

                "certificate": {
                    Type:     pluginsdk.TypeSet,
                    Required: true,
                    MinItems: 1,
                    Elem: &pluginsdk.Resource{
                        Schema: map[string]*pluginsdk.Schema{
                            "store": {
                                Type:     pluginsdk.TypeString,
                                Required: true,
                            },
                            "url": {
                                Type:         pluginsdk.TypeString,
                                Required:     true,
                                ValidateFunc: keyVaultValidate.NestedItemId,
                            },
                        },
                    },
                },
            },
        },
    }
}
```

### WinRM Listener Schema

```go
func winRmListenerSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeSet,
        Optional: true,
        ForceNew: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "protocol": {
                    Type:     pluginsdk.TypeString,
                    Required: true,
                    ForceNew: true,
                    ValidateFunc: validation.StringInSlice([]string{
                        string(virtualmachines.ProtocolTypesHTTP),
                        string(virtualmachines.ProtocolTypesHTTPS),
                    }, false),
                },

                "certificate_url": {
                    Type:         pluginsdk.TypeString,
                    Optional:     true,
                    ForceNew:     true,
                    ValidateFunc: keyVaultValidate.NestedItemId,
                },
            },
        },
    }
}
```

## Azure API Schema

Query result for `body.properties.virtualMachineProfile.osProfile.windowsConfiguration`:

```
ObjectWithOptionalAttrs(map[string]Type{
    "additionalUnattendContent": List(ObjectWithOptionalAttrs(map[string]Type{
        "componentName": String,
        "content": String,
        "passName": String,
        "settingName": String
    }, []string{"componentName", "content", "passName", "settingName"})),
    "enableAutomaticUpdates": Bool,
    "patchSettings": ObjectWithOptionalAttrs(map[string]Type{
        "assessmentMode": String,
        "automaticByPlatformSettings": ObjectWithOptionalAttrs(map[string]Type{
            "bypassPlatformSafetyChecksOnUserSchedule": Bool,
            "rebootSetting": String
        }, []string{"bypassPlatformSafetyChecksOnUserSchedule", "rebootSetting"}),
        "enableHotpatching": Bool,
        "patchMode": String
    }, []string{"assessmentMode", "automaticByPlatformSettings", "enableHotpatching", "patchMode"}),
    "provisionVMAgent": Bool,
    "timeZone": String,
    "winRM": ObjectWithOptionalAttrs(map[string]Type{
        "listeners": List(ObjectWithOptionalAttrs(map[string]Type{
            "certificateUrl": String,
            "protocol": String
        }, []string{"certificateUrl", "protocol"}))
    }, []string{"listeners"})
}, []string{
    "additionalUnattendContent",
    "enableAutomaticUpdates",
    "patchSettings",
    "provisionVMAgent",
    "timeZone",
    "winRM"
})
```

All properties are optional at the Azure API level.

## Hidden Fields Detection

### From Expand Function Analysis

Found **ONE hidden field** in the Azure API that is NOT fully exposed in the Terraform provider:

#### 1. `patchSettings.automaticByPlatformSettings`

**Evidence:** Present in Azure API schema but NOT set in the expand function.

**Provider Code:** The expand function only sets:
```go
patchSettings.AssessmentMode = pointer.To(virtualmachinescalesets.WindowsPatchAssessmentMode(input["patch_assessment_mode"].(string)))
patchSettings.PatchMode = pointer.To(virtualmachinescalesets.WindowsVMGuestPatchMode(input["patch_mode"].(string)))
patchSettings.EnableHotpatching = pointer.To(input["hotpatching_enabled"].(bool))
winConfig.PatchSettings = &patchSettings
```

The `automaticByPlatformSettings` sub-object (containing `bypassPlatformSafetyChecksOnUserSchedule` and `rebootSetting`) is not exposed in the provider.

**Status:** Not exposed - will remain unmapped.

### Fields Set in Parent osProfile

From the expand function, several fields that appear to be part of `windows_configuration` are actually set at the parent `osProfile` level:

```go
osProfile.CustomData = pointer.To(customData)
osProfile.AdminUsername = pointer.To(input["admin_username"].(string))
osProfile.AdminPassword = pointer.To(input["admin_password"].(string))

if computerPrefix := input["computer_name_prefix"].(string); computerPrefix != "" {
    osProfile.ComputerNamePrefix = pointer.To(computerPrefix)
}

if secrets := input["secret"].([]interface{}); len(secrets) > 0 {
    osProfile.Secrets = expandWindowsSecretsVMSS(secrets)
}
```

**Important:** These fields are set at `osProfile` level, NOT inside `windowsConfiguration`:
- `adminUsername` → `osProfile.AdminUsername`
- `adminPassword` → `osProfile.AdminPassword`
- `computerNamePrefix` → `osProfile.ComputerNamePrefix`
- `secrets` → `osProfile.Secrets`

Only the following are set inside `windowsConfiguration`:
- `enableAutomaticUpdates`
- `provisionVMAgent`
- `timeZone`
- `patchSettings` (with `assessmentMode`, `patchMode`, `enableHotpatching`)
- `additionalUnattendContent`
- `winRM.listeners`

### Hidden Fields Assignment

No hidden fields need to be assigned by this skeleton task. The structure is set up correctly to handle all exposed provider fields in their respective child tasks.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|---|---|---|
| windows_configuration | windowsConfiguration | Block wrapper |
| admin_username | *osProfile.adminUsername* | Task #115 - **Set at osProfile level** |
| admin_password | *osProfile.adminPassword* | Task #114 - **Set at osProfile level** |
| computer_name_prefix | *osProfile.computerNamePrefix* | Task #116 - **Set at osProfile level** |
| enable_automatic_updates | enableAutomaticUpdates | Task #117 |
| hotpatching_enabled | patchSettings.enableHotpatching | Task #118 |
| patch_assessment_mode | patchSettings.assessmentMode | Task #119 |
| patch_mode | patchSettings.patchMode | Task #120 |
| provision_vm_agent | provisionVMAgent | Task #121 |
| timezone | timeZone | Task #122 |
| additional_unattend_content | additionalUnattendContent | Tasks #123-125 |
| secret | *osProfile.secrets* | Tasks #126-130 - **Set at osProfile level** |
| winrm_listener | winRM.listeners | Tasks #131-133 |

**Important Nesting Note:**
- Fields marked with asterisks are set at the **parent osProfile level**, NOT inside windowsConfiguration
- The expand function returns an osProfile object containing both parent-level fields and the nested windowsConfiguration
- Child tasks #114, #115, #116, #126-130 must place their values at `osProfile` level
- Child tasks #117-122, #123-125, #131-133 must place their values inside `windowsConfiguration`

## Special Handling

### Block Conditionality

The entire `windowsConfiguration` object is conditional based on whether `var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration` is not null.

### Mutual Exclusivity

From the parent os_profile (Task #96), `windows_configuration` and `linux_configuration` are mutually exclusive. Only one can be present at a time.

### Computer Name Prefix Defaulting

From the Create method, if `computer_name_prefix` is not set, it defaults to the scale set name (same pattern as Linux configuration). This defaulting logic will be handled in Task #116 (`computer_name_prefix`).

### Admin Username Windows Validation

The provider has a custom validation function `validateAdminUsernameWindows` which will need to be analyzed in Task #115.

### Admin Password Required

Unlike Linux configuration where password is optional (SSH keys can be used instead), Windows configuration **requires** an admin password. The schema marks it as `Required: true`.

### Admin Password Diff Suppression

The `admin_password` field has a `DiffSuppressFunc: adminPasswordDiffSuppressFunc` which suppresses diffs in certain conditions. This will be analyzed in Task #114.

### WinRM Listeners Set

WinRM listeners are defined as a `TypeSet`, ensuring uniqueness. Tasks #131-133 will need to handle this properly.

### Additional Unattend Content Sensitive

The `content` field in `additional_unattend_content` is marked as `Sensitive: true` and the entire block is `ForceNew: true`. Task #124 will need to handle this with an independent ephemeral variable.

### Secrets Structure

The `secret` block contains a `key_vault_id` and a set of `certificate` entries (each with a `store` and `url`). Note that Windows secrets include a `store` field, unlike Linux secrets which only have `url`. The expand function converts these to the Azure API format. Tasks #126-130 will handle the expansion.

### Patch Settings Defaults

The patch settings have specific defaults that differ from Linux:
- `patch_assessment_mode`: "ImageDefault"
- `patch_mode`: "AutomaticByOS"
- `hotpatching_enabled`: false

### Timezone Validation

The `timezone` field has a custom validation function `validate.VirtualMachineTimeZone()` which validates against known Windows timezone values. Task #122 will need to replicate this validation.

## Validation

### Category 1 - Value Constraints

No direct value constraints for the block itself. Child fields have their own validations handled in respective tasks.

### Category 2 - Cross-Field Constraints

Not applicable at the block level. The mutual exclusivity with `linux_configuration` is handled at the parent `os_profile` level.

### Category 3 - Custom Logic

The expand function contains special logic for:
1. Default computer name prefix (handled in Task #116)
2. WinRM listeners expansion (handled in Tasks #131-133)
3. Additional unattend content expansion (handled in Tasks #123-125)

## Critical Review & Edge Cases

### Null Semantics

- **`null` windows_configuration:** When `var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration` is `null`, the entire `windowsConfiguration` object is omitted from the API payload.
- **Empty windows_configuration:** The schema requires both `admin_username` and `admin_password` as required, so an empty block is not valid in Terraform.

### Boundary Conditions

1. **Required fields:** Both `admin_username` and `admin_password` must be provided when windows_configuration is set
2. **Optional WinRM listeners:** Can be empty (no WinRM), which is valid
3. **Optional secrets:** Can be empty or contain multiple entries
4. **Optional additional unattend content:** Can be empty or contain multiple entries

### Idempotency

The skeleton structure uses conditional merge patterns which are idempotent. The `!= null` check ensures the block is only added when explicitly configured.

### Safe References

All child field references will use safe navigation in their respective tasks. The skeleton assumes the parent `os_profile` object exists when `windows_configuration` is accessed.

### Edge Case: Parent-Level vs Nested Fields

**CRITICAL:** The expand function sets some fields at the **parent osProfile level** rather than inside windowsConfiguration:
- `adminUsername`, `adminPassword`, `computerNamePrefix`, `secrets` → Set at `osProfile` level
- Only `enableAutomaticUpdates`, `provisionVMAgent`, `timeZone`, `patchSettings`, `additionalUnattendContent`, `winRM` → Set inside `windowsConfiguration`

This means child tasks must be aware of where to place their values:
- Tasks #114, #115, #116, #126-130: Place values at parent osProfile level (outside windowsConfiguration)
- Tasks #117-122, #123-125, #131-133: Place values inside windowsConfiguration

The skeleton structure created here is ONLY for the `windowsConfiguration` object itself. Child tasks that need to place values at the parent osProfile level must merge them at that level, not inside this windowsConfiguration block.

### Edge Case: OS Type Detection

From the Create method, the presence of `windows_configuration` sets the OS type:

```go
if len(winConfigRaw) > 0 && winConfigRaw[0] != nil {
    osType = virtualmachinescalesets.OperatingSystemTypesWindows
    // ...
}
```

This is automatically handled by the provider and doesn't require explicit mapping in the AzAPI resource.

### Edge Case: Additional Unattend Content Components

The Azure API has additional fields in `additionalUnattendContent` that are NOT exposed in Terraform:
- `componentName` - Hardcoded to "Microsoft-Windows-Shell-Setup" in the expand function
- `passName` - Hardcoded to "OobeSystem" in the expand function

These will be handled in the expand logic for Task #123.

### Edge Case: License Type Coordination

The root-level `license_type` field (Task #11) should be coordinated with Windows configuration. When Windows is configured, the license type typically applies (values like "Windows_Client" or "Windows_Server").

## Child Tasks Ready for Delegation

The following child tasks are now **READY** for implementation as the parent skeleton structure is in place:

### Direct Children (Level 1) - Set at osProfile Level

**IMPORTANT:** These tasks place values at the **parent osProfile level**, NOT inside windowsConfiguration:

| Task # | Field | Type | Dependent On | Placement |
|--------|-------|------|--------------|-----------|
| 114 | os_profile.windows_configuration.admin_password | Argument | Skeleton #113 ✅ | osProfile.adminPassword |
| 115 | os_profile.windows_configuration.admin_username | Argument | Skeleton #113 ✅ | osProfile.adminUsername |
| 116 | os_profile.windows_configuration.computer_name_prefix | Argument | Skeleton #113 ✅ | osProfile.computerNamePrefix |
| 126 | os_profile.windows_configuration.secret | Block Skeleton | Skeleton #113 ✅ | osProfile.secrets |

### Direct Children (Level 1) - Set Inside windowsConfiguration

| Task # | Field | Type | Dependent On | Placement |
|--------|-------|------|--------------|-----------|
| 117 | os_profile.windows_configuration.enable_automatic_updates | Argument | Skeleton #113 ✅ | windowsConfiguration |
| 118 | os_profile.windows_configuration.hotpatching_enabled | Argument | Skeleton #113 ✅ | windowsConfiguration.patchSettings |
| 119 | os_profile.windows_configuration.patch_assessment_mode | Argument | Skeleton #113 ✅ | windowsConfiguration.patchSettings |
| 120 | os_profile.windows_configuration.patch_mode | Argument | Skeleton #113 ✅ | windowsConfiguration.patchSettings |
| 121 | os_profile.windows_configuration.provision_vm_agent | Argument | Skeleton #113 ✅ | windowsConfiguration |
| 122 | os_profile.windows_configuration.timezone | Argument | Skeleton #113 ✅ | windowsConfiguration |
| 123 | os_profile.windows_configuration.additional_unattend_content | Block Skeleton | Skeleton #113 ✅ | windowsConfiguration |
| 131 | os_profile.windows_configuration.winrm_listener | Block Skeleton | Skeleton #113 ✅ | windowsConfiguration.winRM |

### Note on Task Ordering

1. **Independent Tasks (Parallel):** Tasks #114-122 can proceed in parallel as they are independent arguments
2. **Block Skeleton Tasks:** Task #123 (additional_unattend_content), #126 (secret), and #131 (winrm_listener) are block skeletons that enable their respective children
3. **Placement Awareness:** Implementers MUST check the "Placement" column to know where to merge their values

### Nested Children (Level 2)

These tasks depend on their parent block skeletons:

| Task # | Field | Type | Dependent On |
|--------|-------|------|--------------|
| 124 | os_profile.windows_configuration.additional_unattend_content.content | Argument | Skeleton #123 |
| 125 | os_profile.windows_configuration.additional_unattend_content.setting | Argument | Skeleton #123 |
| 127 | os_profile.windows_configuration.secret.key_vault_id | Argument | Skeleton #126 |
| 128 | os_profile.windows_configuration.secret.certificate | Block Skeleton | Skeleton #126 |
| 132 | os_profile.windows_configuration.winrm_listener.protocol | Argument | Skeleton #131 |
| 133 | os_profile.windows_configuration.winrm_listener.certificate_url | Argument | Skeleton #131 |

### Nested Children (Level 3)

These tasks depend on Level 2 block skeletons:

| Task # | Field | Type | Dependent On |
|--------|-------|------|--------------|
| 129 | os_profile.windows_configuration.secret.certificate.store | Argument | Skeleton #128 |
| 130 | os_profile.windows_configuration.secret.certificate.url | Argument | Skeleton #128 |

## Completion Checklist

- ✅ Property in correct local (`local.body`)
- ✅ Block structure skeleton created with comment placeholders
- ✅ Conditional logic based on variable null check
- ✅ ForceNew: Not applicable to block structure
- ✅ Validations: No validations at block level (handled by children)
- ✅ Hidden fields identified and documented
- ✅ Critical review completed
- ✅ Edge case analysis included (parent vs nested placement)
- ✅ Proof document created
- ✅ `track.md` will be updated
- ✅ Self-Review: Only skeleton structure created, no child implementations

## Notes

1. **Skeleton Only:** This task creates ONLY the block structure framework. Child fields (#114-133) will be implemented in their respective tasks.

2. **Critical Placement Distinction:** Some fields from the `windows_configuration` schema are actually placed at the parent `osProfile` level in the Azure API:
   - Parent level: adminUsername, adminPassword, computerNamePrefix, secrets
   - Nested level: enableAutomaticUpdates, provisionVMAgent, timeZone, patchSettings, additionalUnattendContent, winRM

3. **Patch Settings Structure:** Tasks #118, #119, and #120 will all contribute to the `patchSettings` object. They must use a shared merge pattern.

4. **WinRM Listeners:** The winrm_listener field is a TypeSet in Terraform but maps to an array in the Azure API. Task #131 will need to handle the conversion properly.

5. **Computer Name Defaulting:** Task #116 must implement the defaulting logic to use the scale set name if not provided.

6. **Additional Unattend Content Hardcoded Fields:** Task #123 must include hardcoded values for `componentName` and `passName` that are not exposed in Terraform schema.

7. **Admin Password Required:** Unlike Linux, Windows requires both username AND password. SSH keys are not an option for Windows authentication.

8. **Extension Operations Coordination:** From Task #96, the `extension_operations_enabled` validation checks against `provision_vm_agent`. Task #121 should document this relationship.

9. **License Type Relationship:** The root-level `license_type` field is typically used with Windows VMs and should be coordinated when implementing Windows configuration.

10. **No Direct API Mapping:** Unlike most nested blocks, this block's fields are split between parent and nested levels. Child task implementers must carefully review the expand function to determine correct placement.
