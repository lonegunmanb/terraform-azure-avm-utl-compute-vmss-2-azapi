# Task #148: rolling_upgrade_policy.prioritize_unhealthy_instances_enabled

## Summary

Implemented the optional boolean field `prioritize_unhealthy_instances_enabled` within the `rolling_upgrade_policy` block. This field controls whether unhealthy instances in a scale set should be upgraded before healthy instances during rolling upgrades. The field is conditionally included in the Azure API payload when not null.

## Shadow Implementation

```hcl
var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy != null ? {
  upgradePolicy = {
    rollingUpgradePolicy = merge(
      {
        maxBatchInstancePercent = var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.max_batch_instance_percent
        maxUnhealthyInstancePercent = var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.max_unhealthy_instance_percent
        maxUnhealthyUpgradedInstancePercent = var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.max_unhealthy_upgraded_instance_percent
        pauseTimeBetweenBatches = var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.pause_time_between_batches
      },
      (var.orchestrated_virtual_machine_scale_set_zones != null && length(var.orchestrated_virtual_machine_scale_set_zones) > 0) ? {
        enableCrossZoneUpgrade = coalesce(var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.cross_zone_upgrades_enabled, false)
      } : {},
      {
        maxSurge = var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.maximum_surge_instances_enabled
      },
      var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.prioritize_unhealthy_instances_enabled != null ? { # <-
        prioritizeUnhealthyInstances = var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.prioritize_unhealthy_instances_enabled # <-
      } : {} # <-
    )
  }
} : {},
```

## Create Phase Verification

**Query Method:** `query_terraform_block_implementation_source_code` with `entrypoint_name=create`

**Pattern Identified:** Single-phase create pattern with `CreateOrUpdateThenPoll`

**Field Classification:** Create phase (set before API call)

**Go Code Evidence:**

```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    // ... initialization code ...
    
    rollingUpgradePolicy, err := ExpandVirtualMachineScaleSetRollingUpgradePolicy(d.Get("rolling_upgrade_policy").([]interface{}), len(zones) > 0, false)
    if err != nil {
        return fmt.Errorf("expanding `rolling_upgrade_policy`: %w", err)
    }

    props.Properties.UpgradePolicy = &virtualmachinescalesets.UpgradePolicy{
        Mode:                 pointer.To(upgradeMode),
        RollingUpgradePolicy: rollingUpgradePolicy,
    }
    
    // ... more config ...
    
    if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
        return fmt.Errorf("creating Orchestrated %s: %w", id, err)
    }
}
```

**Decision:** Field belongs in `local.body` (Create phase) - set before the single `CreateOrUpdateThenPoll` call.

## Assignment Path Verification

**Predicted Path:**
```
Input: rolling_upgrade_policy.prioritize_unhealthy_instances_enabled
Provider: props.Properties.UpgradePolicy.RollingUpgradePolicy.PrioritizeUnhealthyInstances
Azure API: body.properties.upgradePolicy.rollingUpgradePolicy.prioritizeUnhealthyInstances
```

**Go Code Evidence (Expand Function):**

```go
func ExpandVirtualMachineScaleSetRollingUpgradePolicy(input []interface{}, isZonal, overProvision bool) (*virtualmachinescalesets.RollingUpgradePolicy, error) {
    if len(input) == 0 {
        return nil, nil
    }

    raw := input[0].(map[string]interface{})

    rollingUpgradePolicy := &virtualmachinescalesets.RollingUpgradePolicy{
        MaxBatchInstancePercent:             pointer.To(int64(raw["max_batch_instance_percent"].(int))),
        MaxUnhealthyInstancePercent:         pointer.To(int64(raw["max_unhealthy_instance_percent"].(int))),
        MaxUnhealthyUpgradedInstancePercent: pointer.To(int64(raw["max_unhealthy_upgraded_instance_percent"].(int))),
        PauseTimeBetweenBatches:             pointer.To(raw["pause_time_between_batches"].(string)),
        PrioritizeUnhealthyInstances:        pointer.To(raw["prioritize_unhealthy_instances_enabled"].(bool)),
        MaxSurge:                            pointer.To(raw["maximum_surge_instances_enabled"].(bool)),
    }
    // ... validation logic ...
    return rollingUpgradePolicy, nil
}
```

**Assignment Chain:**
1. `d.Get("rolling_upgrade_policy")` → passed to `ExpandVirtualMachineScaleSetRollingUpgradePolicy`
2. Expand function creates `RollingUpgradePolicy` struct with `PrioritizeUnhealthyInstances` field
3. Assigned to `props.Properties.UpgradePolicy.RollingUpgradePolicy`
4. `props` sent to API via `CreateOrUpdateThenPoll`

**Verified Path:** `body.properties.upgradePolicy.rollingUpgradePolicy.prioritizeUnhealthyInstances`

**Path Comparison:** ✅ MATCH - Predicted path matches actual implementation path exactly.

## Provider Schema

**Source:** `query_terraform_block_implementation_source_code` with `entrypoint_name=schema`

```go
func VirtualMachineScaleSetRollingUpgradePolicySchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        ForceNew: true,
        MaxItems: 1,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                // ... other fields ...
                "prioritize_unhealthy_instances_enabled": {
                    Type:     pluginsdk.TypeBool,
                    Optional: true,
                },
                // ... other fields ...
            },
        },
    }
}
```

**Key Attributes:**
- **Type:** `TypeBool`
- **Required:** `false` (Optional)
- **ForceNew:** `false` (inherited from parent block which is `ForceNew: true`)
- **Default:** None (no default value specified)
- **Computed:** `false`
- **Validation:** None

**Note:** The parent `rolling_upgrade_policy` block has `ForceNew: true`, meaning any change to this field triggers resource replacement.

## Azure API Schema

**Query Method:** `query_azapi_resource_schema` with path `body.properties.upgradePolicy.rollingUpgradePolicy.prioritizeUnhealthyInstances`

**API Version:** 2024-11-01

**Resource Type:** Microsoft.Compute/virtualMachineScaleSets

**Schema Result:** `Bool`

**Documentation:** "Upgrade all unhealthy instances in a scale set before any healthy instances."

**Property Path:** `body.properties.upgradePolicy.rollingUpgradePolicy.prioritizeUnhealthyInstances`

## Hidden Fields

**None identified.** The field is explicitly defined in the Terraform schema and directly corresponds to the Azure API property with no hidden or computed fields.

## Mapping

**Terraform (snake_case) → Azure API (camelCase):**

```
prioritize_unhealthy_instances_enabled → prioritizeUnhealthyInstances
```

**Type Mapping:**
- Terraform: `bool`
- Azure API: `Bool`

**Direct Mapping:** The boolean value is passed through directly without transformation.

## Special Handling

### ForceNew Behavior

**Inherited ForceNew:** The parent `rolling_upgrade_policy` block has `ForceNew: true`, meaning:
- Any change to `prioritize_unhealthy_instances_enabled` will trigger resource replacement
- No need to add explicit ForceNew tracking in `replace_triggers_external_values` since the entire block already has ForceNew

**Evidence from Schema:**

```go
"rolling_upgrade_policy": VirtualMachineScaleSetRollingUpgradePolicySchema(),

func VirtualMachineScaleSetRollingUpgradePolicySchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        ForceNew: true,  // <-- Parent block is ForceNew
        MaxItems: 1,
        // ...
    }
}
```

### Validation

**Provider Validations:** None (no validation function defined in schema)

**Cross-Field Validations:** None specific to this field

**Variable Definition:** Already correctly defined in `variables.tf`:

```hcl
variable "orchestrated_virtual_machine_scale_set_rolling_upgrade_policy" {
  type = object({
    cross_zone_upgrades_enabled             = optional(bool)
    max_batch_instance_percent              = number
    max_unhealthy_instance_percent          = number
    max_unhealthy_upgraded_instance_percent = number
    maximum_surge_instances_enabled         = optional(bool, false)
    pause_time_between_batches              = string
    prioritize_unhealthy_instances_enabled  = optional(bool)  # <-- Already defined
  })
  default     = null
  description = <<-EOT
   - `prioritize_unhealthy_instances_enabled` - (Optional) Upgrade all unhealthy instances in a scale set before any healthy instances. Possible values are `true` or `false`.
  EOT
}
```

**Implementation Note:** No additional validations needed - the field accepts any boolean value or null.

### Conditional Assignment

**Strategy:** Conditional merge - only include `prioritizeUnhealthyInstances` in the API payload when the field is not null.

**Rationale:**
1. The provider uses `pointer.To(raw["prioritize_unhealthy_instances_enabled"].(bool))` which always creates a pointer, even for `false`
2. However, the field is Optional with no default, so users may not specify it at all
3. We conditionally add the field only when explicitly set to preserve user intent

**Implementation:**

```hcl
var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.prioritize_unhealthy_instances_enabled != null ? {
  prioritizeUnhealthyInstances = var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.prioritize_unhealthy_instances_enabled
} : {}
```

This ensures:
- When set to `true`: API receives `{"prioritizeUnhealthyInstances": true}`
- When set to `false`: API receives `{"prioritizeUnhealthyInstances": false}`
- When null/unset: Field is omitted from API payload entirely

### Sensitive Data

**Not Sensitive:** This is a configuration boolean, not sensitive data.

### Post-Creation Updates

**Not Applicable:** Changes to this field trigger replacement due to parent block's ForceNew behavior.

## Deferred Work Completion

**Check:** Reviewed `following.md` for any work deferred to Task #148.

**Result:** No deferred work found for this task.

## Critical Review & Edge Case Analysis

### Null Semantics

**Question:** What does `null` mean for this field?

**Answer:** When `null` (not specified by user), the field is omitted from the API payload, allowing Azure to apply its default behavior (likely false - do not prioritize unhealthy instances).

**Evidence:** The provider's expand function always wraps values in `pointer.To()`, but our implementation only includes the field when non-null, which is correct since the schema has no default value.

### Boolean Values

**True:** Unhealthy instances are upgraded first
**False:** Normal upgrade order (no prioritization)
**Null:** Omitted from API payload, Azure uses default behavior

### Edge Cases

1. **Null value:** ✅ Handled - field is conditionally added only when not null
2. **False value:** ✅ Handled - explicitly sent as `false` to API when user sets it
3. **True value:** ✅ Handled - explicitly sent as `true` to API when user sets it

### Idempotency

**Analysis:**
- ✅ Read operations will return the actual API value
- ✅ When null, field is omitted from request
- ✅ When true/false, field is explicitly set
- ✅ No order-dependent operations
- ✅ No transformations that could cause drift

### Safe References

**Variable Reference:**
```hcl
var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.prioritize_unhealthy_instances_enabled
```

**Safety:**
- ✅ Parent null check: `var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy != null ? {...} : {}`
- ✅ Field null check: `prioritize_unhealthy_instances_enabled != null ? {...} : {}`
- ✅ No nested property access that could fail

### Merge Strategy Stability

**Key Stability:** The merge includes this field conditionally, which is correct:
- Key appears in merge output only when field is not null
- This matches provider behavior where Optional bool with no default can be omitted
- No risk of unstable keys causing unnecessary replacements

## Checklist

- ✅ Property in correct local (`local.body`)
- ✅ ForceNew handled (inherited from parent block)
- ✅ All logic exactly replicated from provider (conditional assignment when not null)
- ✅ Validations verified (none required for this field)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work checked (none found in `following.md`)
- ✅ Critical review completed (null semantics, edge cases, idempotency, safe references)
- ✅ Edge Case Analysis included
- ✅ Proof created
- ✅ `track.md` will be updated to "Pending for check"
- ✅ Self-Review: Implementation adds ONLY what Task #148 requires (the prioritize_unhealthy_instances_enabled field)

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #148 - rolling_upgrade_policy.prioritize_unhealthy_instances_enabled

### Validation Results

✅ **ForceNew Logic:** Inherited ForceNew from parent block (`rolling_upgrade_policy` has `ForceNew: true`). No explicit tracking needed in `replace_triggers_external_values`. Correctly documented in proof.

✅ **Stable Keys:** Key `prioritizeUnhealthyInstances` conditionally added within stable parent `rollingUpgradePolicy`. No merge conflicts. Correct pattern for optional field with no default value.

✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase). Evidence from Go code shows single-phase `CreateOrUpdateThenPoll` pattern with field set before API call.

✅ **Type Conversion:** Correct direct mapping from Terraform `bool` to Azure API `Bool`. No transformation needed.

✅ **Null Handling:** Correctly implements conditional merge - field included in API payload only when not null. When null (unset), omitted from payload. When true/false, explicitly sent to API. Exactly matches provider behavior.

✅ **Validations:** None required. Provider schema shows no ValidateFunc, ConflictsWith, or RequiredWith for this field. Boolean field accepts any true/false/null value.

✅ **Assignment Path:** Correctly traced through provider code. Verified path: `rolling_upgrade_policy.prioritize_unhealthy_instances_enabled` → `PrioritizeUnhealthyInstances` → `body.properties.upgradePolicy.rollingUpgradePolicy.prioritizeUnhealthyInstances`

✅ **Deferred Work Completion:** Checked `following.md` - no work deferred to Task #148.

✅ **Deferred Work Recording:** No deferrals made by this task.

✅ **Edge Cases:** Comprehensive edge case analysis completed in proof. Safe references with parent null checks, correct null semantics (omit vs explicit false), idempotency verified.

✅ **Provider Behavior Replication:** Implementation uses conditional merge `field != null ? { key = field } : {}` which exactly replicates provider's `pointer.To(raw["field"].(bool))` - present values (including false) create pointer, absent values omit from payload.

✅ **Scope Compliance:** Implementation adds ONLY the `prioritize_unhealthy_instances_enabled` field. No scope creep detected.

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found. The field is:

- Conditionally included in API payload only when not null (matches provider's pointer.To() behavior)
- Correctly placed in Create phase within `local.body`
- Uses appropriate conditional merge pattern for optional field with no default
- Inherits ForceNew from parent block (correctly documented)
- Has no validations (as per provider schema - none defined)
- Handles all edge cases correctly (null, true, false)

**Status:** APPROVED ✅

---
