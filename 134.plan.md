# Task #134 - plan Block - STRUCTURE SKELETON

## Summary

Created the structure skeleton for the root-level `plan` block with conditional logic and comment placeholders for the three child arguments (name, product, publisher). This establishes the framework for Tasks #135-137 to implement the individual fields.

## Create Phase Verification

### Query Create Method

```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	isLegacy := true
	// ...
	
	// Only inclued the virtual machine profile if this is not a legacy configuration
	if !isLegacy {
		if v, ok := d.GetOk("plan"); ok {
			props.Plan = expandPlanVMSS(v.([]interface{}))
		}
		// ...
	}
	// ...
	
	log.Printf("[DEBUG] Creating Orchestrated %s.", id)
	if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
		return fmt.Errorf("creating Orchestrated %s: %w", id, err)
	}
}
```

### Pattern Analysis

**Pattern:** Single-phase Create

The `plan` field is:
1. Expanded from Terraform config using `expandPlanVMSS()`
2. Assigned to `props.Plan` before the create API call
3. Sent in the initial `CreateOrUpdateThenPoll()` call

**Classification:** Create Phase - field is set before the create call and included in the initial API request.

**Decision:** Implement in `local.body` (NOT in `local.post_creation_updates`).

## Assignment Path Verification

### Predicted Path

`body.plan`

### Go Code Evidence - expandPlanVMSS Function

```go
func expandPlanVMSS(input []interface{}) *virtualmachinescalesets.Plan {
	if len(input) == 0 || input[0] == nil {
		return nil
	}

	raw := input[0].(map[string]interface{})

	return &virtualmachinescalesets.Plan{
		Name:      pointer.To(raw["name"].(string)),
		Product:   pointer.To(raw["product"].(string)),
		Publisher: pointer.To(raw["publisher"].(string)),
	}
}
```

### Go Code Evidence - Assignment in Create Method

```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	props := virtualmachinescalesets.VirtualMachineScaleSet{
		Location: location.Normalize(d.Get("location").(string)),
		Tags:     tags.Expand(t),
		Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
			// ...
		},
	}
	
	// ...
	
	if v, ok := d.GetOk("plan"); ok {
		props.Plan = expandPlanVMSS(v.([]interface{}))  // Direct assignment to props.Plan
	}
	// ...
}
```

### Verified Path

The `expandPlanVMSS` function creates a `virtualmachinescalesets.Plan` object with three fields: `Name`, `Product`, and `Publisher`. This is assigned directly to `props.Plan`.

In the Azure API, the `plan` is a root-level field in the Virtual Machine Scale Set resource, NOT nested under `properties`.

**Verified Path:** `body.plan` (root level in body, NOT under properties)

### Path Comparison

- **Predicted:** `body.plan` ✅
- **Verified:** `body.plan` ✅
- **Match:** YES - The plan block is at the root level of the body

## Provider Schema

```go
func planSchema() *pluginsdk.Schema {
	return &pluginsdk.Schema{
		Type:     pluginsdk.TypeList,
		Optional: true,
		ForceNew: true,
		MaxItems: 1,
		Elem: &pluginsdk.Resource{
			Schema: map[string]*pluginsdk.Schema{
				"name": {
					Type:     pluginsdk.TypeString,
					Required: true,
					ForceNew: true,
				},

				"product": {
					Type:     pluginsdk.TypeString,
					Required: true,
					ForceNew: true,
				},

				"publisher": {
					Type:     pluginsdk.TypeString,
					Required: true,
					ForceNew: true,
				},
			},
		},
	}
}
```

**Key Properties:**
- Type: List with MaxItems: 1 (single block)
- Optional: true
- ForceNew: true (all fields are ForceNew)
- Contains 3 Required fields: name, product, publisher

## Azure API Schema

From `body.plan`:
```json
{
  "name": "The plan ID.",
  "product": "Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.",
  "promotionCode": "The promotion code.",
  "publisher": "The publisher ID."
}
```

**Azure API Fields:**
- `name` (string) - The plan ID
- `product` (string) - Product of the image from marketplace
- `publisher` (string) - The publisher ID
- `promotionCode` (string) - The promotion code (NOT in Terraform schema)

## Hidden Fields

### Check Expand Function for Hidden Fields

The `expandPlanVMSS` function only handles the three fields exposed in Terraform:
- `name` → `Name`
- `product` → `Product`
- `publisher` → `Publisher`

**Hidden Field Found:**
- `promotionCode` - Exists in Azure API schema but NOT in Terraform provider schema

**Decision:** The `promotionCode` field is not exposed in the Terraform provider and will NOT be included in the skeleton. Users cannot configure this field through Terraform.

## Mapping (snake_case → camelCase)

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|------------------------|----------------------|-------|
| plan | plan | Block name (same) |
| name | name | Field inside plan |
| product | product | Field inside plan |
| publisher | publisher | Field inside plan |
| N/A | promotionCode | Hidden - not in Terraform schema |

## Special Handling

### ForceNew

All three fields in the `plan` block are marked as `ForceNew: true` in the provider schema. This means:
1. Any change to `name`, `product`, or `publisher` will trigger resource replacement
2. Each field should be tracked in `replace_triggers_external_values`

**Implementation:** The child tasks (#135, #136, #137) will add their respective fields to `replace_triggers_external_values` with stable keys.

### Conditional Logic

The plan block is optional (`Optional: true`). The skeleton implements conditional logic:
```hcl
var.orchestrated_virtual_machine_scale_set_plan != null ? {
  plan = { ... }
} : {}
```

This ensures the plan object is only included in the body when the user configures it.

## Shadow Implementation

```hcl
locals {
  body = merge(
    {
      properties = merge(
        # ... existing properties ...
      )
    },
    # ... existing sku and zones blocks ...
    var.orchestrated_virtual_machine_scale_set_plan != null ? {
      plan = {
        # name = ... # Task #135
        # product = ... # Task #136
        # publisher = ... # Task #137
      }
    } : {}
  )
}
```

**Key Implementation Details:**
1. **Conditional block:** Only included when `var.orchestrated_virtual_machine_scale_set_plan != null`
2. **Location:** At the root level of `body` (NOT under properties)
3. **Comment placeholders:** Each child field has a comment placeholder with its task number
4. **Empty structure:** No fields are implemented yet - waiting for child tasks

## Child Tasks Ready for Delegation

The following child tasks are now ready to be delegated to implement the individual arguments:

1. **Task #135** - `plan.name` (Required argument)
2. **Task #136** - `plan.product` (Required argument)
3. **Task #137** - `plan.publisher` (Required argument)

All three tasks are Type 4 (Block Argument) tasks and should:
- Implement their respective field in the plan block
- Add ForceNew tracking to `replace_triggers_external_values`
- Replace the comment placeholder in the skeleton
- Create their own proof documents

## Critical Review & Edge Case Analysis

### Null Semantics
- **Block is null:** Plan object is not included in the API body (conditional logic handles this)
- **Block exists but field is null:** Not applicable - all three fields are Required in the schema

### Boundary Conditions
- **Empty block:** Not possible - schema requires all three fields when block is present
- **MaxItems: 1:** Enforced by schema - only one plan block allowed

### Idempotency
- All fields are simple strings - no ordering concerns
- ForceNew on all fields ensures consistent replacement behavior

### Safe References
- Conditional check `var.orchestrated_virtual_machine_scale_set_plan != null` prevents null reference errors
- Child tasks will safely access fields within the guaranteed non-null block

### Structural Considerations
- Plan block is at root level of body, parallel to properties, sku, and zones
- This matches Azure API structure where plan is a top-level resource field
- No nested merging required - direct assignment in conditional block

## Checklist

- ✅ Skeleton structure created with conditional logic
- ✅ Comment placeholders added for all three child fields (Tasks #135-137)
- ✅ Placed at correct location in body (root level, NOT under properties)
- ✅ Hidden field `promotionCode` identified but correctly excluded (not in Terraform schema)
- ✅ Conditional logic prevents null block from being included in body
- ✅ ForceNew behavior noted for child tasks to implement
- ✅ Child tasks listed and ready for delegation
- ✅ Create phase verified (single-phase, Create phase assignment)
- ✅ Assignment path verified (body.plan)
- ✅ Edge case analysis completed
- ✅ No content from other tasks added
- ✅ Proof document created
- ✅ Track.md will be updated to "Pending for check"

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #134 - plan

### Validation Results

✅ **ForceNew Logic:** Documented for child tasks - all three fields (name, product, publisher) are ForceNew and will be tracked by Tasks #135-137
✅ **Stable Keys:** Plan block conditionally added at merge level (acceptable for optional block structure), child fields are all Required (stable once block exists)
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase) based on single-phase Create pattern
✅ **Type Conversion:** N/A - skeleton only, child tasks will handle field conversions
✅ **Null Handling:** Conditional logic correctly prevents null block from being included in API body
✅ **Validations:** None required at skeleton level - child tasks will implement field validations
✅ **Deferred Work Completion:** No deferred work for this task in following.md
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed - null semantics, boundary conditions, structural placement
✅ **Scope Discipline:** Only skeleton structure created - no premature implementation of child fields
✅ **Hidden Fields:** Correctly identified `promotionCode` in Azure API but excluded (not in Terraform provider schema)
✅ **Assignment Path:** Correctly verified as `body.plan` (root level, NOT under properties)
✅ **Child Task Readiness:** Tasks #135-137 properly documented and ready for delegation

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The Type 3 skeleton implementation:
- Creates proper conditional structure for optional block
- Places plan at correct root body level (parallel to sku, zones, NOT under properties)
- Uses comment placeholders for all three Required child fields
- Documents child tasks ready for delegation
- Does not prematurely implement any child field logic
- Correctly excludes hidden field (`promotionCode`) not exposed by provider

The proof document is comprehensive with all required sections, proper Go code evidence for Create phase verification, complete assignment path trace, and thorough edge case analysis.

**Status:** APPROVED ✅

---
