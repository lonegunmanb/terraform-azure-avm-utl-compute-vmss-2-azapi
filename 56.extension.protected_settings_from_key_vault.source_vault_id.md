# Task #56: extension.protected_settings_from_key_vault.source_vault_id

## Summary

Implemented `extension.protected_settings_from_key_vault.source_vault_id` argument, which specifies the Azure Key Vault resource ID containing the extension's protected settings secret. This is a Required string field that must be a valid Key Vault resource ID. The field is directly mapped to the Azure API's `sourceVault.id` property within the `protectedSettingsFromKeyVault` block.

## Shadow Implementation

```hcl
locals {
  body = merge(
    {
      properties = merge(
        var.orchestrated_virtual_machine_scale_set_sku_name != null ? {
          virtualMachineProfile = merge(
            var.orchestrated_virtual_machine_scale_set_extension != null || var.orchestrated_virtual_machine_scale_set_extensions_time_budget != null ? {
              extensionProfile = merge(
                var.orchestrated_virtual_machine_scale_set_extension != null ? {
                  extensions = [
                    for ext in var.orchestrated_virtual_machine_scale_set_extension : {
                      name = ext.name
                      properties = merge(
                        ext.protected_settings_from_key_vault != null ? {
                          protectedSettingsFromKeyVault = {
                            secretUrl = ext.protected_settings_from_key_vault.secret_url
                            sourceVault = { # <-
                              id = ext.protected_settings_from_key_vault.source_vault_id # <-
                            } # <-
                          }
                        } : {}
                      )
                    }
                  ]
                } : {}
              )
            } : {}
          )
        } : {}
      )
    }
  )
}
```

## Create Phase Verification

**Pattern:** Single-phase Create (CreateOrUpdate)

From `resourceOrchestratedVirtualMachineScaleSetCreate`:

```go
if v, ok := d.GetOk("extension"); ok {
    var err error
    virtualMachineProfile.ExtensionProfile, hasHealthExtension, err = expandOrchestratedVirtualMachineScaleSetExtensions(v.(*pluginsdk.Set).List())
    if err != nil {
        return err
    }
}

// ...later in the function...

props := virtualmachinescalesets.VirtualMachineScaleSet{
    Location: location.Normalize(d.Get("location").(string)),
    Tags:     tags.Expand(t),
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        // ...
        VirtualMachineProfile: &virtualMachineProfile,
    },
}

if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Decision:** This is a **Create phase** field - the extension's `protectedSettingsFromKeyVault.sourceVault.id` is set during the expand function before the CreateOrUpdate call. It goes into `local.body`.

## Assignment Path Verification

**Predicted Path:** `properties.virtualMachineProfile.extensionProfile.extensions[].properties.protectedSettingsFromKeyVault.sourceVault.id`

**Go Code Evidence:**

From `expandProtectedSettingsFromKeyVaultVMSS`:

```go
func expandProtectedSettingsFromKeyVaultVMSS(input []interface{}) *virtualmachinescalesets.KeyVaultSecretReference {
    if len(input) == 0 {
        return nil
    }

    v := input[0].(map[string]interface{})

    return &virtualmachinescalesets.KeyVaultSecretReference{
        SecretURL: v["secret_url"].(string),
        SourceVault: virtualmachinescalesets.SubResource{    // <-- Creates SubResource
            Id: pointer.To(v["source_vault_id"].(string)),  // <-- Maps to Id
        },
    }
}
```

From `expandOrchestratedVirtualMachineScaleSetExtensions`:

```go
protectedSettingsFromKeyVault := expandProtectedSettingsFromKeyVaultVMSS(extensionRaw["protected_settings_from_key_vault"].([]interface{}))
extensionProps.ProtectedSettingsFromKeyVault = (protectedSettingsFromKeyVault)

extension.Properties = &extensionProps  // <-- Assigns to Properties
extensions = append(extensions, extension)
```

From Create method:

```go
virtualMachineProfile.ExtensionProfile, hasHealthExtension, err = expandOrchestratedVirtualMachineScaleSetExtensions(v.(*pluginsdk.Set).List())

// ...

props := virtualmachinescalesets.VirtualMachineScaleSet{
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        VirtualMachineProfile: &virtualMachineProfile,  // <-- VirtualMachineProfile
    },
}
```

**Traced Path:**
1. `expandProtectedSettingsFromKeyVaultVMSS` creates `KeyVaultSecretReference` with `SourceVault.Id` field
2. `extensionProps.ProtectedSettingsFromKeyVault = protectedSettingsFromKeyVault` → Properties.ProtectedSettingsFromKeyVault
3. `extension.Properties = &extensionProps` → Extension.Properties
4. `extensionProfile.Extensions = &extensions` → ExtensionProfile.Extensions
5. `virtualMachineProfile.ExtensionProfile = extensionProfile` → VirtualMachineProfile.ExtensionProfile
6. `props.Properties.VirtualMachineProfile = &virtualMachineProfile` → Properties.VirtualMachineProfile

**Verified Path:** `properties.virtualMachineProfile.extensionProfile.extensions[].properties.protectedSettingsFromKeyVault.sourceVault.id`

**Path Comparison:** ✅ MATCH - Predicted path matches verified path.

## Provider Schema

From `protectedSettingsFromKeyVaultSchema`:

```go
func protectedSettingsFromKeyVaultSchema(conflictsWithProtectedSettings bool) *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        MaxItems: 1,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "secret_url": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ValidateFunc: keyVaultValidate.NestedItemId,
                },
                "source_vault_id": commonschema.ResourceIDReferenceRequired(&commonids.KeyVaultId{}),
            },
        },
    }
}
```

From `commonschema.ResourceIDReferenceRequired`:

```go
func ResourceIDReferenceRequired(parser resourceids.ResourceIdParser) *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:         pluginsdk.TypeString,
        Required:     true,
        ValidateFunc: validation.IsResourceId(parser),
    }
}
```

**Key Properties:**
- **Type:** `TypeString`
- **Required:** `true`
- **ValidateFunc:** Validates that the string is a valid Key Vault resource ID (format: `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}`)

## Azure API Schema

**Path:** `properties.virtualMachineProfile.extensionProfile.extensions[].properties.protectedSettingsFromKeyVault.sourceVault.id`

**Type:** String (within SubResource object)

**Description:** The resource ID of the Azure Key Vault that contains the secret referenced by secretUrl.

**Structure:**
```json
{
  "protectedSettingsFromKeyVault": {
    "secretUrl": "string",
    "sourceVault": {
      "id": "string"
    }
  }
}
```

## Hidden Fields

### Analysis of Expand Function

From `expandProtectedSettingsFromKeyVaultVMSS`:

```go
func expandProtectedSettingsFromKeyVaultVMSS(input []interface{}) *virtualmachinescalesets.KeyVaultSecretReference {
    if len(input) == 0 {
        return nil
    }

    v := input[0].(map[string]interface{})

    return &virtualmachinescalesets.KeyVaultSecretReference{
        SecretURL: v["secret_url"].(string),
        SourceVault: virtualmachinescalesets.SubResource{
            Id: pointer.To(v["source_vault_id"].(string)),  // <-- Direct assignment from schema
        },
    }
}
```

**Hidden Fields Found:** NONE

The expand function directly reads `source_vault_id` from the schema with no transformations, defaults, or additional logic. It's a straightforward string assignment wrapped in the `SubResource` structure.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) |
|------------------------|----------------------|
| source_vault_id | sourceVault.id |

## Special Handling

### Type 4: Block Argument

This is a **Type 4 task** - implementing a nested block argument. The implementation:

1. **Parent Block Exists:** Task #54 created the `protectedSettingsFromKeyVault` skeleton
2. **SubResource Structure:** The field is wrapped in a `sourceVault` object (SubResource type)
3. **Direct Assignment:** The field value is directly assigned from the variable to the nested structure

### Conditional Logic

The field is only rendered when the parent block `ext.protected_settings_from_key_vault != null` (handled by Task #54 skeleton).

**Implementation:**
```hcl
ext.protected_settings_from_key_vault != null ? {
  protectedSettingsFromKeyVault = {
    secretUrl = ext.protected_settings_from_key_vault.secret_url
    sourceVault = {
      id = ext.protected_settings_from_key_vault.source_vault_id
    }
  }
} : {}
```

### Required Field

Since `source_vault_id` is marked as `Required: true` in the provider schema, Terraform will enforce that it must be provided when the parent `protected_settings_from_key_vault` block is defined. No additional null checks are needed within the locals block.

## Validation Requirements

From the provider schema:

```go
"source_vault_id": commonschema.ResourceIDReferenceRequired(&commonids.KeyVaultId{}),
```

Which expands to:

```go
func ResourceIDReferenceRequired(parser resourceids.ResourceIdParser) *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:         pluginsdk.TypeString,
        Required:     true,
        ValidateFunc: validation.IsResourceId(parser),
    }
}
```

**Validation Analysis:**

The `validation.IsResourceId` function with `&commonids.KeyVaultId{}` parser validates that the string is a valid Key Vault resource ID following the format:
- `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}`

**Implementation Decision:**

The validation is already present in `variables.tf` through the object type definition:
```hcl
protected_settings_from_key_vault = optional(object({
  secret_url      = string
  source_vault_id = string
}))
```

Since `source_vault_id` is defined as a non-nullable `string` within the object, Terraform enforces:
1. **Required when block is present:** If `protected_settings_from_key_vault` block is defined, both `secret_url` and `source_vault_id` must be provided
2. **Type validation:** Must be a string

**Key Vault Resource ID Format Validation:**

Following the same rationale as Task #55 and aligned with executor.md line 102:
- **Skip resource ID format validations:** executor.md explicitly states "Skip ONLY Azure Resource ID format validations (e.g., `/subscriptions/.../resourceGroups/...`)"
- **This is a resource reference:** The `source_vault_id` is an Azure resource ID reference, similar to other resource ID fields
- **Users typically reference existing resources:** Users will reference existing Key Vault resources using Terraform data sources or resource outputs, making format errors unlikely
- **Azure API validates:** The Azure API will validate the resource ID format and existence during resource creation

**Decision:** No additional validation block needed in `variables.tf`. The Key Vault resource ID format will be validated by Azure API when the resource is created. The Required constraint is already enforced by the object type definition.

## Critical Review & Edge Case Analysis

### Null Semantics

**Field-Level Null:**
- `ext.protected_settings_from_key_vault.source_vault_id` - Cannot be null due to Required constraint in schema
- Terraform enforces presence when parent block is defined

**Parent Block Null:**
- `ext.protected_settings_from_key_vault == null` → Entire `protectedSettingsFromKeyVault` block omitted (handled by Task #54)

### Edge Cases

1. **Empty String:** Schema Required constraint prevents empty string (Terraform validates non-empty)
2. **Invalid Resource ID Format:** Will be validated by Azure API during resource creation
3. **Key Vault Not Found:** Azure API will return error if resource ID is valid but Key Vault doesn't exist
4. **Permissions:** Azure API will validate that the VMSS has permissions to access the specified Key Vault
5. **Cross-Subscription/Cross-Region:** Azure API will validate that the Key Vault is accessible from the VMSS's location and subscription context

### Idempotency

**Direct Assignment:**
- String value is used as-is, no transformations
- Same input always produces same output
- No ordering concerns (single value, not a collection)

### Safe References

**Current Implementation:**
```hcl
ext.protected_settings_from_key_vault != null ? {
  protectedSettingsFromKeyVault = {
    secretUrl = ext.protected_settings_from_key_vault.secret_url
    sourceVault = {
      id = ext.protected_settings_from_key_vault.source_vault_id
    }
  }
} : {}
```

**Safety Check:** ✅ SAFE
- Parent null check performed by Task #54 skeleton
- Required constraint ensures both fields exist when parent block is present
- Direct field access is safe after null guard
- Nested `sourceVault` object structure properly created

## Deferred Work Completion

**Check following.md:** No `following.md` file exists, so no deferred work to complete.

**Deferred Work Recording:** No work deferred to other tasks.

## Checklist

- ✅ Property in correct local (body)
- ✅ ForceNew handling: N/A (no ForceNew on this field)
- ✅ All logic exactly replicated from provider (direct string assignment in SubResource structure)
- ✅ Validations: Required constraint enforced by object type definition, resource ID format skipped per executor.md line 102
- ✅ Hidden fields checked (none found)
- ✅ Deferred work completed: N/A (no following.md)
- ✅ Deferred work recorded: N/A (no deferrals made)
- ✅ Critical review completed
- ✅ Edge case analysis documented
- ✅ Proof document created
- ✅ Track.md will be updated to "Pending for check"
- ✅ Self-review: Only implemented source_vault_id (Task #56), completing the protected_settings_from_key_vault block

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-09
**Task:** #56 - extension.protected_settings_from_key_vault.source_vault_id

### Validation Results

✅ **Field Type & Scope:** Task #56 correctly implements ONLY the `source_vault_id` field within the `protected_settings_from_key_vault` block (Type 4: Block Argument)

✅ **Create Phase Verification:** Correctly identified as Create phase field - set during `expandOrchestratedVirtualMachineScaleSetExtensions` before `CreateOrUpdate` call. Placed in `local.body` as required.

✅ **Assignment Path Verification:** Correct path `properties.virtualMachineProfile.extensionProfile.extensions[].properties.protectedSettingsFromKeyVault.sourceVault.id` - matches provider implementation with proper SubResource structure

✅ **Provider Schema Replication:** 
- Correctly identified as `Required: true` string field
- Type conversion: String → String (direct mapping)
- No hidden fields found in expand function

✅ **Nested Structure:** Correctly implements `sourceVault` object wrapping with `id` field inside, matching the provider's `SubResource` structure

✅ **Conditional Logic:** Field correctly rendered only when parent `ext.protected_settings_from_key_vault != null` (handled by Task #54 skeleton)

✅ **Validations:** 
- Required constraint enforced by object type definition in `variables.tf`
- Resource ID format validation appropriately skipped per executor.md line 102
- Follows same approach as Task #55 (`secret_url`)

✅ **ForceNew Logic:** N/A - no ForceNew on this field per provider schema

✅ **Stable Keys:** N/A - not in `replace_triggers_external_values`

✅ **Null Handling:** Safe reference - parent null check ensures field exists when accessed due to Required constraint

✅ **Deferred Work Completion:** No `following.md` file exists - no deferred work to complete

✅ **Deferred Work Recording:** No work deferred to other tasks

✅ **Edge Cases:** Properly analyzed - empty strings prevented by Required constraint, resource validation delegated to Azure API

✅ **Merge Structure:** No shared path conflicts - `protectedSettingsFromKeyVault` appears only once, fields merged correctly within it

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`:
- Direct string assignment wrapped in `sourceVault.id` SubResource structure matches provider's `expandProtectedSettingsFromKeyVaultVMSS` function
- Required field constraint properly enforced through object type definition
- No deviations, simplifications, or unnecessary additions found

The implementation is minimal, surgical, and precisely completes the `protected_settings_from_key_vault` block structure alongside Task #54 and #55.

**Status:** APPROVED ✅

---
