# Task #110 - os_profile.linux_configuration.secret.key_vault_id - Block Argument

## Summary

Implemented `os_profile.linux_configuration.secret.key_vault_id` field mapping to Azure API `properties.virtualMachineProfile.osProfile.secrets[].sourceVault.id`. This field specifies the Key Vault resource ID from which all certificates in the secret group should be sourced. The field is required when the parent `secret` block is present.

## Shadow Implementation

```hcl
locals {
  body = {
    properties = merge(
      var.orchestrated_virtual_machine_scale_set_sku_name != null ? {
        virtualMachineProfile = merge(
          var.orchestrated_virtual_machine_scale_set_os_profile != null ? {
            osProfile = merge(
              var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration != null && 
              var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.secret != null && 
              length(var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.secret) > 0 ? {
                secrets = [
                  for secret in var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.secret : {
                    sourceVault = {                    # <-
                      id = secret.key_vault_id         # <-
                    }                                   # <-
                    # vaultCertificates = ... # Task #111-112
                  }
                ]
              } : {}
            )
          } : {}
        )
      } : {}
    )
  }
}
```

## Create Phase Verification

### Pattern Identification

Queried Create method to identify the creation pattern.

**Evidence from Create method:**

From `resourceOrchestratedVirtualMachineScaleSetCreate`:

```go
if len(linConfigRaw) > 0 && linConfigRaw[0] != nil {
    osType = virtualmachinescalesets.OperatingSystemTypesLinux
    linConfig := linConfigRaw[0].(map[string]interface{})
    // ... other fields ...
    
    vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration(linConfig, customData)
    // ...
}

// Inside expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration:
if secrets := input["secret"].([]interface{}); len(secrets) > 0 {
    osProfile.Secrets = expandLinuxSecretsVMSS(secrets)
}

// ...
virtualMachineProfile.OsProfile = vmssOsProfile
// ...
props.Properties.VirtualMachineProfile = &virtualMachineProfile

if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Pattern:** Single-phase creation (Create phase only)

**Classification:** Create phase field - value set before the create API call

**Decision:** Implement in `local.body`

### Two-Phase Check

No two-phase pattern detected. The field is set once during Create and sent in the initial CreateOrUpdate call.

## Assignment Path Verification

### Predicted Path

Based on the Terraform schema `os_profile.linux_configuration.secret.key_vault_id`, the Azure API path should be:
```
properties.virtualMachineProfile.osProfile.secrets[].sourceVault.id
```

### Go Code Evidence

From the expand function `expandLinuxSecretsVMSS` in `shared_schema.go`:

```go
func expandLinuxSecretsVMSS(input []interface{}) *[]virtualmachinescalesets.VaultSecretGroup {
    output := make([]virtualmachinescalesets.VaultSecretGroup, 0)

    for _, raw := range input {
        v := raw.(map[string]interface{})

        keyVaultId := v["key_vault_id"].(string)  // <-- Terraform field
        certificatesRaw := v["certificate"].(*pluginsdk.Set).List()
        certificates := make([]virtualmachinescalesets.VaultCertificate, 0)
        for _, certificateRaw := range certificatesRaw {
            certificateV := certificateRaw.(map[string]interface{})

            url := certificateV["url"].(string)
            certificates = append(certificates, virtualmachinescalesets.VaultCertificate{
                CertificateURL: pointer.To(url),
            })
        }

        output = append(output, virtualmachinescalesets.VaultSecretGroup{
            SourceVault: &virtualmachinescalesets.SubResource{  // <-- Nested object
                Id: pointer.To(keyVaultId),                      // <-- API field
            },
            VaultCertificates: &certificates,
        })
    }

    return &output
}
```

**Critical Assignment in Create method:**

From `expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration`:

```go
if secrets := input["secret"].([]interface{}); len(secrets) > 0 {
    osProfile.Secrets = expandLinuxSecretsVMSS(secrets)
}

// osProfile is of type VirtualMachineScaleSetOSProfile
// osProfile.Secrets is []VaultSecretGroup
```

From Create method:

```go
virtualMachineProfile.OsProfile = vmssOsProfile

props := virtualmachinescalesets.VirtualMachineScaleSet{
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        VirtualMachineProfile: &virtualMachineProfile,  // <- profile contains OsProfile with Secrets
    },
}
```

### Verified Path

```
properties.virtualMachineProfile.osProfile.secrets[]
  .sourceVault
    .id  <- key_vault_id maps here
  .vaultCertificates[] (Task #111-112)
```

### Path Comparison

- **Predicted:** `properties.virtualMachineProfile.osProfile.secrets[].sourceVault.id`
- **Verified:** `properties.virtualMachineProfile.osProfile.secrets[].sourceVault.id`
- **Match:** ✅ Yes

## Provider Schema

From `linuxSecretSchema()` function:

```go
func linuxSecretSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                // whilst this isn't present in the nested object it's required when this is specified
                "key_vault_id": commonschema.ResourceIDReferenceRequired(&commonids.KeyVaultId{}),

                "certificate": {
                    Type:     pluginsdk.TypeSet,
                    Required: true,
                    MinItems: 1,
                    Elem: &pluginsdk.Resource{
                        Schema: map[string]*pluginsdk.Schema{
                            "url": {
                                Type:         pluginsdk.TypeString,
                                Required:     true,
                                ValidateFunc: keyVaultValidate.NestedItemId,
                            },
                        },
                    },
                },
            },
        },
    }
}
```

**Key Schema Details:**
- **Type:** String
- **Required:** Yes (when parent `secret` block is present)
- **ValidateFunc:** `commonschema.ResourceIDReferenceRequired(&commonids.KeyVaultId{})` - validates proper Key Vault resource ID format
- **ForceNew:** Not explicitly marked (inherits from parent block behavior)
- **Computed:** No
- **Sensitive:** No

From `variables.tf`:

```hcl
secret = optional(list(object({
  key_vault_id = string  # Required within the secret object
  certificate = set(object({
    url = string
  }))
})))
```

## Azure API Schema

From Go SDK types in `virtualmachinescalesets` package:

```go
type VirtualMachineScaleSetOSProfile struct {
    // ...
    Secrets *[]VaultSecretGroup `json:"secrets,omitempty"`
}

type VaultSecretGroup struct {
    SourceVault       *SubResource         `json:"sourceVault,omitempty"`
    VaultCertificates *[]VaultCertificate  `json:"vaultCertificates,omitempty"`
}

type SubResource struct {
    Id *string `json:"id,omitempty"`
}
```

**API Path:**
```
properties.virtualMachineProfile.osProfile.secrets[]
  .sourceVault
    .id  <- key_vault_id
```

**API Field Details:**
- **Name:** `id` (within `sourceVault` object)
- **Type:** `*string` (pointer to string, optional but required in practice)
- **JSON Tag:** `"id,omitempty"`
- **Parent:** `sourceVault` object of type `SubResource`

## Hidden Fields

### Analysis of Expand Function

From `expandLinuxSecretsVMSS`:

```go
output = append(output, virtualmachinescalesets.VaultSecretGroup{
    SourceVault: &virtualmachinescalesets.SubResource{
        Id: pointer.To(keyVaultId),  // Direct mapping, no transformations
    },
    VaultCertificates: &certificates,
})
```

**Hidden Fields:** None

The `key_vault_id` field is directly mapped to `sourceVault.id` with no:
- Additional hardcoded values
- Computed transformations
- Hidden API-only fields
- Default values applied

The only transformation is wrapping the string in a pointer via `pointer.To()`, which is a standard Go pattern for optional fields.

## Mapping

| Terraform Field | Azure API Field | Notes |
|----------------|-----------------|-------|
| `key_vault_id` | `secrets[].sourceVault.id` | Direct string mapping |

**Naming Convention:**
- `key_vault_id` (snake_case) → nested path: `sourceVault.id` (camelCase)
- The nesting structure creates an intermediate object `sourceVault` of type `SubResource`
- `sourceVault` is not a direct mapping but a structural requirement of the API

**Type Conversion:**
- Terraform: `string`
- Go: `*string` (pointer)
- Azure API: `string` (JSON)

## Special Handling

### Validation

The provider uses `commonschema.ResourceIDReferenceRequired(&commonids.KeyVaultId{})` which validates:
1. The ID follows Azure resource ID format
2. The resource type is `Microsoft.KeyVault/vaults`
3. All required segments are present (subscription, resource group, provider, vault name)

**Expected format:**
```
/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}
```

**Implementation in `variables.tf`:**

Added validation block to the parent `orchestrated_virtual_machine_scale_set_os_profile` variable:

```hcl
validation {
  condition = (
    var.orchestrated_virtual_machine_scale_set_os_profile == null ||
    var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration == null ||
    var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.secret == null ||
    alltrue([
      for secret in var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.secret :
      can(regex("^/subscriptions/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/resourceGroups/[^/]+/providers/Microsoft.KeyVault/vaults/[^/]+$", secret.key_vault_id))
    ])
  )
  error_message = "Each key_vault_id must be a valid Key Vault resource ID in the format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}."
}
```

**Validation Details:**
- Checks all secrets in the list using `alltrue()`
- Validates UUID format for subscription ID
- Ensures proper Azure resource ID structure
- Matches exact provider type `Microsoft.KeyVault/vaults`
- Fails fast at plan time before API call

### ForceNew Behavior

No explicit `ForceNew: true` in schema. The field behavior:
- Can be modified after creation (no forced replacement)
- Updates are supported through the Update method
- Changes to certificates in a Key Vault are propagated on update

**Decision:** No special ForceNew handling required. Field is mutable.

### Nesting Structure

The implementation creates a nested object structure:

```hcl
sourceVault = {
  id = secret.key_vault_id
}
```

This matches the Azure API requirement where `sourceVault` is a separate object containing the Key Vault reference, not just a flat ID field.

### Sensitive Data

The `key_vault_id` itself is NOT sensitive (it's a resource identifier), but it references a Key Vault that contains sensitive certificates. The field itself doesn't need to be marked as sensitive or ephemeral.

## Critical Review & Edge Cases

### Null Semantics

**`null` key_vault_id:**
- The field is Required within the `secret` object, so it cannot be null when a secret block is present
- Schema validation enforces this at Terraform plan time
- If somehow null, the validation would fail before reaching the API

**Empty string:**
- Not a valid Key Vault ID
- Validation regex will reject empty strings
- Result: Error at plan time with clear message

**Invalid format:**
- Validation regex checks the exact Azure resource ID format
- Malformed IDs fail at plan time, not during API call
- Provides better user experience than waiting for API error

### Boundary Conditions

1. **Valid Key Vault ID:** Standard case, direct mapping to API
2. **Key Vault in different subscription:** Valid - Azure supports cross-subscription references
3. **Key Vault in different resource group:** Valid - common scenario
4. **Deleted Key Vault:** API will fail at runtime (cannot validate existence at plan time)
5. **Key Vault without access permissions:** API will fail at runtime with permission error

### Idempotency

The implementation is idempotent:
- Same `key_vault_id` input produces same `sourceVault.id` output
- No state dependencies
- No side effects
- Direct string mapping without transformations

### Safe References

**Variable Access Chain:**
```hcl
secret.key_vault_id
```

**Safety Checks:**
- Parent condition checks `secret != null` and `length(secret) > 0`
- Within the for loop, each `secret` object is guaranteed to exist
- The `key_vault_id` field is required by schema, so it's always present in each secret object

**Safe because:** The for loop only executes when the list is non-empty, and each iteration accesses a required field.

### Edge Case: Case Sensitivity

Azure resource IDs are case-insensitive, but Terraform treats them as case-sensitive strings.

**Provider behavior:** No DiffSuppressFunc for this field, so case differences will trigger updates.

**Impact:** If the API returns a different case (e.g., uppercase resource group name) than provided, Terraform will detect a drift.

**Handling:** Users should use consistent casing matching their resource definitions. This matches provider behavior exactly.

### Edge Case: Multiple Secrets Referencing Same Key Vault

**Scenario:** Multiple secret blocks with the same `key_vault_id` but different certificates.

**Provider behavior:** Allowed and valid - each secret group can reference the same Key Vault.

**Implementation:** Each iteration of the for loop creates an independent `sourceVault` object, so this scenario works correctly.

### Edge Case: Integration with certificate Block (Task #111)

The `key_vault_id` and `certificate` blocks work together:
- `key_vault_id` specifies WHERE to get certificates
- `certificate` specifies WHICH certificates to get

**Dependency:** Task #111 will implement the `vaultCertificates` array within the same secret object. The two fields are siblings within each secret group.

**No cross-field validation needed:** The provider doesn't validate that the certificate URLs belong to the specified Key Vault - Azure API handles this at runtime.

## Completion Checklist

- ✅ Property in correct local (`local.body`)
- ✅ Field placed in correct path: `secrets[].sourceVault.id`
- ✅ ForceNew: Not applicable (field is mutable)
- ✅ Validations: Implemented Key Vault resource ID format validation in `variables.tf`
- ✅ Hidden fields: None (direct mapping)
- ✅ Deferred work: None for this task
- ✅ Critical review completed
- ✅ Edge case analysis included
- ✅ Proof document created
- ✅ `track.md` will be updated to "Pending for check"
- ✅ Self-Review: Only `key_vault_id` field implemented, no other fields added

## Notes

1. **Direct Mapping:** The field is a straightforward string mapping with nested object structure (`sourceVault.id`).

2. **Validation Replicated:** The provider's `ResourceIDReferenceRequired` validation is replicated using a regex pattern that checks:
   - Subscription ID UUID format
   - Resource group presence
   - Correct provider namespace `Microsoft.KeyVault/vaults`
   - Vault name presence

3. **No Transformation:** Unlike some fields that require normalization or conversion, `key_vault_id` is passed through directly.

4. **Parent Block Context:** This field exists within the parent `secret` block (Task #109) and works alongside the `certificate` block (Tasks #111-112).

5. **Required Field:** Although the parent `secret` block is optional, when it is present, `key_vault_id` is required by schema.

6. **Sibling Relationship:** This task (#110) and the certificate block task (#111) can be implemented in parallel as they are siblings within the secret object.

7. **No DiffSuppressFunc:** The field has no DiffSuppressFunc, so exact string matching is used for drift detection.

8. **Cross-Subscription Support:** Azure supports referencing Key Vaults from different subscriptions, and the implementation correctly supports this by accepting any valid Key Vault resource ID.

9. **API Behavior:** The Azure API validates:
   - Key Vault existence at runtime
   - Access permissions at runtime
   - Certificate URL validity at runtime (Task #112)

10. **Integration Point:** The `sourceVault.id` and `vaultCertificates[]` fields work together to provision certificates from a Key Vault to Linux VMs in the scale set.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #110 - os_profile.linux_configuration.secret.key_vault_id

### Validation Results

✅ **Path Mapping:** Correctly maps `key_vault_id` to `properties.virtualMachineProfile.osProfile.secrets[].sourceVault.id`
✅ **Create Phase:** Field correctly placed in `local.body` (Create phase, single-phase creation pattern)
✅ **Type Conversion:** Correct conversion from Terraform `string` to Azure API nested object structure `sourceVault.id`
✅ **Null Handling:** Safe - parent conditions check `secret != null` and `length(secret) > 0` before for loop iteration
✅ **Validations:** Provider validation (`ResourceIDReferenceRequired(&commonids.KeyVaultId{})`) correctly replicated in `variables.tf` with comprehensive regex checking:
  - Subscription ID format (UUID)
  - Resource group presence
  - Provider namespace `Microsoft.KeyVault/vaults`
  - Vault name presence
✅ **ForceNew Logic:** Not applicable (field is mutable, no ForceNew in schema or CustomizeDiff)
✅ **Stable Keys:** Not applicable (not in replace_triggers_external_values)
✅ **Merge Structure:** Correct - `secrets` key appears only once in osProfile merge at line 418, no duplicate parent keys causing overwrites
✅ **Deferred Work Completion:** No deferred work for this task in `following.md`
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** Comprehensive analysis in proof document covering:
  - Null semantics and required field behavior
  - Resource ID format validation
  - Cross-subscription and cross-resource-group references
  - Case sensitivity handling
  - Multiple secrets with same Key Vault ID
  - Integration with certificate block (Task #111)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`:
- Direct mapping from `key_vault_id` to nested `sourceVault.id` structure matches Go code in `expandLinuxSecretsVMSS`
- No transformations beyond wrapping in required object structure
- Validation logic matches provider's `ResourceIDReferenceRequired` validation exactly
- No hidden fields, no computed defaults, no simplifications
- No deviations, no "safer alternatives", no shortcuts

**Status:** APPROVED ✅

---
