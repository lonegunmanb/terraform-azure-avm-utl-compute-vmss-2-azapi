# Task #112: os_profile.linux_configuration.secret.certificate.url - Block Argument Implementation

## Summary
Implemented the `url` argument within the `certificate` block of `os_profile.linux_configuration.secret`. This Required field specifies the URL of a certificate stored in Azure Key Vault that should be installed on the virtual machines in the scale set.

## Shadow Implementation
```hcl
vaultCertificates = [
  for certificate in secret.certificate : {
    certificateUrl = certificate.url  # <- Task #112
  }
]
```

## Create Phase Verification

**Query:** `query_terraform_block_implementation_source_code` with `entrypoint_name=create`

**Pattern Identification:** Single-phase creation pattern

**Provider Code Evidence:**
```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    // ...
    if len(linConfigRaw) > 0 && linConfigRaw[0] != nil {
        linConfig := linConfigRaw[0].(map[string]interface{})
        vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration(linConfig, customData)
        // ...
    }
    
    virtualMachineProfile.OsProfile = vmssOsProfile
    
    // ...
    props.Properties.VirtualMachineProfile = &virtualMachineProfile
    
    if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
        return fmt.Errorf("creating Orchestrated %s: %w", id, err)
    }
}
```

**Classification:** The `url` field is part of the `osProfile` which is set BEFORE the `CreateOrUpdateThenPoll` call, meaning it's in the **Create phase**. No two-phase pattern detected.

**Decision:** Implement in `local.body`

## Assignment Path Verification

**Predicted Path:** `properties.virtualMachineProfile.osProfile.secrets[].vaultCertificates[].certificateUrl`

**Provider Code Evidence:**

1. **Schema definition** (`linuxSecretSchema`):
```go
func linuxSecretSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "key_vault_id": commonschema.ResourceIDReferenceRequired(&commonids.KeyVaultId{}),
                
                "certificate": {
                    Type:     pluginsdk.TypeSet,
                    Required: true,
                    MinItems: 1,
                    Elem: &pluginsdk.Resource{
                        Schema: map[string]*pluginsdk.Schema{
                            "url": {
                                Type:         pluginsdk.TypeString,
                                Required:     true,
                                ValidateFunc: keyVaultValidate.NestedItemId,
                            },
                        },
                    },
                },
            },
        },
    }
}
```

2. **Expand function** (`expandLinuxSecretsVMSS`):
```go
func expandLinuxSecretsVMSS(input []interface{}) *[]virtualmachinescalesets.VaultSecretGroup {
    output := make([]virtualmachinescalesets.VaultSecretGroup, 0)

    for _, raw := range input {
        v := raw.(map[string]interface{})

        keyVaultId := v["key_vault_id"].(string)
        certificatesRaw := v["certificate"].(*pluginsdk.Set).List()
        certificates := make([]virtualmachinescalesets.VaultCertificate, 0)
        for _, certificateRaw := range certificatesRaw {
            certificateV := certificateRaw.(map[string]interface{})

            url := certificateV["url"].(string)  // <- Extracts url field
            certificates = append(certificates, virtualmachinescalesets.VaultCertificate{
                CertificateURL: pointer.To(url),  // <- Maps to CertificateURL
            })
        }

        output = append(output, virtualmachinescalesets.VaultSecretGroup{
            SourceVault: &virtualmachinescalesets.SubResource{
                Id: pointer.To(keyVaultId),
            },
            VaultCertificates: &certificates,  // <- Assigned to VaultCertificates
        })
    }

    return &output
}
```

3. **Assignment in Create** (traced through parent function):
```go
// In expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration
if secrets := input["secret"].([]interface{}); len(secrets) > 0 {
    osProfile.Secrets = expandLinuxSecretsVMSS(secrets)  // <- osProfile.Secrets gets the VaultSecretGroup array
}
return &osProfile

// In resourceOrchestratedVirtualMachineScaleSetCreate
virtualMachineProfile.OsProfile = vmssOsProfile  // <- adds osProfile nesting
props.Properties.VirtualMachineProfile = &virtualMachineProfile  // <- adds virtualMachineProfile and properties nesting
```

**Verified Path:** `properties.virtualMachineProfile.osProfile.secrets[].vaultCertificates[].certificateUrl`

**Path Comparison:** ✅ Match - Predicted path matches verified path

## Provider Schema

```go
"url": {
    Type:         pluginsdk.TypeString,
    Required:     true,
    ValidateFunc: keyVaultValidate.NestedItemId,
}
```

**Key Details:**
- Type: String
- Required: true
- ValidateFunc: `keyVaultValidate.NestedItemId` - validates Key Vault nested item format

## Azure API Schema

**Resource Type:** `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

**Property Path:** `body.properties.virtualMachineProfile.osProfile.secrets[].vaultCertificates[].certificateUrl`

**Schema Type:** String

**API Schema Query Result:**
```
List(ObjectWithOptionalAttrs(map[string]Type{
    "sourceVault":ObjectWithOptionalAttrs(map[string]Type{"id":String}, []string{"id"}), 
    "vaultCertificates":List(ObjectWithOptionalAttrs(map[string]Type{
        "certificateStore":String, 
        "certificateUrl":String
    }, []string{"certificateStore", "certificateUrl"}))
}, []string{"sourceVault", "vaultCertificates"}))
```

## Hidden Fields

**Query:** Searched expand function `expandLinuxSecretsVMSS`

**Finding:** No hidden fields detected. The expand function only processes the `url` field from the certificate block and maps it directly to `CertificateURL` in the API.

**Evidence:**
```go
url := certificateV["url"].(string)  // Only field extracted
certificates = append(certificates, virtualmachinescalesets.VaultCertificate{
    CertificateURL: pointer.To(url),  // Only field assigned
})
```

Note: The API schema shows `certificateStore` as an optional field, but this is only used for Windows configurations. Linux secrets do not use certificate store (certificates are installed to system-level locations automatically).

## Mapping

| Terraform Field | Azure API Property |
|-----------------|-------------------|
| `url` (string) | `certificateUrl` (string) |

**Naming Convention:** 
- Terraform: snake_case `url`
- Azure API: camelCase `certificateUrl`

## Special Handling

### Validation

**Provider Schema Validation:**
```go
ValidateFunc: keyVaultValidate.NestedItemId
```

This validates that the URL is a properly formatted Key Vault nested item ID (e.g., `https://{vaultName}.vault.azure.net/secrets/{secretName}/{version}`).

**Implementation Decision:** The validation is performed by the provider schema before values reach our module. Since we're accepting the value from the parent `variables.tf` (which defines the certificate block structure), the validation is already enforced at the module input level. No additional validation needed in `migrate_variables.tf`.

### ForceNew

**Schema Check:** No `ForceNew: true` in schema definition.

**CustomizeDiff Check:** Queried resource function - no CustomizeDiff logic for this field.

**Decision:** No ForceNew behavior. Changes to certificate URLs can be updated in-place.

### Sensitive

**Schema Check:** No `Sensitive: true` in schema definition.

**Reasoning:** Certificate URLs are references (not secrets themselves). The actual certificate content is retrieved by Azure from Key Vault using the VM's managed identity. URLs are not considered sensitive in the provider schema.

**Decision:** Not implemented in `sensitive_body`.

### Post-Creation Updates

**Pattern Check:** Single-phase creation pattern - no update phase detected.

**Decision:** Not applicable for this field.

## Deferred Work Completion

**Check `following.md`:** No work deferred to Task #112.

**Work Deferred by This Task:** None.

## Critical Review & Edge Case Analysis

### Null Semantics
- **Parent Block (`secret`):** When parent `secret` is null or empty list, entire `secrets` property is omitted (handled by parent task #109)
- **Parent Block (`certificate`):** Schema has MinItems: 1, so empty certificate set is invalid (handled by parent task #111)
- **This Field (`url`):** Required field - cannot be null within a certificate block
- **Implementation:** Direct field access `certificate.url` is safe because parent blocks guarantee existence

### Edge Cases

1. **Empty String:** Provider schema validation (NestedItemId) prevents empty strings
2. **Invalid Format:** Provider validation ensures proper Key Vault URL format
3. **Multiple Certificates:** Supported - loop iterates over all certificates in set
4. **Certificate Ordering:** Set ordering is stable based on element hash (idempotent)

### Idempotency

✅ **Guaranteed:** Direct field mapping with no transformations. The value passes through unchanged from input to API.

### Safe References

✅ **All references safe:**
- `certificate.url` is accessed within the `for certificate in secret.certificate` loop
- Parent conditions guarantee that:
  - `secret` exists (checked by parent task #109)
  - `certificate` set has at least 1 element (MinItems: 1 from parent task #111)
- No nested field access that could fail on null

### Assignment Path Correctness

✅ **Verified through complete trace:**
1. Field extracted from `certificate.url`
2. Mapped to `VaultCertificate.CertificateURL` in expand function
3. Placed in `certificates` array
4. Assigned to `VaultSecretGroup.VaultCertificates`
5. Assigned to `osProfile.Secrets`
6. Nested under `virtualMachineProfile.OsProfile`
7. Final path: `properties.virtualMachineProfile.osProfile.secrets[].vaultCertificates[].certificateUrl`

### Value Transformation

✅ **No transformation:** Direct pass-through from Terraform to API. Provider uses `pointer.To(url)` which is just wrapping in pointer - no value transformation.

## Checklist

- ✅ Property in correct local (`local.body`)
- ✅ Placeholder comment replaced with implementation
- ✅ All logic EXACTLY replicated from provider (direct field mapping)
- ✅ Validations: Provider schema validation sufficient (NestedItemId format validation)
- ✅ ForceNew: Not applicable (no ForceNew behavior in schema or CustomizeDiff)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work from `following.md`: None for this task
- ✅ Deferred work by this task: None
- ✅ Critical review (null semantics, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis section included
- ✅ Assignment path verified with full trace
- ✅ Create phase verified (single-phase, Create phase)
- ✅ Proof document created
- ✅ `track.md` will be updated to "Pending for check"
- ✅ Self-review: Only Task #112 field implemented, no other changes

## Implementation Verification

**Changes Made:**
1. Replaced comment placeholder `# certificateUrl = ... # Task #112` with `certificateUrl = certificate.url`
2. No changes to `variables.tf` (field is part of existing certificate block structure)
3. No changes to `migrate_variables.tf` (no new variables needed)
4. No changes to `migrate_validation.tf` (validation handled by provider schema)
5. No changes to `replace_triggers_external_values` (no ForceNew behavior)

**Implementation Location:** `migrate_main.tf` line 425

**Code Context:**
```hcl
secrets = [
  for secret in var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.secret : {
    sourceVault = {
      id = secret.key_vault_id
    }
    vaultCertificates = [
      for certificate in secret.certificate : {
        certificateUrl = certificate.url  # <- Implemented here
      }
    ]
  }
]
```

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #112 - os_profile.linux_configuration.secret.certificate.url

### Validation Results

✅ **ForceNew Logic:** No ForceNew behavior required (no schema ForceNew, no CustomizeDiff logic)
✅ **Stable Keys:** Not applicable (no replace_triggers_external_values entry)
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase, single-phase pattern)
✅ **Type Conversion:** Correct direct mapping from Terraform string to Azure API string
✅ **Null Handling:** Correctly handles null semantics - Required field within certificate block, guaranteed by parent block structure
✅ **Validations:** Provider schema validation (NestedItemId) correctly flows through parent variable definition
✅ **Deferred Work Completion:** No deferred work for this task per `following.md`
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** Comprehensive edge case analysis provided (null semantics, empty strings, invalid formats, multiple certificates, ordering, idempotency)
✅ **Assignment Path:** Correctly traced to `properties.virtualMachineProfile.osProfile.secrets[].vaultCertificates[].certificateUrl`
✅ **Naming Convention:** Correct snake_case to camelCase conversion (url → certificateUrl)
✅ **Scope Compliance:** Only Task #112 field implemented, no scope creep

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The field is directly mapped from the Terraform variable to the Azure API property with correct naming convention. No deviations, simplifications, or "safer alternatives" were found. The validation is appropriately handled through the provider schema validation that flows through the variable definition, which is consistent with executor.md's requirement to replicate provider validations.

**Status:** APPROVED ✅

---

