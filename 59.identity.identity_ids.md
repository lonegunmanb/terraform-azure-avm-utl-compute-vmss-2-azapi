# Task #59: identity.identity_ids - Block Argument Implementation

## Summary

Implemented `identity.identity_ids` argument within the existing identity block skeleton in `azapi_header`. The identity_ids field is Required (when identity block is present) and accepts a set of User Assigned Identity IDs. In azapi_resource, this maps to the `identity_ids` parameter (not the Azure API's `userAssignedIdentities` structure). The field includes validation for proper User Assigned Identity resource ID format.

## Shadow Implementation

```hcl
locals {
  azapi_header = merge(
    {
      type      = "Microsoft.Compute/virtualMachineScaleSets@2024-11-01"
      name      = var.orchestrated_virtual_machine_scale_set_name
      location  = var.orchestrated_virtual_machine_scale_set_location
      parent_id = var.orchestrated_virtual_machine_scale_set_resource_group_id
    },
    var.orchestrated_virtual_machine_scale_set_identity != null ? {
      identity = {
        type         = var.orchestrated_virtual_machine_scale_set_identity.type # <-
        identity_ids = tolist(var.orchestrated_virtual_machine_scale_set_identity.identity_ids) # <-
      }
    } : {}
  )
}
```

```hcl
# variables.tf
variable "orchestrated_virtual_machine_scale_set_identity" {
  type = object({
    identity_ids = set(string)
    type         = string
  })
  default     = null
  description = <<-EOT
 - `identity_ids` - (Required) Specifies a list of User Managed Identity IDs to be assigned to this Windows Virtual Machine Scale Set.
 - `type` - (Required) The type of Managed Identity that should be configured on this Windows Virtual Machine Scale Set. Only possible value is `UserAssigned`.
EOT

  validation {
    condition = (
      var.orchestrated_virtual_machine_scale_set_identity == null ||
      var.orchestrated_virtual_machine_scale_set_identity.type == "UserAssigned"
    )
    error_message = "The type must be 'UserAssigned'."
  }

  validation { # <-
    condition = ( # <-
      var.orchestrated_virtual_machine_scale_set_identity == null || # <-
      (length(var.orchestrated_virtual_machine_scale_set_identity.identity_ids) > 0 && # <-
        alltrue([for id in var.orchestrated_virtual_machine_scale_set_identity.identity_ids : can(regex("^/subscriptions/[^/]+/resourceGroups/[^/]+/providers/Microsoft\\.ManagedIdentity/userAssignedIdentities/[^/]+$", id))])) # <-
    ) # <-
    error_message = "All identity_ids must be valid User Assigned Identity resource IDs in the format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}." # <-
  } # <-
}
```

## Create Phase Verification

### Query Result from Create Method

From `resourceOrchestratedVirtualMachineScaleSetCreate`:

```go
if v, ok := d.GetOk("identity"); ok {
    identityExpanded, err := identity.ExpandSystemAndUserAssignedMap(v.([]interface{}))
    if err != nil {
        return fmt.Errorf("expanding `identity`: %w", err)
    }
    props.Identity = identityExpanded
}
```

This code appears in the Create method BEFORE the `client.CreateOrUpdateThenPoll()` call.

### Analysis

**Pattern:** Single-phase creation  
**Field Classification:** Create phase - identity_ids is part of the identity block expanded and set on `props.Identity` before the CreateOrUpdate API call  
**Decision:** Field value goes in `azapi_header.identity.identity_ids` (root level of azapi_resource)

## Assignment Path Verification

### Predicted Path

Based on Azure API schema for `Microsoft.Compute/virtualMachineScaleSets@2024-11-01` and AzAPI resource design:
- Root-level property: `identity` (object)
- Child parameter: `identity_ids` (list of strings in azapi_resource)

**Critical Note:** AzAPI resource uses `identity_ids` parameter directly at the identity level. This is NOT the same as Azure API's `userAssignedIdentities` map structure. AzAPI provider handles the transformation internally.

### Go Code Evidence

From the `ExpandSystemAndUserAssignedMap` function:

```go
func ExpandSystemAndUserAssignedMap(input []interface{}) (*SystemAndUserAssignedMap, error) {
    identityType := TypeNone
    identityIds := make(map[string]UserAssignedIdentityDetails, 0)

    if len(input) > 0 {
        raw := input[0].(map[string]interface{})
        // ... type processing ...
        
        identityIdsRaw := raw["identity_ids"].(*schema.Set).List()
        for _, v := range identityIdsRaw {
            identityIds[v.(string)] = UserAssignedIdentityDetails{
                // intentionally empty since the expand shouldn't send these values
            }
        }
    }

    if len(identityIds) > 0 && (identityType != TypeSystemAssignedUserAssigned && identityType != TypeUserAssigned) {
        return nil, fmt.Errorf("`identity_ids` can only be specified when `type` is set to %q or %q", string(TypeSystemAssignedUserAssigned), string(TypeUserAssigned))
    }

    return &SystemAndUserAssignedMap{
        Type:        identityType,
        IdentityIds: identityIds,
    }, nil
}
```

The `SystemAndUserAssignedMap` struct:

```go
type SystemAndUserAssignedMap struct {
    Type        Type                                   `json:"type" tfschema:"type"`
    PrincipalId string                                 `json:"principalId" tfschema:"principal_id"`
    TenantId    string                                 `json:"tenantId" tfschema:"tenant_id"`
    IdentityIds map[string]UserAssignedIdentityDetails `json:"userAssignedIdentities"`
}
```

**Key transformation:**
- **AzureRM provider input:** Set of identity ID strings
- **Expand function converts:** Set → Map with IDs as keys and empty UserAssignedIdentityDetails as values
- **Azure API receives:** `userAssignedIdentities` as a map

**AzAPI handling:**
AzAPI resource accepts `identity_ids` as a list parameter and handles the map transformation internally. We don't need to create the map structure ourselves.

### Verified Path

**In azapi_resource:**
- Root level: `identity.identity_ids` (list parameter)

**Assignment chain:**
1. Terraform config: `identity.identity_ids` (set of strings from user)
2. Shadow module: Convert set to list with `tolist()`
3. AzAPI resource: Receives list and transforms to API's map structure internally
4. API request: Serialized as `userAssignedIdentities` map

### Path Comparison

✅ **Match** - The identity_ids field is correctly placed at `identity.identity_ids` in azapi_header, using azapi_resource's native identity parameter structure

## Provider Schema

From `resourceOrchestratedVirtualMachineScaleSet()` schema:

```go
"identity": commonschema.UserAssignedIdentityOptional(),
```

The `commonschema.UserAssignedIdentityOptional()` function:

```go
func UserAssignedIdentityOptional() *schema.Schema {
    return &schema.Schema{
        Type:     schema.TypeList,
        Optional: true,
        MaxItems: 1,
        Elem: &schema.Resource{
            Schema: map[string]*schema.Schema{
                "type": {
                    Type:     schema.TypeString,
                    Required: true,
                    ValidateFunc: validation.StringInSlice([]string{
                        string(identity.TypeUserAssigned),
                    }, false),
                },
                "identity_ids": {
                    Type:     schema.TypeSet,
                    Required: true,
                    Elem: &schema.Schema{
                        Type:         schema.TypeString,
                        ValidateFunc: commonids.ValidateUserAssignedIdentityID,
                    },
                },
            },
        },
    }
}
```

**Key Properties for `identity_ids` field:**
- **Type:** TypeSet (set of strings)
- **Required:** true (within identity block)
- **Optional:** false
- **ForceNew:** Not specified (defaults to false)
- **Computed:** Not specified (defaults to false)
- **DiffSuppressFunc:** None
- **ValidateFunc:** `commonids.ValidateUserAssignedIdentityID` - validates User Assigned Identity resource ID format

**Validation Details:**
The validation ensures each identity ID is a valid Azure User Assigned Identity resource ID in the format: `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}`

## Azure API Schema

Resource Type: `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

### Query Result

```
ObjectWithOptionalAttrs(map[string]Type{"type":String, "userAssignedIdentities":Map(EmptyObject)}, []string{"type", "userAssignedIdentities"})
```

**Analysis:**
- The identity object has two properties: `type` and `userAssignedIdentities`
- Both are optional in the API schema
- `userAssignedIdentities` is a Map type with empty object values
- Assignment path in Azure API: Root level `identity.userAssignedIdentities`

**AzAPI Transformation:**
AzAPI resource uses `identity_ids` parameter (list of ID strings) and internally transforms it to the Azure API's `userAssignedIdentities` map structure where:
- Keys are the identity IDs
- Values are empty objects (or objects with computed fields like principalId/clientId after creation)

## Hidden Fields

No hidden fields for the `identity_ids` property itself. The Azure API `userAssignedIdentities` map values contain computed fields (`principalId`, `clientId`) but these are read-only and populated by Azure after resource creation.

## Mapping

### Terraform (snake_case) → Azure API (camelCase)

| Terraform Field | azapi_resource Parameter | Azure API Field | Notes |
|----------------|--------------------------|-----------------|-------|
| `identity_ids` | `identity_ids` (list) | `userAssignedIdentities` (map) | AzAPI handles transformation |

**Value Mapping:**
- **Provider schema:** Set of identity ID strings
- **Shadow module:** Convert set to list using `tolist()`
- **AzAPI parameter:** List of identity ID strings
- **Azure API:** Map with IDs as keys and empty/computed objects as values

**Transformation Flow:**
```
Terraform Set → tolist() → AzAPI List → AzAPI Internal Transform → Azure API Map
```

## Special Handling

### Validation Implementation

**Provider Schema Validation:**
```go
ValidateFunc: commonids.ValidateUserAssignedIdentityID,
```

The provider validates that each identity_ids value is a valid User Assigned Identity resource ID. This validation MUST be replicated in variables.tf.

**Shadow Module Implementation:**
```hcl
validation {
  condition = (
    var.orchestrated_virtual_machine_scale_set_identity == null ||
    (length(var.orchestrated_virtual_machine_scale_set_identity.identity_ids) > 0 &&
      alltrue([for id in var.orchestrated_virtual_machine_scale_set_identity.identity_ids : can(regex("^/subscriptions/[^/]+/resourceGroups/[^/]+/providers/Microsoft\\.ManagedIdentity/userAssignedIdentities/[^/]+$", id))]))
  )
  error_message = "All identity_ids must be valid User Assigned Identity resource IDs in the format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}."
}
```

**Justification for EXACT replication:**
- Uses resource ID validation matching the pattern enforced by `commonids.ValidateUserAssignedIdentityID`
- Validates format: `/subscriptions/*/resourceGroups/*/providers/Microsoft.ManagedIdentity/userAssignedIdentities/*`
- Also ensures the set is non-empty when identity block is present (Required field)
- Error occurs at plan time if user provides invalid identity IDs
- Validation placed on parent identity variable (ownership rule)

### Cross-Field Validation

The expand function includes cross-field validation:

```go
if len(identityIds) > 0 && (identityType != TypeSystemAssignedUserAssigned && identityType != TypeUserAssigned) {
    return nil, fmt.Errorf("`identity_ids` can only be specified when `type` is set to %q or %q", ...)
}
```

However, since our schema ONLY allows `type = "UserAssigned"` (validated in Task #58), this cross-field validation is automatically satisfied. We don't need to replicate this specific check because:
1. Task #58 validation ensures `type == "UserAssigned"`
2. `identity_ids` is Required within the identity block
3. Therefore, when `identity_ids` exists, `type` is always "UserAssigned"

### Type Conversion: Set to List

**Provider schema:** `TypeSet` (unordered collection, no duplicates)  
**AzAPI parameter:** Expects a list

**Conversion:**
```hcl
identity_ids = tolist(var.orchestrated_virtual_machine_scale_set_identity.identity_ids)
```

**Why `tolist()` is needed:**
- Terraform set type is unordered
- AzAPI resource identity parameter expects a list type
- `tolist()` converts the set to a list while maintaining element uniqueness
- Order doesn't matter for identity IDs, Azure treats them as a collection

**Safety:**
- Sets automatically ensure no duplicate IDs
- Conversion to list preserves all unique elements
- No data loss or unexpected behavior

### No ForceNew Required

**Schema Analysis:**
- No `ForceNew: true` in provider schema for `identity_ids` field
- No CustomizeDiff logic affecting identity.identity_ids
- Identity updates (adding/removing identity IDs) are supported by Azure API

**Decision:** No entry needed in `replace_triggers_external_values` for identity.identity_ids

### No Sensitive Field

The `identity_ids` field contains identity resource IDs, which are not sensitive information (they're resource references). It goes in `azapi_header` (not `sensitive_body`).

### Placement in azapi_header

The `identity_ids` field is placed within the `identity` object in `azapi_header`, which is correct because:
1. Identity is a root-level property in azapi_resource (one of the 5 allowed fields)
2. AzAPI resource design uses `identity` parameter with `type` and `identity_ids` sub-parameters
3. AzAPI provider handles transformation from list to Azure API's map structure

## Deferred Work Completion

Checked `following.md` - file does not exist, no deferred work to complete for this task.

## Critical Review & Edge Case Analysis

### Null Semantics

**Identity block is null:**
- The entire identity object is omitted from azapi_header
- The conditional `var.orchestrated_virtual_machine_scale_set_identity != null ? {...} : {}` handles this
- No identity_ids are sent when identity block is absent

**Identity_ids field specifically:**
- Schema marks `identity_ids` as Required within the identity block
- If identity block exists, identity_ids field MUST be present (enforced by Terraform)
- Cannot be null or empty when identity block is specified
- Validation ensures at least one identity ID is provided

### Empty Set

**Validation prevents empty set:**
The validation includes:
```hcl
length(var.orchestrated_virtual_machine_scale_set_identity.identity_ids) > 0
```

This ensures that if the identity block is present, the identity_ids set must contain at least one element. Empty sets will fail validation at plan time with a clear error message.

**Rationale:**
The provider schema marks identity_ids as Required, and Azure API requires at least one identity when using UserAssigned type. An empty identity_ids set would be meaningless.

### Boundary Conditions

**Single identity:**
The most common case - one User Assigned Identity. Works correctly:
```hcl
identity_ids = tolist(["<identity-id>"])  # Results in single-element list
```

**Multiple identities:**
Valid scenario - multiple User Assigned Identities. Set ensures uniqueness:
```hcl
identity_ids = tolist(["<id-1>", "<id-2>", "<id-3>"])  # All unique IDs
```

**Duplicate IDs in input:**
Terraform set type automatically prevents duplicates. If user attempts to provide duplicate IDs, Terraform's type system will merge them into a single entry before our code runs.

### Idempotency

**Set → List conversion:**
```hcl
tolist(var.orchestrated_virtual_machine_scale_set_identity.identity_ids)
```

While sets are unordered in Terraform, `tolist()` produces a consistent ordering within a single plan/apply operation. However, the order might change between different Terraform runs if the set contents are rebuilt.

**Why this is safe:**
- Azure treats identity IDs as a collection, not an ordered list
- The Azure API doesn't care about the order of identities
- AzAPI compares the actual identity IDs present, not their order
- Adding/removing identities triggers appropriate updates regardless of order
- No idempotency issues because Azure only cares about the presence/absence of specific IDs

### Safe References

```hcl
var.orchestrated_virtual_machine_scale_set_identity != null ? {
  identity = {
    type         = var.orchestrated_virtual_machine_scale_set_identity.type
    identity_ids = tolist(var.orchestrated_virtual_machine_scale_set_identity.identity_ids)
  }
} : {}
```

**Safety analysis:**
- The null check on the parent block ensures we only access `.identity_ids` when the identity object exists
- Within the conditional branch, `.identity_ids` is safe because:
  - The object schema defines `identity_ids` as a required field
  - Terraform's type system enforces this at validation time
  - If identity block is specified, identity_ids field must be present
- The `tolist()` function safely handles the set-to-list conversion

### Edge Cases

**1. Identity ID format validation:**
The regex validation matches the Azure User Assigned Identity resource ID format:
```
^/subscriptions/[^/]+/resourceGroups/[^/]+/providers/Microsoft\.ManagedIdentity/userAssignedIdentities/[^/]+$
```

This ensures:
- Correct Azure resource ID structure
- Proper resource type (Microsoft.ManagedIdentity/userAssignedIdentities)
- No empty segments
- Case-sensitive matching (Azure resource IDs are case-insensitive, but we maintain user's input case)

**2. Set-to-list ordering:**
While set ordering isn't guaranteed across Terraform runs, this doesn't affect correctness because:
- Azure doesn't care about identity order
- AzAPI compares actual IDs, not positions
- Plan shows changes based on ID presence, not order

**3. Identity updates:**
Users can:
- Add new identities: Azure API supports this via update
- Remove identities: Azure API supports this via update
- Replace identities: Combination of add/remove
- No ForceNew required for any identity_ids changes

**4. Cross-region identities:**
User Assigned Identities can be referenced across regions. Our validation doesn't restrict this - it only validates the ID format, allowing any valid identity resource ID.

**5. Identity from different subscriptions:**
Azure supports cross-subscription identity references in some scenarios. Our validation allows this as long as the resource ID format is correct.

## Checklist

- ✅ Field placed in correct location (`azapi_header.identity.identity_ids`)
- ✅ Value converted from set to list with `tolist()`
- ✅ Validation implemented in variables.tf (MANDATORY - resource ID format + non-empty)
- ✅ Validation EXACTLY matches provider schema intent
- ✅ Cross-field validation addressed (type validation from Task #58 ensures compatibility)
- ✅ No ForceNew required (not in schema or CustomizeDiff)
- ✅ Not a sensitive field (goes in azapi_header, not sensitive_body)
- ✅ Create phase verified (single-phase, Create phase)
- ✅ Assignment path verified (identity.identity_ids at root level, AzAPI handles transformation)
- ✅ Provider schema analyzed (Required, Set type, ValidateUserAssignedIdentityID)
- ✅ Azure API schema verified (userAssignedIdentities map, AzAPI transforms internally)
- ✅ Hidden fields checked (none for this field, computed fields in API are read-only)
- ✅ Mapping documented (set → tolist() → AzAPI list → Azure API map)
- ✅ Deferred work checked (none to complete)
- ✅ Critical review completed with edge case analysis
- ✅ Self-review: Only identity.identity_ids field added, no other fields
- ✅ Parent block skeleton exists (Task #57 completed)
- ✅ Comment placeholder replaced in skeleton
- ✅ Type field implemented (Task #58 completed)

---

**Implementation Status:** Complete - Ready for checker validation

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-09
**Task:** #59 - identity.identity_ids

### Validation Results

✅ **Field Placement:** Correctly placed in `azapi_header.identity.identity_ids` (root-level azapi_resource parameter)
✅ **Type Conversion:** Correct conversion from `set(string)` to `list` using `tolist()`, AzAPI handles transformation to Azure API map
✅ **Validations:** User Assigned Identity resource ID format validation EXACTLY replicated from provider's `commonids.ValidateUserAssignedIdentityID`
✅ **Non-Empty Validation:** Correctly ensures identity_ids is non-empty when identity block present (Required field semantics)
✅ **Validation Placement:** Placed on parent identity variable following ownership rule
✅ **ForceNew Logic:** None required - schema has no ForceNew, no CustomizeDiff affecting this field, updates supported by API
✅ **Sensitive Field:** Not sensitive (identity IDs are resource references), correctly in azapi_header not sensitive_body
✅ **Stable Keys:** identity key appears only once in azapi_header merge, no duplicate parent keys
✅ **Phase Detection:** Correctly verified as Create phase (single-phase pattern), placed in azapi_header not post_creation_updates
✅ **Assignment Path:** Verified identity.identity_ids at root level, AzAPI transforms to Azure API userAssignedIdentities map
✅ **Cross-Field Validation:** Appropriately handled - type validation from Task #58 ensures compatibility, no additional validation needed
✅ **Deferred Work Completion:** No following.md file, no deferred work for this task
✅ **Edge Cases:** Comprehensive analysis of null semantics, empty sets, boundary conditions, idempotency, safe references
✅ **Provider Schema Analysis:** TypeSet, Required within identity block, ValidateUserAssignedIdentityID - all correctly handled
✅ **Azure API Schema:** userAssignedIdentities map structure understood, AzAPI transformation documented
✅ **Implementation Scope:** Only identity.identity_ids field added, no scope creep

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`:

1. **Validation Replication:** The provider uses `commonids.ValidateUserAssignedIdentityID` to validate resource ID format. The shadow module implements the EXACT same validation using a regex pattern that matches the User Assigned Identity resource ID structure: `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}`

2. **Type Handling:** The provider schema uses TypeSet, which the shadow module correctly converts to list using `tolist()`. AzAPI resource handles the transformation from list to Azure API's map structure internally.

3. **Required Field Semantics:** The validation ensures the set is non-empty when the identity block is present, matching the provider's Required field behavior.

4. **Cross-Field Logic:** The expand function's cross-field validation (identity_ids only valid with certain types) is automatically satisfied because Task #58 restricts type to "UserAssigned" only.

5. **No ForceNew:** Correctly identified that identity_ids can be updated without replacement, matching provider schema.

No deviations, simplifications, or "safer alternatives" were found. The implementation uses the prescribed method from executor.md for all aspects.

**Status:** APPROVED ✅

---
