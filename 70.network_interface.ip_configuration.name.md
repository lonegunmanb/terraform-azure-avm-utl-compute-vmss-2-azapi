# Task #70 - network_interface.ip_configuration.name

## Summary

Documented the `name` field for `ip_configuration` within `network_interface`. This field was already implemented in Task #69 (parent block skeleton) as it's a Required root-level field with simple direct mapping. This task provides full verification including schema analysis, phase detection, assignment path verification, and validation implementation.

## Shadow Implementation

```hcl
ipConfigurations = [
  for ip_config in nic.ip_configuration : {
    name = ip_config.name # <-
    properties = {
      # ... other properties
    }
  }
]
```

**Note:** Implementation already exists from Task #69. This task documents and verifies the implementation.

## Create Phase Verification

### Query Create Method

Analyzed the Create method from the provider source code.

### Provider Code Evidence

From `resourceOrchestratedVirtualMachineScaleSetCreate`:

```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	if v, ok := d.GetOk("network_interface"); ok {
		networkInterfaces, err := ExpandOrchestratedVirtualMachineScaleSetNetworkInterface(v.([]interface{}))
		if err != nil {
			return fmt.Errorf("expanding `network_interface`: %w", err)
		}

		networkProfile.NetworkInterfaceConfigurations = networkInterfaces
		virtualMachineProfile.NetworkProfile = networkProfile
	}
	// ...
	props.Properties.VirtualMachineProfile = &virtualMachineProfile
	// ...
	if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
		return fmt.Errorf("creating Orchestrated %s: %w", id, err)
	}
}
```

From `expandOrchestratedVirtualMachineScaleSetIPConfiguration`:

```go
func expandOrchestratedVirtualMachineScaleSetIPConfiguration(raw map[string]interface{}) (*virtualmachinescalesets.VirtualMachineScaleSetIPConfiguration, error) {
	// ... (other field processing)
	
	ipConfiguration := virtualmachinescalesets.VirtualMachineScaleSetIPConfiguration{
		Name: raw["name"].(string),
		Properties: &virtualmachinescalesets.VirtualMachineScaleSetIPConfigurationProperties{
			// ...
		},
	}
	// ...
	return &ipConfiguration, nil
}
```

### Pattern Identification

**Single-phase Create pattern** - The `name` field is extracted from the Terraform configuration and assigned to the `VirtualMachineScaleSetIPConfiguration` struct before the `CreateOrUpdateThenPoll` call.

### Decision

Field belongs in **Create phase** → Placed in `local.body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].properties.ipConfigurations[].name`

## Assignment Path Verification

### Predicted Path

```
body
└── properties
    └── virtualMachineProfile
        └── networkProfile
            └── networkInterfaceConfigurations[]
                └── properties
                    └── ipConfigurations[]
                        └── name
```

### Provider Code Evidence

Tracing the assignment chain:

**Step 1:** IP configuration creation in `expandOrchestratedVirtualMachineScaleSetIPConfiguration`:
```go
ipConfiguration := virtualmachinescalesets.VirtualMachineScaleSetIPConfiguration{
	Name: raw["name"].(string),  // <-- Name assigned at root level of IP configuration
	Properties: &virtualmachinescalesets.VirtualMachineScaleSetIPConfigurationProperties{
		// ...
	},
}
```

**Step 2:** IP configurations array assignment in `ExpandOrchestratedVirtualMachineScaleSetNetworkInterface`:
```go
ipConfigurations := make([]virtualmachinescalesets.VirtualMachineScaleSetIPConfiguration, 0)
ipConfigurationsRaw := raw["ip_configuration"].([]interface{})
for _, configV := range ipConfigurationsRaw {
	configRaw := configV.(map[string]interface{})
	ipConfiguration, err := expandOrchestratedVirtualMachineScaleSetIPConfiguration(configRaw)
	if err != nil {
		return nil, err
	}
	ipConfigurations = append(ipConfigurations, *ipConfiguration)
}

config := virtualmachinescalesets.VirtualMachineScaleSetNetworkConfiguration{
	Name: raw["name"].(string),
	Properties: &virtualmachinescalesets.VirtualMachineScaleSetNetworkConfigurationProperties{
		IPConfigurations: ipConfigurations,  // <-- Assigned to Properties
		// ...
	},
}
```

**Step 3:** Network profile assignment (from Create method):
```go
networkProfile.NetworkInterfaceConfigurations = networkInterfaces
virtualMachineProfile.NetworkProfile = networkProfile
props.Properties.VirtualMachineProfile = &virtualMachineProfile
```

### Verified Path

```
body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].properties.ipConfigurations[].name
```

**CRITICAL NOTE:** The `name` field is at the **root level** of each `ipConfiguration` object, NOT inside the `properties` sub-object. The Azure API schema has:
- `ipConfigurations[].name` (root level)
- `ipConfigurations[].properties` (sub-object with other fields)

### Path Comparison

✅ **MATCH** - The implementation correctly places `name` at the root level of the ipConfiguration object:
```hcl
for ip_config in nic.ip_configuration : {
  name = ip_config.name        # <-- Root level, correct
  properties = { ... }          # <-- Separate properties object
}
```

## Provider Schema

From the schema query response and provider source code:

```go
func orchestratedVirtualMachineScaleSetIPConfigurationSchema() *pluginsdk.Schema {
	return &pluginsdk.Schema{
		Type:     pluginsdk.TypeList,
		Required: true,
		Elem: &pluginsdk.Resource{
			Schema: map[string]*pluginsdk.Schema{
				"name": {
					Type:         pluginsdk.TypeString,
					Required:     true,
					ValidateFunc: validation.StringIsNotEmpty,
				},
				// ... other fields
			},
		},
	}
}
```

**Field Properties:**
- **Type:** String
- **Required:** Yes
- **ForceNew:** No (not marked in schema)
- **Validation:** `StringIsNotEmpty` - ensures the name is not an empty string

## Azure API Schema

Query result for `body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations.properties.ipConfigurations[].name`:

**Type:** String

The Azure API schema shows `name` as a simple string field at the root level of each IP configuration object.

## Mapping

| Terraform Field | Azure API Field | Notes |
|----------------|----------------|-------|
| `network_interface[].ip_configuration[].name` | `networkInterfaceConfigurations[].properties.ipConfigurations[].name` | Direct string mapping |

**Naming Convention:**
- Terraform: `name` (snake_case)
- Azure API: `name` (camelCase - but already lowercase, no change needed)

## Special Handling

### Validation Implementation

The provider schema includes `ValidateFunc: validation.StringIsNotEmpty`. This validation MUST be replicated in `variables.tf`.

**Location:** The field is already defined in `variables.tf` at line 545:
```hcl
variable "orchestrated_virtual_machine_scale_set_network_interface" {
  type = list(object({
    # ...
    ip_configuration = list(object({
      # ...
      name = string  # Line 545
      # ...
    }))
  }))
}
```

**Current State:** The variable definition uses `string` type without explicit validation.

**Action Required:** Add validation to ensure name is not empty.

**Updated Implementation:**

```hcl
variable "orchestrated_virtual_machine_scale_set_network_interface" {
  type = list(object({
    # ...
    ip_configuration = list(object({
      # ...
      name = string
      # ...
    }))
  }))
  default     = null
  description = <<-EOT
  # ... existing description
EOT

  validation {
    condition = (
      var.orchestrated_virtual_machine_scale_set_network_interface == null ||
      alltrue([
        for nic in var.orchestrated_virtual_machine_scale_set_network_interface : alltrue([
          for ip_config in nic.ip_configuration :
          ip_config.name != null && ip_config.name != ""
        ])
      ])
    )
    error_message = "Each IP configuration name must not be empty."
  }
}
```

### ForceNew Analysis

**Schema Check:** The `name` field does NOT have `ForceNew: true` in the provider schema.

**CustomizeDiff Check:** Analyzed the resource function and found NO CustomizeDiff logic specific to `ip_configuration.name`.

**Conclusion:** Changes to the IP configuration name do NOT force replacement. Azure API allows updating IP configuration names in place.

**Action:** NO entry needed in `replace_triggers_external_values` for this field.

### Root-Level vs Properties

**Critical Distinction:** The `name` field is at the root level of the IP configuration object, separate from the `properties` sub-object. This is correctly implemented in the skeleton:

```hcl
for ip_config in nic.ip_configuration : {
  name = ip_config.name          # Root level - correct ✅
  properties = {                  # Separate object for other properties
    # Other fields go here
  }
}
```

This matches the Azure API structure exactly.

## Critical Review & Edge Case Analysis

### Null Semantics

**Field-level null:**
- The variable definition specifies `name = string` (no `optional()` wrapper)
- This means `name` is REQUIRED within each `ip_configuration` object
- If `ip_configuration` is provided, every entry MUST have a `name` value
- ✅ Correct: Matches provider schema `Required: true`

**Block-level null:**
- `ip_configuration` itself is Required when `network_interface` is provided
- If `network_interface` is null, the entire block is omitted (handled by parent)
- ✅ Safe: Implementation only executes when parent block exists

### Boundary Conditions

**Empty string:**
- Provider validation: `StringIsNotEmpty` rejects empty strings
- Our validation: Checks `ip_config.name != null && ip_config.name != ""`
- ✅ Correct: Matches provider behavior exactly

**Special characters:**
- Provider only validates non-empty, doesn't restrict characters
- Azure API may have additional restrictions
- ✅ Acceptable: Let API validation handle character restrictions

**Length limits:**
- Provider schema has no explicit length validation
- Azure API likely has length limits
- ✅ Acceptable: Let API validation handle length restrictions

**Uniqueness:**
- No provider validation for uniqueness across IP configurations
- Azure API may require unique names within a network interface
- ✅ Acceptable: Let API validation handle uniqueness

### Idempotency

**Stable value:**
- Direct assignment: `name = ip_config.name`
- Same input produces same output
- ✅ Correct: No transformations or computations

**Order preservation:**
- IP configurations processed in `for` loop maintaining order
- Names assigned in same order as input
- ✅ Correct: Stable iteration pattern

### Safe References

**Variable access:**
- `ip_config.name` accessed within `for ip_config in nic.ip_configuration` loop
- Variable is guaranteed to exist within loop scope
- Field is Required, so value is guaranteed to be present
- ✅ Safe: No risk of null reference

**No nested access:**
- Direct field access, no chaining
- No conditional logic needed
- ✅ Safe: Simple and robust

### Edge Cases

1. **IP configuration without name:**
   - Type system prevents this: `name = string` (not optional)
   - Variable validation will catch empty strings
   - ✅ Correct: Multiple layers of protection

2. **Multiple IP configurations with same name:**
   - No provider-level validation for uniqueness
   - Azure API will handle this (likely reject duplicates)
   - ✅ Acceptable: Following provider behavior exactly

3. **Very long name:**
   - No provider-level length validation
   - Azure API will enforce its limits
   - ✅ Acceptable: Following provider behavior exactly

4. **Name with special characters:**
   - Provider allows any non-empty string
   - Azure API will validate acceptable characters
   - ✅ Acceptable: Following provider behavior exactly

5. **Name change on existing resource:**
   - Not a ForceNew field
   - Azure API allows in-place updates
   - No replace trigger needed
   - ✅ Correct: Matches provider behavior

## Deferred Work Completion

Checked `following.md` - file does not exist yet, so no deferred work exists for this task.

## Checklist

- ✅ Field already implemented in Task #69 skeleton (root level, not in properties)
- ✅ Create phase verified (single-phase pattern, field set before CreateOrUpdateThenPoll)
- ✅ Assignment path verified (root level of ipConfiguration, separate from properties object)
- ✅ Provider schema analyzed (Required, String, StringIsNotEmpty validation)
- ✅ Azure API schema queried (String type confirmed)
- ✅ Validation implemented in variables.tf (StringIsNotEmpty check added)
- ✅ ForceNew analyzed (NOT a ForceNew field, no replace trigger needed)
- ✅ Mapping documented (direct string mapping, no transformation)
- ✅ Null semantics analyzed (Required field, cannot be null or empty)
- ✅ Edge cases covered (empty string, special chars, length, uniqueness, updates)
- ✅ Idempotency verified (direct assignment, stable iteration)
- ✅ Safe references verified (within loop scope, Required field)
- ✅ No hidden fields found (simple string assignment)
- ✅ No deferred work exists
- ✅ Root-level placement confirmed (NOT inside properties object)
- ✅ Proof document created with all required sections
- ✅ Self-review: Only documented existing implementation, added required validation

---

**Status:** Ready for checker validation

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-09
**Task:** #70 - network_interface.ip_configuration.name

### Validation Results

✅ **Field Implementation:** Correctly placed at root level of ipConfiguration object (line 169), NOT inside properties object - matches Azure API structure exactly
✅ **ForceNew Logic:** No ForceNew field - correctly NO entry in replace_triggers_external_values
✅ **Stable Keys:** N/A - simple direct assignment in for loop
✅ **Phase Detection:** Field correctly placed in local.body (Create phase)
✅ **Type Conversion:** Direct string-to-string mapping, no conversion needed
✅ **Null Handling:** Required field (no optional wrapper), validation ensures non-null and non-empty
✅ **Validations:** Provider validation (StringIsNotEmpty) correctly implemented in variables.tf lines 662-673 with nested alltrue() pattern
✅ **Sensitive Field Handling:** Not sensitive - correctly in body (not sensitive_body)
✅ **Deferred Work Completion:** No deferred work exists (following.md does not exist)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed (empty string, null, special chars, length, uniqueness, updates)
✅ **Assignment Path:** Correctly verified - root level of ipConfiguration, separate from properties sub-object
✅ **Proof Document:** All required sections present with Go code evidence and detailed analysis

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The field is correctly placed at the root level of the ipConfiguration object (not inside the properties sub-object), matching the Azure API structure. Validation is properly implemented using nested `alltrue()` for the nested block structure. No deviations, simplifications, or alternative approaches were found.

**Status:** APPROVED ✅

---
