# Task #97: os_profile.custom_data - COMPLETED

## Summary

Implemented the `custom_data` field from `azurerm_orchestrated_virtual_machine_scale_set` os_profile block. This is a sensitive, optional, base64-encoded string field that maps to `properties.virtualMachineProfile.osProfile.customData` in the Azure API. As a nested block sensitive field, it requires independent ephemeral variables and is placed in `sensitive_body` with version tracking.

## Shadow Implementation

```hcl
# variables.tf
variable "orchestrated_virtual_machine_scale_set_os_profile" {
  type = object({
    custom_data = optional(string) # TODO: delete later - migrated to independent ephemeral variable (Task #97) # <-
    # ... other fields
  })
}

# migrate_variables.tf
variable "migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data" { # <-
  type        = string # <-
  nullable    = true # <-
  ephemeral   = true # <-
  description = "(Optional) Specifies a base-64 encoded string of custom data. The base-64 encoded string is decoded to a binary array that is saved as a file on the Virtual Machine. The maximum length of the binary array is 65535 bytes." # <-

  validation { # <-
    condition     = var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data == null || can(base64decode(var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data)) # <-
    error_message = "The custom_data must be a valid base64 encoded string." # <-
  } # <-
} # <-

variable "migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data_version" { # <-
  type        = number # <-
  default     = null # <-
  description = "(Optional) Version tracker for custom_data. Must be set when custom_data is provided." # <-

  validation { # <-
    condition     = var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data == null || var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data_version != null # <-
    error_message = "When custom_data is set, custom_data_version must also be set." # <-
  } # <-
} # <-

# migrate_main.tf
locals {
  sensitive_body = { # <-
    properties = var.orchestrated_virtual_machine_scale_set_sku_name != null && var.orchestrated_virtual_machine_scale_set_os_profile != null ? { # <-
      virtualMachineProfile = { # <-
        osProfile = merge( # <-
          var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data != null ? { # <-
            customData = var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data # <-
          } : {} # <-
        ) # <-
      } # <-
    } : {} # <-
  } # <-

  sensitive_body_version = { # <-
    "properties.virtualMachineProfile.osProfile.customData" = try(tostring(var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data_version), "null") # <-
  } # <-
}
```

## Create Phase Verification

**Query Method:** `query_terraform_block_implementation_source_code` with `entrypoint_name=create`

**Pattern:** Single-phase creation

**Evidence from Create method:**
```go
osProfileRaw := d.Get("os_profile").([]interface{})

if len(osProfileRaw) > 0 && osProfileRaw[0] != nil {
    osProfile := osProfileRaw[0].(map[string]interface{})
    winConfigRaw := osProfile["windows_configuration"].([]interface{})
    linConfigRaw := osProfile["linux_configuration"].([]interface{})
    customData := ""

    // Pass custom data if it is defined in the config file
    if v := osProfile["custom_data"]; v != nil {
        customData = v.(string)
    }

    if len(winConfigRaw) > 0 && winConfigRaw[0] != nil {
        // ...
        vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(winConfig, customData)
    }

    if len(linConfigRaw) > 0 && linConfigRaw[0] != nil {
        // ...
        vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration(linConfig, customData)
    }

    virtualMachineProfile.OsProfile = vmssOsProfile
}

// ...
props.Properties.VirtualMachineProfile = &virtualMachineProfile

if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Classification:** Create phase - The `custom_data` value is extracted from `os_profile` block, passed to the expand functions, and included in `virtualMachineProfile.OsProfile` before the `CreateOrUpdateThenPoll` call. This is single-phase creation (no separate update call after creation).

**Decision:** Implement in `locals.sensitive_body` (not in `post_creation_updates`).

## Assignment Path Verification

**Predicted Path:** `properties.virtualMachineProfile.osProfile.customData`

**Evidence from expand functions:**

**For Windows Configuration:**
```go
func expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(input map[string]interface{}, customData string) *virtualmachinescalesets.VirtualMachineScaleSetOSProfile {
    osProfile := virtualmachinescalesets.VirtualMachineScaleSetOSProfile{}
    winConfig := virtualmachinescalesets.WindowsConfiguration{}
    // ...

    if len(input) > 0 {
        osProfile.CustomData = pointer.To(customData)  // ← Assigned here
        // ...
    }

    osProfile.WindowsConfiguration = &winConfig

    return &osProfile
}
```

**For Linux Configuration:**
```go
func expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration(input map[string]interface{}, customData string) *virtualmachinescalesets.VirtualMachineScaleSetOSProfile {
    osProfile := virtualmachinescalesets.VirtualMachineScaleSetOSProfile{}
    linConfig := virtualmachinescalesets.LinuxConfiguration{}
    // ...

    if len(input) > 0 {
        osProfile.CustomData = pointer.To(customData)  // ← Assigned here
        // ...
    }

    osProfile.LinuxConfiguration = &linConfig

    return &osProfile
}
```

**Traced assignments:**
1. `osProfile.CustomData = pointer.To(customData)` - Set on osProfile struct
2. `virtualMachineProfile.OsProfile = vmssOsProfile` - Assigned to virtualMachineProfile
3. `props.Properties.VirtualMachineProfile = &virtualMachineProfile` - Nested under Properties

**Verified Path:** `properties.virtualMachineProfile.osProfile.customData`

**Path Comparison:** ✅ MATCH - Predicted path matches traced path exactly.

## Provider Schema

**Query:** `query_terraform_block_implementation_source_code` with `entrypoint_name=schema`

**Schema Definition:**
```go
func OrchestratedVirtualMachineScaleSetOSProfileSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        MaxItems: 1,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "custom_data": {
                    Type:         pluginsdk.TypeString,
                    Optional:     true,
                    Sensitive:    true,
                    ValidateFunc: validation.StringIsBase64,
                },
                // ...
            },
        },
    }
}
```

**Key Properties:**
- **Type:** `pluginsdk.TypeString`
- **Optional:** `true`
- **Sensitive:** `true` ← Critical for implementation
- **ValidateFunc:** `validation.StringIsBase64` ← Must replicate in variables.tf

## Azure API Schema

**Query:** `query_azapi_resource_schema` and `query_azapi_resource_document`

**Resource Type:** `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

**Path:** `body.properties.virtualMachineProfile.osProfile.customData`

**Type:** `String`

**Description:** "Specifies a base-64 encoded string of custom data. The base-64 encoded string is decoded to a binary array that is saved as a file on the Virtual Machine. The maximum length of the binary array is 65535 bytes. For using cloud-init for your VM, see [Using cloud-init to customize a Linux VM during creation](https://docs.microsoft.com/azure/virtual-machines/linux/using-cloud-init)"

## Hidden Fields

No hidden fields identified for `custom_data`.

## Mapping

| Terraform Field | Azure API Field | Transformation |
|-----------------|-----------------|----------------|
| `os_profile.custom_data` | `properties.virtualMachineProfile.osProfile.customData` | Direct assignment (base64 string) |

## Special Handling

### 1. Sensitive Field - Independent Ephemeral Variable

**Reason:** `custom_data` is marked as `Sensitive: true` in the schema and is inside a nested block (`os_profile`). According to executor.md rules, nested block sensitive fields require independent ephemeral variables.

**Implementation:**
- Created `migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data` with `ephemeral = true`
- Created version variable `migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data_version`
- Added TODO comment to original field in `variables.tf` on the same line
- Placed in `sensitive_body` (NOT in `body`)
- Added to `sensitive_body_version` with full JSON path

### 2. Validation - Base64 Encoding

**Provider Validation:**
```go
ValidateFunc: validation.StringIsBase64,
```

**Replicated in migrate_variables.tf:**
```hcl
validation {
  condition     = var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data == null || can(base64decode(var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data))
  error_message = "The custom_data must be a valid base64 encoded string."
}
```

**Reason:** Must validate at plan time to provide fast feedback (not defer to Azure API).

### 3. Cross-Variable Validation - Version Tracking

**Implementation:**
```hcl
validation {
  condition     = var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data == null || var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data_version != null
  error_message = "When custom_data is set, custom_data_version must also be set."
}
```

**Reason:** Ephemeral fields require version tracking for change detection.

### 4. Update Behavior

**Evidence from Update method:**
```go
if d.HasChange("os_profile.0.custom_data") {
    updateInstances = true

    // customData can only be sent if it's a base64 encoded string,
    // so it's not possible to remove this without tainting the resource
    vmssOsProfile.CustomData = pointer.To(osProfile["custom_data"].(string))
}
```

**Key Points:**
- Changes to `custom_data` trigger `updateInstances = true`
- Field can be updated (not ForceNew)
- Comment indicates: "customData can only be sent if it's a base64 encoded string, so it's not possible to remove this without tainting the resource"
- This means once set, it cannot be unset via update - only via recreation

**Implementation:** No special ForceNew handling needed - the Azure API allows updates, and version tracking handles change detection.

### 5. Conditional Inclusion

**Logic:** `custom_data` is only included when:
1. `var.orchestrated_virtual_machine_scale_set_sku_name != null` (virtualMachineProfile exists)
2. `var.orchestrated_virtual_machine_scale_set_os_profile != null` (osProfile block exists)
3. `var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data != null` (field is provided)

**Implementation in sensitive_body:**
```hcl
properties = var.orchestrated_virtual_machine_scale_set_sku_name != null && var.orchestrated_virtual_machine_scale_set_os_profile != null ? {
  virtualMachineProfile = {
    osProfile = merge(
      var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data != null ? {
        customData = var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data
      } : {}
    )
  }
} : {}
```

## Critical Review & Edge Case Analysis

### 1. Null Semantics

**Question:** What does `null` mean for `custom_data`?

**Answer:** When `custom_data` is `null`, the field is omitted from the API request entirely. This is the default state for VMs without custom initialization scripts.

**Implementation:** Correctly handles null by checking before inclusion:
```hcl
var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data != null ? {
  customData = var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data
} : {}
```

### 2. Empty String Edge Case

**Question:** What happens if an empty string `""` is provided?

**Answer:** Empty string would fail base64 validation. The validation `can(base64decode(...))` will catch this at plan time.

**Test:**
```hcl
# This will FAIL validation:
custom_data = ""
```

### 3. Update Limitations

**Question:** Can `custom_data` be removed after being set?

**Answer from Provider Code:**
```go
// customData can only be sent if it's a base64 encoded string,
// so it's not possible to remove this without tainting the resource
```

**Implication:** Once `custom_data` is set, it cannot be cleared via update. The user must:
- Keep the value
- Change to a different base64 value
- Recreate the resource (ForceNew)

**Our Implementation:** Matches this behavior - we don't add special ForceNew logic, allowing the Azure API to handle the limitation naturally.

### 4. Maximum Length

**Azure Documentation:** "The maximum length of the binary array is 65535 bytes"

**Question:** Should we validate the decoded length?

**Answer:** No - the provider doesn't validate length, only validates that it's valid base64. The Azure API will return an error if the decoded content exceeds the limit. This is acceptable behavior (matches provider).

### 5. Idempotency

**Question:** Is the implementation idempotent?

**Answer:** Yes - the same `custom_data` value provided multiple times results in the same API call. Version tracking ensures changes are detected properly.

### 6. Safe References

**Question:** Are nested accesses safe?

**Answer:** Yes - all references check for null before accessing:
```hcl
var.orchestrated_virtual_machine_scale_set_sku_name != null && var.orchestrated_virtual_machine_scale_set_os_profile != null ? { ... } : {}
```

### 7. Sensitive Body Version Stability

**Question:** Is the `sensitive_body_version` key stable?

**Answer:** Yes - the key `"properties.virtualMachineProfile.osProfile.customData"` is always present in the map, with value either being the version number (as string) or `"null"` (string). This ensures the key doesn't disappear/appear across applies, preventing unexpected replacements.

```hcl
sensitive_body_version = {
  "properties.virtualMachineProfile.osProfile.customData" = try(tostring(var.migrate_orchestrated_virtual_machine_scale_set_os_profile_custom_data_version), "null")
}
```

### 8. Windows vs Linux Behavior

**Question:** Does `custom_data` behave differently for Windows vs Linux?

**Answer:** No - both expand functions handle `customData` identically at the osProfile level:
```go
// Both functions do this:
osProfile.CustomData = pointer.To(customData)
```

The only difference is which configuration block (WindowsConfiguration vs LinuxConfiguration) is populated alongside it.

## Checklist

- ✅ Property in correct local (`sensitive_body`, not `body`)
- ✅ Validation IMPLEMENTED in variables.tf (base64 encoding check)
- ✅ TODO comment added to original field in variables.tf (same line)
- ✅ Independent ephemeral variable created for nested sensitive field
- ✅ Version variable created with cross-variable validation
- ✅ `sensitive_body_version` key is stable (always present)
- ✅ Hidden fields checked (none found)
- ✅ Critical review completed (null, edge cases, idempotent, safe refs)
- ✅ Edge Case Analysis completed
- ✅ Proof created
- ✅ Implementation exactly matches provider behavior

## Files Modified

1. `variables.tf` - Updated TODO comment for `custom_data` field
2. `migrate_variables.tf` - Added independent ephemeral variables with validations
3. `migrate_main.tf` - Added `custom_data` to `sensitive_body` and `sensitive_body_version`

## Exact Provider Behavior Match

✅ **CONFIRMED** - This implementation exactly replicates the provider behavior:
- Sensitive field handling matches provider's `Sensitive: true`
- Base64 validation replicates `validation.StringIsBase64`
- Version tracking enables change detection for ephemeral values
- Update behavior matches (updateInstances triggered, no ForceNew)
- Conditional inclusion matches provider's expand logic
- Path matches exact API structure

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-05
**Task:** #97 - os_profile.custom_data

### Validation Results

✅ **Sensitive Field Handling:** Correctly implemented as independent ephemeral variable with version tracking
✅ **Validation Logic:** Base64 validation exactly replicates provider's `validation.StringIsBase64`
✅ **Stable Keys:** `sensitive_body_version` key is always present using `try(tostring(...), "null")` pattern
✅ **Phase Detection:** Field correctly placed in `sensitive_body` (Create phase, not post-creation)
✅ **Type Conversion:** Correct direct assignment of base64 string
✅ **Null Handling:** Correctly omits field when null, handles conditional inclusion properly
✅ **Path Verification:** Exact path match: `properties.virtualMachineProfile.osProfile.customData`
✅ **Merge Structure:** No duplicate parent keys - `osProfile` appears only once in each merge context
✅ **Cross-Variable Validation:** Version variable validation correctly enforces paired setting
✅ **Edge Cases:** All edge cases properly analyzed (null semantics, empty string, update limitations, idempotency)

### Detailed Compliance Checks

**Sensitive Field Implementation (executor.md lines 236-283):**
- ✅ Independent ephemeral variable in `migrate_variables.tf` (not reusing existing)
- ✅ Version variable with `default = null` (NOT `default = 1`)
- ✅ Version validation enforces both field and version set together
- ✅ TODO comment added to original field in `variables.tf` on same line
- ✅ Field value in `sensitive_body` (NOT in `body`)
- ✅ Field path in `sensitive_body_version` with correct format

**Shared Path Merge Check (checker.md lines 104-155):**
- ✅ No duplicate `osProfile` keys in `local.body` merge
- ✅ No duplicate `osProfile` keys in `local.sensitive_body` merge
- ✅ Proper nested merge structure for child fields

**Validation Implementation (executor.md lines 71-108):**
- ✅ Base64 validation implemented in `migrate_variables.tf` (not deferred to Azure API)
- ✅ Validation logic exactly matches provider's `validation.StringIsBase64`
- ✅ Uses Terraform's `can(base64decode(...))` for plan-time validation

**Conditional Logic:**
- ✅ Correctly checks `sku_name != null` and `os_profile != null` before including
- ✅ Uses merge pattern with empty object fallback
- ✅ Conditional at field level (customData only included when non-null)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found. All mandatory rules followed:
- Sensitive field handling per nested block rules
- Exact validation replication (no deferral to Azure API)
- Stable keys in sensitive_body_version
- Correct phase detection and local placement
- Proper merge structure without duplicate keys

**Status:** APPROVED ✅

---
