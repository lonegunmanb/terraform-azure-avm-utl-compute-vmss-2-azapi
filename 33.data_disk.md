# Task #33 - data_disk Block Structure Skeleton

## Summary

Created the block structure skeleton for `data_disk` nested block within `virtualMachineProfile.storageProfile.dataDisks`. This is a Type 3 task that only creates the framework with comment placeholders for child tasks #34-42.

## Shadow Implementation

```hcl
locals {
  body = {
    properties = merge(
      # ... existing properties ...
      var.orchestrated_virtual_machine_scale_set_sku_name != null ? {
        virtualMachineProfile = merge(
          # ... existing virtualMachineProfile fields ...
          var.orchestrated_virtual_machine_scale_set_data_disk != null ? {
            storageProfile = merge(
              # ... existing storageProfile fields (osDisk, etc.) ...
              {
                dataDisks = [
                  for data_disk in var.orchestrated_virtual_machine_scale_set_data_disk : {
                    # caching = ... # Task #34
                    # createOption = ... # Task #36
                    # diskSizeGB = ... # Task #38
                    # lun = ... # Task #39
                    # writeAcceleratorEnabled = ... # Task #42
                    # managedDisk = { # Task #35, #37
                    #   storageAccountType = ... # Task #35
                    #   diskEncryptionSet = { # Task #37
                    #     id = ... # Task #37
                    #   }
                    # }
                    # diskIOPSReadWrite = ... # Task #40
                    # diskMBpsReadWrite = ... # Task #41
                  }
                ]
              }
            )
          } : {}
        )
      } : {}
    )
  }
}
```

## Create Phase Verification

**Pattern:** Single-phase creation

**Evidence from Create method:**
```go
if v, ok := d.GetOk("data_disk"); ok {
    ultraSSDEnabled := d.Get("additional_capabilities.0.ultra_ssd_enabled").(bool)
    dataDisks, err := ExpandOrchestratedVirtualMachineScaleSetDataDisk(v.([]interface{}), ultraSSDEnabled)
    if err != nil {
        return fmt.Errorf("expanding `data_disk`: %w", err)
    }
    virtualMachineProfile.StorageProfile.DataDisks = dataDisks
}
```

**Classification:** Create phase - The data_disk block is expanded and assigned before the `CreateOrUpdateThenPoll` call.

**Decision:** Implement in `local.body`

## Assignment Path Verification

**Predicted Path:** `properties.virtualMachineProfile.storageProfile.dataDisks`

**Tracing Assignment:**
1. `dataDisks := ExpandOrchestratedVirtualMachineScaleSetDataDisk(...)` → Returns `*[]virtualmachinescalesets.VirtualMachineScaleSetDataDisk`
2. `virtualMachineProfile.StorageProfile.DataDisks = dataDisks` → Assigns to `StorageProfile.DataDisks`
3. `props.Properties.VirtualMachineProfile = &virtualMachineProfile` → Wraps in VirtualMachineProfile
4. Final API payload: `properties.virtualMachineProfile.storageProfile.dataDisks`

**Verified Path:** `properties.virtualMachineProfile.storageProfile.dataDisks` ✅

**Path Comparison:** Predicted path matches verified path.

## Provider Schema

```go
func OrchestratedVirtualMachineScaleSetDataDiskSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "caching": {
                    Type:     pluginsdk.TypeString,
                    Required: true,
                    ValidateFunc: validation.StringInSlice([]string{
                        string(virtualmachinescalesets.CachingTypesNone),
                        string(virtualmachinescalesets.CachingTypesReadOnly),
                        string(virtualmachinescalesets.CachingTypesReadWrite),
                    }, false),
                },
                "create_option": {
                    Type:     pluginsdk.TypeString,
                    Optional: true,
                    ValidateFunc: validation.StringInSlice([]string{
                        string(virtualmachinescalesets.DiskCreateOptionTypesEmpty),
                        string(virtualmachinescalesets.DiskCreateOptionTypesFromImage),
                    }, false),
                    Default: string(virtualmachinescalesets.DiskCreateOptionTypesEmpty),
                },
                "disk_encryption_set_id": {
                    Type:     pluginsdk.TypeString,
                    Optional: true,
                    ForceNew: true,
                    ValidateFunc: validate.DiskEncryptionSetID,
                },
                "disk_size_gb": {
                    Type:         pluginsdk.TypeInt,
                    Optional:     true,
                    Computed:     true,
                    ValidateFunc: validation.IntBetween(1, 32767),
                },
                "lun": {
                    Type:         pluginsdk.TypeInt,
                    Optional:     true,
                    Computed:     true,
                    ValidateFunc: validation.IntBetween(0, 2000),
                },
                "storage_account_type": {
                    Type:     pluginsdk.TypeString,
                    Required: true,
                    ValidateFunc: validation.StringInSlice([]string{
                        string(virtualmachinescalesets.StorageAccountTypesPremiumLRS),
                        string(virtualmachinescalesets.StorageAccountTypesPremiumVTwoLRS),
                        string(virtualmachinescalesets.StorageAccountTypesPremiumZRS),
                        string(virtualmachinescalesets.StorageAccountTypesStandardLRS),
                        string(virtualmachinescalesets.StorageAccountTypesStandardSSDLRS),
                        string(virtualmachinescalesets.StorageAccountTypesStandardSSDZRS),
                        string(virtualmachinescalesets.StorageAccountTypesUltraSSDLRS),
                    }, false),
                },
                "write_accelerator_enabled": {
                    Type:     pluginsdk.TypeBool,
                    Optional: true,
                    Default:  false,
                },
                "ultra_ssd_disk_iops_read_write": {
                    Type:         pluginsdk.TypeInt,
                    Optional:     true,
                    ValidateFunc: validation.IntAtLeast(1),
                    Computed:     true,
                },
                "ultra_ssd_disk_mbps_read_write": {
                    Type:         pluginsdk.TypeInt,
                    Optional:     true,
                    ValidateFunc: validation.IntAtLeast(1),
                    Computed:     true,
                },
            },
        },
    }
}
```

## Azure API Schema

**Resource Type:** `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

**Property Path:** `body.properties.virtualMachineProfile.storageProfile.dataDisks`

**Type:** `List(ObjectWithOptionalAttrs(...))`

**Fields:**
- `caching` - String (optional)
- `createOption` - String (optional)
- `deleteOption` - String (optional, not exposed in provider)
- `diskIOPSReadWrite` - Number (optional)
- `diskMBpsReadWrite` - Number (optional)
- `diskSizeGB` - Number (optional)
- `lun` - Number (optional)
- `managedDisk` - Object (optional)
  - `diskEncryptionSet.id` - String (optional)
  - `securityProfile` - Object (optional, not exposed in provider)
  - `storageAccountType` - String (optional)
- `name` - String (optional, not exposed in provider)
- `writeAcceleratorEnabled` - Bool (optional)

## Hidden Fields Check

**Expand Function Analysis:**

```go
func ExpandOrchestratedVirtualMachineScaleSetDataDisk(input []interface{}, ultraSSDEnabled bool) (*[]virtualmachinescalesets.VirtualMachineScaleSetDataDisk, error) {
    disks := make([]virtualmachinescalesets.VirtualMachineScaleSetDataDisk, 0)

    for _, v := range input {
        raw := v.(map[string]interface{})

        storageAccountType := virtualmachinescalesets.StorageAccountTypes(raw["storage_account_type"].(string))
        disk := virtualmachinescalesets.VirtualMachineScaleSetDataDisk{
            Caching: pointer.To(virtualmachinescalesets.CachingTypes(raw["caching"].(string))),
            ManagedDisk: &virtualmachinescalesets.VirtualMachineScaleSetManagedDiskParameters{
                StorageAccountType: pointer.To(storageAccountType),
            },
            WriteAcceleratorEnabled: pointer.To(raw["write_accelerator_enabled"].(bool)),
            CreateOption:            virtualmachinescalesets.DiskCreateOptionTypes(raw["create_option"].(string)),
        }

        if dataDiskSize := raw["disk_size_gb"].(int); dataDiskSize > 0 {
            disk.DiskSizeGB = pointer.To(int64(dataDiskSize))
        }

        if lun := raw["lun"].(int); lun >= 0 {
            disk.Lun = int64(lun)
        }

        if id := raw["disk_encryption_set_id"].(string); id != "" {
            disk.ManagedDisk.DiskEncryptionSet = &virtualmachinescalesets.SubResource{
                Id: pointer.To(id),
            }
        }

        var iops int
        if diskIops, ok := raw["ultra_ssd_disk_iops_read_write"]; ok && diskIops.(int) > 0 {
            iops = diskIops.(int)
        }

        if iops > 0 && !ultraSSDEnabled && storageAccountType != virtualmachinescalesets.StorageAccountTypesPremiumVTwoLRS {
            return nil, fmt.Errorf("`ultra_ssd_disk_iops_read_write` can only be set when `storage_account_type` is set to `PremiumV2_LRS` or `UltraSSD_LRS`")
        }

        if iops > 0 {
            disk.DiskIOPSReadWrite = pointer.To(int64(iops))
        }

        var mbps int
        if diskMbps, ok := raw["ultra_ssd_disk_mbps_read_write"]; ok && diskMbps.(int) > 0 {
            mbps = diskMbps.(int)
        }

        if mbps > 0 && !ultraSSDEnabled && storageAccountType != virtualmachinescalesets.StorageAccountTypesPremiumVTwoLRS {
            return nil, fmt.Errorf("`ultra_ssd_disk_mbps_read_write` can only be set when `storage_account_type` is set to `PremiumV2_LRS` or `UltraSSD_LRS`")
        }

        if mbps > 0 {
            disk.DiskMBpsReadWrite = pointer.To(int64(mbps))
        }

        disks = append(disks, disk)
    }

    return &disks, nil
}
```

**Hidden Fields:** None - All fields assigned are directly from schema input. No hardcoded values or additional fields added by the expand function.

## Mapping

| AzureRM (Terraform) | Azure API | Notes |
|---------------------|-----------|-------|
| `data_disk` | `dataDisks` | Block → List |
| `caching` | `caching` | Direct |
| `storage_account_type` | `managedDisk.storageAccountType` | Nested |
| `create_option` | `createOption` | Direct |
| `disk_encryption_set_id` | `managedDisk.diskEncryptionSet.id` | Nested |
| `disk_size_gb` | `diskSizeGB` | Direct |
| `lun` | `lun` | Direct |
| `ultra_ssd_disk_iops_read_write` | `diskIOPSReadWrite` | Direct |
| `ultra_ssd_disk_mbps_read_write` | `diskMBpsReadWrite` | Direct |
| `write_accelerator_enabled` | `writeAcceleratorEnabled` | Direct |

## Special Handling

### Block Dependency
- **Condition:** Only created when `var.orchestrated_virtual_machine_scale_set_sku_name != null`
- **Reason:** `data_disk` is part of `virtualMachineProfile.storageProfile`, which only exists when sku_name is set

### List Iteration
- **Pattern:** Uses `for` expression to iterate over list items
- **Structure:** Each item in the list becomes one object in the `dataDisks` array

### Parent Block Integration
- **Note:** The `storageProfile` block may already exist for `osDisk` (Task #87-95)
- **Integration:** Will need to use `merge()` at the `storageProfile` level to combine with any existing storage profile fields
- **Placeholder:** Comment notes indicate this integration point

## Critical Review & Edge Case Analysis

### Null Semantics
- **Variable null:** When `var.orchestrated_virtual_machine_scale_set_data_disk == null`, the entire conditional block is skipped
- **Empty list:** When `var.orchestrated_virtual_machine_scale_set_data_disk == []`, the `dataDisks` array will be empty `[]`
- **Meaning:** Null = no data disks defined, Empty list = explicitly no data disks

### Boundary Conditions
- **Empty list handling:** Valid - creates empty `dataDisks` array
- **Single item:** Valid - creates array with one disk
- **Multiple items:** Valid - creates array with multiple disks

### Idempotency
- **List order:** Terraform maintains list order from configuration
- **No automatic sorting:** Order depends on configuration order
- **Safe:** List iteration with `for` preserves order consistently

### Safe References
- **Variable check:** `var.orchestrated_virtual_machine_scale_set_data_disk != null` prevents null reference
- **Parent dependency:** Wrapped in `var.orchestrated_virtual_machine_scale_set_sku_name != null` check
- **No nested access:** Only checks top-level variable existence

### Edge Cases
1. **Null vs Empty:** Properly distinguishes between null (not configured) and empty list (no disks wanted)
2. **Single placement:** storageProfile may need merge with osDisk from Task #87-95
3. **Parent block:** Correctly nested under virtualMachineProfile condition

## Child Tasks Ready for Delegation

The following child tasks are now ready for implementation:

- **Task #34:** `data_disk.caching` (Required argument)
- **Task #35:** `data_disk.storage_account_type` (Required argument)
- **Task #36:** `data_disk.create_option` (Optional argument with default)
- **Task #37:** `data_disk.disk_encryption_set_id` (Optional argument, ForceNew)
- **Task #38:** `data_disk.disk_size_gb` (Optional argument)
- **Task #39:** `data_disk.lun` (Optional argument)
- **Task #40:** `data_disk.ultra_ssd_disk_iops_read_write` (Optional argument)
- **Task #41:** `data_disk.ultra_ssd_disk_mbps_read_write` (Optional argument)
- **Task #42:** `data_disk.write_accelerator_enabled` (Optional argument with default)

All child tasks can be delegated immediately as the parent skeleton is now in place.

## Completion Checklist

- ✅ Block skeleton created with conditional structure
- ✅ Comment placeholders for all child fields (Tasks #34-42)
- ✅ Parent dependency check included (`sku_name != null`)
- ✅ List iteration pattern established (`for data_disk in ...`)
- ✅ Hidden fields checked (none found)
- ✅ Critical review completed
- ✅ Edge case analysis documented
- ✅ Proof document created
- ✅ Child tasks identified for delegation
- ✅ Self-review: Only added structure skeleton, no individual field implementations

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2025-12-08
**Task:** #33 - data_disk

### Issues Identified

#### Issue 1: Incorrect storageProfile Condition

**Problem:**
The `storageProfile` block was conditionally created ONLY when `data_disk != null`, but the provider allows `os_disk` to exist independently without `data_disk`. This creates a functional error where users cannot configure `os_disk` alone.

**Executor's Implementation:**
```hcl
var.orchestrated_virtual_machine_scale_set_data_disk != null ? {
  storageProfile = {
    dataDisks = [...]
    # osDisk = { # Task #87-95
  }
} : {}
```

**Why This Violates executor.md:**
Executor.md Line 18: "✅ **ALWAYS replicate** all provider logic EXACTLY in `locals`"

The provider's behavior allows three scenarios:
1. Only `data_disk` set → creates storageProfile with dataDisks
2. Only `os_disk` set → creates storageProfile with osDisk  
3. Both set → creates storageProfile with both

The original implementation BLOCKED scenario #2, which violates exact replication requirement.

**Provider's Actual Behavior:**
From the provider schema and expand function, `storageProfile` is a parent container that can hold:
- `dataDisks` (from `data_disk` block)
- `osDisk` (from `os_disk` block - Task #87)

Both are optional and independent. The `storageProfile` should exist when EITHER is configured.

**Expected Behavior:**
- When `data_disk` is set but `os_disk` is null → storageProfile with dataDisks only
- When `os_disk` is set but `data_disk` is null → storageProfile with osDisk only
- When both are set → storageProfile with both dataDisks and osDisk
- When neither is set → no storageProfile

**Root Cause:**
The executor created the `storageProfile` condition based only on `data_disk`, not considering that `os_disk` (Task #87-95) also needs the same parent block. This is an oversight in parent block condition design.

### Corrections Made

#### Fix 1: Corrected storageProfile Condition

**Changed Files:**
- `migrate_main.tf`: Changed storageProfile condition and structure

**New Implementation:**
```hcl
var.orchestrated_virtual_machine_scale_set_data_disk != null || var.orchestrated_virtual_machine_scale_set_os_disk != null ? {
  storageProfile = merge(
    var.orchestrated_virtual_machine_scale_set_data_disk != null ? {
      dataDisks = [
        for data_disk in var.orchestrated_virtual_machine_scale_set_data_disk : {
          # Task #34-42 placeholders
        }
      ]
    } : {},
    # osDisk will be added here by Task #87-95
  )
} : {}
```

**Why This is EXACT:**
- The outer condition `data_disk != null || os_disk != null` ensures storageProfile is created when EITHER child block is configured
- Uses `merge()` to combine dataDisks and osDisk at the same level
- `dataDisks` is conditionally included only when `data_disk != null`
- `osDisk` will be conditionally added by Task #87 when `os_disk != null`
- Matches the provider's behavior where both fields are independent and optional

**Verification:**
- Scenario 1: `data_disk = [{...}]`, `os_disk = null` → storageProfile with dataDisks only ✅
- Scenario 2: `data_disk = null`, `os_disk = {...}` → storageProfile with osDisk only ✅
- Scenario 3: `data_disk = [{...}]`, `os_disk = {...}` → storageProfile with both ✅
- Scenario 4: `data_disk = null`, `os_disk = null` → no storageProfile ✅

### Validation Results

✅ **ForceNew Logic:** Not applicable for Type 3 skeleton task
✅ **Stable Keys:** Not applicable for Type 3 skeleton task  
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase)
✅ **Type Conversion:** List structure correctly set up with `for` expression
✅ **Null Handling:** Correctly handles null vs empty list semantics
✅ **Validations:** Not applicable for Type 3 skeleton task (child tasks will implement)
✅ **Edge Cases:** All edge cases properly analyzed
✅ **Shared Path Merge:** No violations - storageProfile appears only once, uses merge for children
✅ **Parent Block Condition:** CORRECTED - Now checks both data_disk and os_disk

### Compliance Statement

After corrections, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`. The storageProfile parent block is correctly created when either data_disk or os_disk is configured, matching the provider's independent field logic.

**Status:** CORRECTED AND APPROVED ✅
