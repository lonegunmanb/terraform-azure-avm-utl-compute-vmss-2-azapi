# Task #150: sku_profile.allocation_strategy

## Summary

Implemented the required argument `allocation_strategy` within the `sku_profile` block from azurerm_orchestrated_virtual_machine_scale_set to azapi_resource. This field specifies the allocation strategy for the virtual machine scale set based on which the VMs will be allocated. The field is ForceNew and maps to `properties.skuProfile.allocationStrategy` in the Azure API.

## Shadow Implementation

```hcl
# variables.tf
variable "orchestrated_virtual_machine_scale_set_sku_profile" {
  type = object({
    allocation_strategy = string  # <-
    vm_sizes            = set(string)
  })
  default     = null
  description = <<-EOT
 - `allocation_strategy` - (Required) Specifies the allocation strategy for the virtual machine scale set based on which the VMs will be allocated. Possible values are `CapacityOptimized`, `LowestPrice` and `Prioritized`.
 - `vm_sizes` - (Required) Specifies the VM sizes for the virtual machine scale set.
EOT

  validation {  # <-
    condition     = var.orchestrated_virtual_machine_scale_set_sku_profile == null || contains(["LowestPrice", "CapacityOptimized", "Prioritized"], var.orchestrated_virtual_machine_scale_set_sku_profile.allocation_strategy)  # <-
    error_message = "The `allocation_strategy` must be one of: `LowestPrice`, `CapacityOptimized`, or `Prioritized`."  # <-
  }  # <-
}

# migrate_main.tf - locals.body
var.orchestrated_virtual_machine_scale_set_sku_profile != null ? {
  skuProfile = {
    allocationStrategy = var.orchestrated_virtual_machine_scale_set_sku_profile.allocation_strategy  # <-
    # vmSizes = ... # Task #151
  }
} : {},

# migrate_main.tf - locals.replace_triggers_external_values
sku_profile_allocation_strategy = { value = var.orchestrated_virtual_machine_scale_set_sku_profile != null ? var.orchestrated_virtual_machine_scale_set_sku_profile.allocation_strategy : "" }  # <-
sku_profile_vm_sizes            = { value = var.orchestrated_virtual_machine_scale_set_sku_profile != null ? jsonencode(var.orchestrated_virtual_machine_scale_set_sku_profile.vm_sizes) : "" }  # <-
```

## Create Phase Verification

Queried `resourceOrchestratedVirtualMachineScaleSetCreate` to identify the phase where `allocation_strategy` is set.

**Pattern:** Single-phase create

**Go Code Evidence:**

```go
if v, ok := d.GetOk("sku_profile"); ok {
    props.Properties.SkuProfile = expandOrchestratedVirtualMachineScaleSetSkuProfile(v.([]interface{}))
}

// Later in the same function
if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Classification:** The `allocation_strategy` is part of `sku_profile` which is set in the **Create phase** (before the CreateOrUpdateThenPoll call) → belongs in `local.body`.

## Assignment Path Verification

**Predicted Path:** `properties.skuProfile.allocationStrategy`

**Go Code Evidence from expandOrchestratedVirtualMachineScaleSetSkuProfile:**

```go
func expandOrchestratedVirtualMachineScaleSetSkuProfile(input []interface{}) *virtualmachinescalesets.SkuProfile {
    if len(input) == 0 || input[0] == nil {
        return nil
    }

    v := input[0].(map[string]interface{})
    vmSizesRaw := v["vm_sizes"].(*pluginsdk.Set).List()
    vmSizes := make([]virtualmachinescalesets.SkuProfileVMSize, 0)
    for _, vmSize := range vmSizesRaw {
        vmSizes = append(vmSizes, virtualmachinescalesets.SkuProfileVMSize{
            Name: pointer.To(vmSize.(string)),
        })
    }

    return &virtualmachinescalesets.SkuProfile{
        AllocationStrategy: pointer.To((virtualmachinescalesets.AllocationStrategy)(v["allocation_strategy"].(string))),
        VMSizes:            pointer.To(vmSizes),
    }
}
```

**Assignment chain:**
1. `expandOrchestratedVirtualMachineScaleSetSkuProfile` returns `*virtualmachinescalesets.SkuProfile`
2. In Create: `props.Properties.SkuProfile = expandOrchestratedVirtualMachineScaleSetSkuProfile(...)`
3. The `SkuProfile` struct has field `AllocationStrategy`
4. This is assigned to `props.Properties.SkuProfile.AllocationStrategy`

**Verified Path:** `properties.skuProfile.allocationStrategy` ✅

**Path Comparison:** Predicted path matches verified path.

## Provider Schema

```go
"sku_profile": {
    Type:     pluginsdk.TypeList,
    Optional: true,
    ForceNew: true,
    MaxItems: 1,
    Elem: &pluginsdk.Resource{
        Schema: map[string]*pluginsdk.Schema{
            "allocation_strategy": {
                Type:     pluginsdk.TypeString,
                Required: true,
                ValidateFunc: validation.StringInSlice(
                    virtualmachinescalesets.PossibleValuesForAllocationStrategy(),
                    false,
                ),
            },
            // ...
        },
    },
},
```

**Key Properties:**
- **Type:** String
- **Required:** Yes (within sku_profile block)
- **ForceNew:** Yes (inherited from parent block)
- **Validation:** StringInSlice with PossibleValuesForAllocationStrategy()

## Azure API Schema

**Field Path:** `properties.skuProfile.allocationStrategy`

**Azure API Documentation:**
```
"skuProfile": {
    "allocationStrategy": "Specifies the allocation strategy for the virtual machine scale set based on which the VMs will be allocated. (Possible values: LowestPrice,CapacityOptimized,Prioritized)",
    "vmSizes": "Specifies the VM sizes for the virtual machine scale set."
}
```

**Key Properties:**
- **Type:** String (enum)
- **Required:** Yes (when sku_profile is specified)
- **Possible Values:** `LowestPrice`, `CapacityOptimized`, `Prioritized`

## Hidden Fields

None. The expand function directly maps the Terraform field to the Azure API field with no hidden logic or additional fields.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|------------------------|----------------------|-------|
| `allocation_strategy` | `allocationStrategy` | Direct string mapping |

## Special Handling

### 1. Validation

**Provider Validation:**
```go
ValidateFunc: validation.StringInSlice(
    virtualmachinescalesets.PossibleValuesForAllocationStrategy(),
    false,
),
```

**Shadow Implementation:**
```hcl
validation {
    condition     = var.orchestrated_virtual_machine_scale_set_sku_profile == null || contains(["LowestPrice", "CapacityOptimized", "Prioritized"], var.orchestrated_virtual_machine_scale_set_sku_profile.allocation_strategy)
    error_message = "The `allocation_strategy` must be one of: `LowestPrice`, `CapacityOptimized`, or `Prioritized`."
}
```

**Implementation:** Added validation block to `orchestrated_virtual_machine_scale_set_sku_profile` variable in `variables.tf` that checks the field against the allowed values list.

### 2. ForceNew

**Provider Behavior:**
The entire `sku_profile` block is marked as `ForceNew: true`, meaning any change to `allocation_strategy` (or `vm_sizes`) requires resource replacement.

**Shadow Implementation:**
Added to `replace_triggers_external_values`:
```hcl
sku_profile_allocation_strategy = { value = var.orchestrated_virtual_machine_scale_set_sku_profile != null ? var.orchestrated_virtual_machine_scale_set_sku_profile.allocation_strategy : "" }
sku_profile_vm_sizes            = { value = var.orchestrated_virtual_machine_scale_set_sku_profile != null ? jsonencode(var.orchestrated_virtual_machine_scale_set_sku_profile.vm_sizes) : "" }
```

**Rationale:**
- Both fields are tracked together since they're both part of the ForceNew sku_profile block
- Used Mode 1 (wrapped in `{ value = ... }`) to ensure key stability
- When sku_profile is null, both fields return empty string to maintain key presence
- The `vm_sizes` field is jsonencoded since it's a set (to ensure consistent comparison)

### 3. Cross-Field Relationship with sku_name

From Task #17 and Task #149, the `sku_profile` block has a tight coupling with `sku_name`:
- When `sku_name = "Mix"`, `sku_profile` is **required**
- When `sku_name != "Mix"`, `sku_profile` must **not** be set

These validations were implemented in Task #17 and are not repeated here.

## Deferred Work Completion

Checked `following.md` - no work has been deferred to this task.

## Critical Review & Edge Case Analysis

### Null Semantics
- **`sku_profile = null`:** The entire block is not included in the request body (conditional returns `{}`). This is correct - null means "do not configure sku_profile".
- **Field within object:** Since this is a required field within the `sku_profile` object, Terraform's type system ensures it cannot be null when the parent object is provided.

### Boundary Conditions
- **Valid values:** Only three values are allowed: `LowestPrice`, `CapacityOptimized`, `Prioritized`. The validation block enforces this at plan time.
- **Case sensitivity:** The validation uses exact string matching, which matches the provider behavior (case-sensitive comparison).

### Idempotency
- **Value comparison:** String values are compared directly, ensuring idempotent behavior.
- **ForceNew tracking:** The field is wrapped in `{ value = ... }` pattern, ensuring stable key and proper change detection.

### Safe References
- **Null check:** The implementation checks `var.orchestrated_virtual_machine_scale_set_sku_profile != null` before accessing the `allocation_strategy` field.
- **Parent block existence:** The skeleton from Task #149 already establishes the conditional block structure.

### Edge Cases
1. **Empty string:** Not possible - validation ensures the value is one of the three allowed strings.
2. **Invalid values:** Caught by validation block at plan time.
3. **Concurrent changes:** Both `allocation_strategy` and `vm_sizes` are tracked in ForceNew, ensuring the entire sku_profile configuration triggers replacement if either field changes.

## Checklist

- ✅ Property in correct local (body)
- ✅ ForceNew wrapped: `{ value = var.orchestrated_virtual_machine_scale_set_sku_profile.allocation_strategy }`
- ✅ All logic EXACTLY replicated from provider (validation matches StringInSlice)
- ✅ Validations IMPLEMENTED in variables.tf (enum validation added)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work in following.md: N/A (this field doesn't defer work)
- ✅ Deferred work from following.md: None deferred to this task
- ✅ Critical review (null, edge, idempotent, safe refs)
- ✅ Edge Case Analysis section included
- ✅ Proof created
- ✅ `track.md` will be updated to Pending for check
- ✅ Self-Review: Only implemented allocation_strategy field, did not add hidden fields or fields from other tasks

## Implementation Verification

**Files Modified:**
1. `variables.tf` - Added validation block to `orchestrated_virtual_machine_scale_set_sku_profile` variable
2. `migrate_main.tf` - Added `allocationStrategy` field to `skuProfile` block in body
3. `migrate_main.tf` - Added ForceNew tracking for both sku_profile fields in `replace_triggers_external_values`

**Behavior Match:**
- ✅ Required field within parent block (enforced by Terraform type system)
- ✅ ForceNew behavior (tracked in replace_triggers_external_values)
- ✅ String validation with exact enum values (validation block in variables.tf)
- ✅ Direct field mapping with no transformation
- ✅ No hidden fields or defaults

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #150 - sku_profile.allocation_strategy

### Validation Results

✅ **ForceNew Logic:** Simple ForceNew (schema `ForceNew: true` at block level) - correctly implemented with Mode 1 wrapping in `replace_triggers_external_values`
✅ **Stable Keys:** All keys in `replace_triggers_external_values` are stable (both `sku_profile_allocation_strategy` and `sku_profile_vm_sizes` always present with empty string when null)
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase)
✅ **Type Conversion:** Direct string mapping, no conversion needed
✅ **Null Handling:** Correctly propagates null semantics - when `sku_profile` is null, the entire block is omitted
✅ **Validations:** Provider validation `StringInSlice` with `PossibleValuesForAllocationStrategy()` exactly replicated in `variables.tf` with the three valid values: `LowestPrice`, `CapacityOptimized`, `Prioritized`
✅ **Deferred Work Completion:** No deferred work for this task (verified in `following.md`)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed and handled (null semantics, validation, idempotency, safe references)
✅ **Shared Path Merge:** No merge conflicts - `skuProfile` appears only once in the merge structure
✅ **Cross-field Relationship:** Correctly references the parent `sku_profile` block validations from Task #17 (sku_name = "Mix" requirement)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`:
- Schema `ForceNew: true` → Tracked in `replace_triggers_external_values` with Mode 1 pattern
- Schema `Required: true` → Enforced by Terraform type system
- Schema `ValidateFunc: validation.StringInSlice(PossibleValuesForAllocationStrategy(), false)` → Replicated in validation block with exact enum values
- Direct field mapping `allocation_strategy` → `allocationStrategy` with proper camelCase conversion
- No hidden fields, no defaults, no transformations

**Status:** APPROVED ✅

---
