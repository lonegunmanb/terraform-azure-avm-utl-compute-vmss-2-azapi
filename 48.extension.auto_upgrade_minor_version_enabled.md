# Task #48 - extension.auto_upgrade_minor_version_enabled

## Shadow Implementation

**File: `migrate_main.tf`**

```hcl
locals {
  body = {
    properties = merge(
      var.orchestrated_virtual_machine_scale_set_sku_name != null ? {
        virtualMachineProfile = merge(
          var.orchestrated_virtual_machine_scale_set_extension != null || var.orchestrated_virtual_machine_scale_set_extensions_time_budget != null ? {
            extensionProfile = merge(
              var.orchestrated_virtual_machine_scale_set_extension != null ? {
                extensions = [
                  for ext in var.orchestrated_virtual_machine_scale_set_extension : {
                    name = ext.name
                    properties = {
                      publisher               = ext.publisher
                      type                    = ext.type
                      typeHandlerVersion      = ext.type_handler_version
                      autoUpgradeMinorVersion = coalesce(ext.auto_upgrade_minor_version_enabled, true) # <-
                      # provisionAfterExtensions = ... # Task #49
                      # suppressFailures = ... # Task #50
                      # forceUpdateTag = ... # Task #51
                      # protectedSettings = ... # Task #52
                      # settings = ... # Task #53
                      # protectedSettingsFromKeyVault = { # Task #54
                      #   secretUrl = ... # Task #55
                      #   sourceVault = { # Task #56
                      #     id = ... # Task #56
                      #   }
                      # }
                    }
                  }
                ]
              } : {},
              var.orchestrated_virtual_machine_scale_set_extensions_time_budget != null ? {
                extensionsTimeBudget = var.orchestrated_virtual_machine_scale_set_extensions_time_budget
              } : {}
            )
          } : {}
        )
      } : {}
    )
  }
}
```

**File: `variables.tf`**

```hcl
variable "orchestrated_virtual_machine_scale_set_extension" {
  type = set(object({
    auto_upgrade_minor_version_enabled        = optional(bool, true) # <-
    extensions_to_provision_after_vm_creation = optional(list(string))
    failure_suppression_enabled               = optional(bool)
    force_extension_execution_on_change       = optional(string)
    name                                      = string
    protected_settings                        = optional(string)
    publisher                                 = string
    settings                                  = optional(string)
    type                                      = string
    type_handler_version                      = string
    protected_settings_from_key_vault = optional(object({
      secret_url      = string
      source_vault_id = string
    }))
  }))
  default     = null
  description = <<-EOT
 - `auto_upgrade_minor_version_enabled` - (Optional) Should the latest version of the Extension be used at Deployment Time, if one is available? This won't auto-update the extension on existing installation. Defaults to `true`.
 ...
EOT
}
```

## Summary

Implemented `extension.auto_upgrade_minor_version_enabled` field mapping to Azure API's `autoUpgradeMinorVersion` property. Field has default value `true` matching provider behavior, implemented using `optional(bool, true)` in variables.tf and `coalesce()` fallback in migrate_main.tf.

## Create Phase Verification

### Query Create Method

From `resourceOrchestratedVirtualMachineScaleSetCreate`:

```go
if v, ok := d.GetOk("extension"); ok {
    var err error
    virtualMachineProfile.ExtensionProfile, hasHealthExtension, err = expandOrchestratedVirtualMachineScaleSetExtensions(v.(*pluginsdk.Set).List())
    if err != nil {
        return err
    }
}

// Later in Create method:
if !isLegacy {
    props.Properties.VirtualMachineProfile = &virtualMachineProfile
}

log.Printf("[DEBUG] Creating Orchestrated %s.", id)
if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Pattern:** Single-phase creation. Extension fields are processed via `expandOrchestratedVirtualMachineScaleSetExtensions` and added to `virtualMachineProfile.ExtensionProfile` before the `CreateOrUpdateThenPoll` call.

**Classification:** Create phase - field value is set before the create API call.

**Decision:** Implement in `local.body` (NOT in `local.post_creation_updates`).

## Assignment Path Verification

### Predicted Path
`properties.virtualMachineProfile.extensionProfile.extensions[].properties.autoUpgradeMinorVersion`

### Go Code Evidence

From `expandOrchestratedVirtualMachineScaleSetExtensions`:

```go
func expandOrchestratedVirtualMachineScaleSetExtensions(input []interface{}) (extensionProfile *virtualmachinescalesets.VirtualMachineScaleSetExtensionProfile, hasHealthExtension bool, err error) {
    extensions := make([]virtualmachinescalesets.VirtualMachineScaleSetExtension, 0)
    for _, v := range input {
        extensionRaw := v.(map[string]interface{})
        extension := virtualmachinescalesets.VirtualMachineScaleSetExtension{
            Name: pointer.To(extensionRaw["name"].(string)),
        }
        extensionType := extensionRaw["type"].(string)

        autoUpgradeMinorVersion, _ := extensionRaw["auto_upgrade_minor_version_enabled"].(bool)  // <- Read from Terraform

        extensionProps := virtualmachinescalesets.VirtualMachineScaleSetExtensionProperties{
            Publisher:               pointer.To(extensionRaw["publisher"].(string)),
            Type:                    &extensionType,
            TypeHandlerVersion:      pointer.To(extensionRaw["type_handler_version"].(string)),
            AutoUpgradeMinorVersion: pointer.To(autoUpgradeMinorVersion),  // <- Assigned to Properties
        }
        
        extension.Properties = &extensionProps  // <- Properties assigned to extension
        extensions = append(extensions, extension)
    }
    extensionProfile.Extensions = &extensions  // <- Extensions assigned to profile

    return extensionProfile, hasHealthExtension, nil
}
```

**Assignment Trace:**
1. Value read from `extensionRaw["auto_upgrade_minor_version_enabled"]` as bool
2. Assigned to `extensionProps.AutoUpgradeMinorVersion` with pointer
3. `extensionProps` assigned to `extension.Properties`
4. `extension` appended to `extensions` array
5. `extensions` assigned to `extensionProfile.Extensions`
6. In Create method: `extensionProfile` assigned to `virtualMachineProfile.ExtensionProfile`
7. `virtualMachineProfile` assigned to `props.Properties.VirtualMachineProfile`

### Verified Path
`properties.virtualMachineProfile.extensionProfile.extensions[].properties.autoUpgradeMinorVersion`

### Path Comparison
✅ **MATCH** - Predicted path matches verified path.

## Provider Schema

From `OrchestratedVirtualMachineScaleSetExtensionsSchema`:

```go
"auto_upgrade_minor_version_enabled": {
    Type:     pluginsdk.TypeBool,
    Optional: true,
    Default:  true,
},
```

**Key Properties:**
- **Type:** `TypeBool`
- **Optional:** `true`
- **Default:** `true`
- **No validations**
- **No ForceNew**
- **No DiffSuppressFunc**
- **No CustomizeDiff**

## Azure API Schema

**Path:** `properties.virtualMachineProfile.extensionProfile.extensions[].properties.autoUpgradeMinorVersion`

**Type:** `boolean`

**Description:** Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.

## Hidden Fields

None. Field value comes directly from Terraform configuration without additional processing.

## Mapping

**Terraform → Azure API:**

| Terraform Field | Azure API Field | Notes |
|----------------|-----------------|-------|
| `extension[].auto_upgrade_minor_version_enabled` | `extensions[].properties.autoUpgradeMinorVersion` | snake_case → camelCase |

## Special Handling

### Default Value Implementation

**Provider Behavior:**
- Schema specifies `Default: true`
- When field is not set, provider returns `false` from type assertion: `autoUpgradeMinorVersion, _ := extensionRaw["auto_upgrade_minor_version_enabled"].(bool)`
- But then immediately wraps with `pointer.To(autoUpgradeMinorVersion)`, sending `false` to API
- **CRITICAL:** Provider schema `Default: true` means Terraform sets the value to `true` BEFORE the Go code sees it
- The expand function receives `true` when user doesn't specify a value

**Shadow Module Implementation:**
Two-layer default handling for exact replication:
1. **variables.tf:** `optional(bool, true)` - Terraform sets default to `true` when field not provided
2. **migrate_main.tf:** `coalesce(ext.auto_upgrade_minor_version_enabled, true)` - Additional safety layer

**Why Both Layers:**
- `optional(bool, true)` replicates schema `Default: true` behavior
- `coalesce(..., true)` ensures value is never null/false in final API payload
- This exactly matches provider behavior where schema default applies before expand function

### No ForceNew Logic

This field does NOT have `ForceNew: true` in schema and has no CustomizeDiff logic affecting it. Changes to this field will update in-place.

### No Validations

Provider schema has no validations for this field. All boolean values are valid.

## Deferred Work Completion

Checked `following.md` - file does not exist. No deferred work to complete.

## Critical Review & Edge Case Analysis

### Null Semantics
- **`ext.auto_upgrade_minor_version_enabled == null`:** Uses default `true` (via `optional(bool, true)` and `coalesce()` fallback) ✅
- **`ext.auto_upgrade_minor_version_enabled == true`:** Passes `true` to API ✅
- **`ext.auto_upgrade_minor_version_enabled == false`:** Passes `false` to API ✅

### Edge Cases
1. **Explicit false vs omitted:** When user explicitly sets `false`, value is `false`. When omitted, Terraform applies default `true` via `optional(bool, true)`.
2. **Boolean coercion:** `coalesce()` with bool type is safe - no type conversion issues.
3. **API behavior:** Azure API accepts both `true` and `false`. Default `true` means extensions will use latest compatible minor version at deployment time.
4. **Update behavior:** Field can be updated without ForceNew. Azure will apply the new setting on next extension deployment/update.

### Idempotency
- ✅ Field is idempotent - same input always produces same output
- ✅ Default value `true` is consistently applied when field is omitted
- ✅ Boolean type prevents ambiguous values

### Safe References
- ✅ Field accessed within `for` loop over `var.orchestrated_virtual_machine_scale_set_extension`
- ✅ Loop only executes when `extension != null` (checked in parent conditional)
- ✅ `coalesce()` provides safe fallback for null values
- ✅ No nested object access that could fail on null

### Default Value Replication Verification

**Provider Schema Default Application:**
```go
// Schema definition
"auto_upgrade_minor_version_enabled": {
    Type:     pluginsdk.TypeBool,
    Optional: true,
    Default:  true,  // <- Terraform applies this BEFORE expand function
},

// Expand function receives value after default applied
autoUpgradeMinorVersion, _ := extensionRaw["auto_upgrade_minor_version_enabled"].(bool)
// If user didn't set value, this receives `true` from schema default
```

**Shadow Module Replication:**
```hcl
# variables.tf - Replicates schema default
auto_upgrade_minor_version_enabled = optional(bool, true)  # <- Terraform applies default

# migrate_main.tf - Additional safety (though optional(bool, true) should handle it)
autoUpgradeMinorVersion = coalesce(ext.auto_upgrade_minor_version_enabled, true)
```

**Verification:**
- ✅ User omits field → `optional(bool, true)` sets to `true` → API receives `true`
- ✅ User sets `true` → API receives `true`
- ✅ User sets `false` → API receives `false`
- ✅ Matches provider behavior exactly

## Checklist

- ✅ Property in correct local (`local.body`)
- ✅ ForceNew not needed (field not marked ForceNew in schema)
- ✅ Logic EXACTLY replicated (default value `true` via `optional(bool, true)`)
- ✅ No validations in provider schema - none added
- ✅ Hidden fields checked (none)
- ✅ Deferred work checked (no following.md exists)
- ✅ Critical review completed
- ✅ Edge Case Analysis documented
- ✅ Proof created
- ✅ track.md ready for update
- ✅ Self-Review: Only Task #48 field implemented, no other fields added

## Compliance Statement

This implementation EXACTLY replicates the AzureRM provider behavior:

1. ✅ **Default Value:** Uses `optional(bool, true)` to match provider's `Default: true` schema property
2. ✅ **No Validations:** Provider has no validations for this field - none added
3. ✅ **No ForceNew:** Field not marked ForceNew - no replace triggers added
4. ✅ **Correct Phase:** Field set in Create phase via `local.body`
5. ✅ **Exact Mapping:** snake_case → camelCase conversion matches provider expand function
6. ✅ **Type Handling:** Boolean type properly handled with `coalesce()` fallback

**No approximations, no "more conservative" approaches, no deviations.** The implementation is an exact replica of the provider's logic for this field.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-08
**Task:** #48 - extension.auto_upgrade_minor_version_enabled

### Validation Results

✅ **ForceNew Logic:** No ForceNew required (field not marked ForceNew in schema, no CustomizeDiff logic)
✅ **Stable Keys:** N/A - field not in replace_triggers_external_values (correctly)
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase, single-phase creation pattern)
✅ **Type Conversion:** Boolean type correctly handled, no conversion needed
✅ **Null Handling:** Correctly uses `optional(bool, true)` in variables.tf and `coalesce(..., true)` fallback in locals
✅ **Validations:** No provider validations - correctly none implemented
✅ **Default Value:** Exactly replicates provider's `Default: true` using `optional(bool, true)` (executor.md preferred method)
✅ **Deferred Work Completion:** No following.md exists - no deferred work to complete
✅ **Deferred Work Recording:** No deferrals made - N/A
✅ **Edge Cases:** All edge cases properly analyzed and handled (explicit false vs omitted, boolean coercion, API behavior, update behavior)
✅ **Scope Compliance:** Only Task #48 field implemented, no other fields added

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`:

1. **Default Value Handling:** Uses the PREFERRED method `optional(bool, true)` (executor.md lines 124-127) instead of fallback coalesce() in locals. The additional `coalesce()` in migrate_main.tf is acceptable as a safety layer.

2. **Method Priority:** Correctly prioritizes `optional(bool, true)` over fallback methods, following executor.md's strict method priority rules.

3. **No Deviations:** No simplifications, no "more conservative" approaches, no violations of the EXACT replication requirement.

**Status:** APPROVED ✅

---
