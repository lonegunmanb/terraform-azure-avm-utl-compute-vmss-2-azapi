# Task #88 - os_disk.caching

## Summary

Implemented the `caching` argument for the `os_disk` block. This is a required field that specifies the caching type for the Internal OS Disk. The field accepts three values: `None`, `ReadOnly`, or `ReadWrite`. The implementation includes direct mapping from Terraform to Azure API with validation enforcement.

## Shadow Implementation

```hcl
# In migrate_main.tf
locals {
  body = merge(
    {
      properties = merge(
        var.orchestrated_virtual_machine_scale_set_sku_name != null ? {
          virtualMachineProfile = merge(
            var.orchestrated_virtual_machine_scale_set_data_disk != null || var.orchestrated_virtual_machine_scale_set_os_disk != null ? {
              storageProfile = merge(
                var.orchestrated_virtual_machine_scale_set_os_disk != null ? {
                  osDisk = {
                    caching = var.orchestrated_virtual_machine_scale_set_os_disk.caching # <- Task #88
                  }
                } : {}
              )
            } : {}
          )
        } : {}
      )
    }
  )
}
```

```hcl
# In variables.tf
variable "orchestrated_virtual_machine_scale_set_os_disk" {
  type = object({
    caching = string # <- Required field
    # ... other fields ...
  })
  
  validation {
    condition = (
      var.orchestrated_virtual_machine_scale_set_os_disk == null ||
      contains(["None", "ReadOnly", "ReadWrite"], var.orchestrated_virtual_machine_scale_set_os_disk.caching)
    )
    error_message = "The caching type must be one of: None, ReadOnly, ReadWrite." # <- Task #88 validation
  }
}
```

## Create Phase Verification

**Pattern:** Single-phase creation

**Evidence from Create method:**

```go
if v, ok := d.GetOk("os_disk"); ok {
    virtualMachineProfile.StorageProfile.OsDisk = ExpandOrchestratedVirtualMachineScaleSetOSDisk(v.([]interface{}), osType)
}

// ... later in Create method ...
props.Properties.VirtualMachineProfile = &virtualMachineProfile

// Single-phase creation
if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Classification:** The `caching` field is set during the Create phase (before the CreateOrUpdateThenPoll call) as part of the `os_disk` expansion. This field is added to `local.body`.

**Decision:** Implement in `local.body` (not `post_creation_updates`).

## Assignment Path Verification

**Predicted Path:** `body.properties.virtualMachineProfile.storageProfile.osDisk.caching`

**Go Code Evidence:**

From `ExpandOrchestratedVirtualMachineScaleSetOSDisk`:

```go
func ExpandOrchestratedVirtualMachineScaleSetOSDisk(input []interface{}, osType virtualmachinescalesets.OperatingSystemTypes) *virtualmachinescalesets.VirtualMachineScaleSetOSDisk {
    raw := input[0].(map[string]interface{})
    disk := virtualmachinescalesets.VirtualMachineScaleSetOSDisk{
        Caching: pointer.To(virtualmachinescalesets.CachingTypes(raw["caching"].(string))),
        // ... other fields ...
    }
    return &disk
}
```

From Create method:

```go
virtualMachineProfile := virtualmachinescalesets.VirtualMachineScaleSetVMProfile{
    StorageProfile: &virtualmachinescalesets.VirtualMachineScaleSetStorageProfile{},
}

// Later:
if v, ok := d.GetOk("os_disk"); ok {
    virtualMachineProfile.StorageProfile.OsDisk = ExpandOrchestratedVirtualMachineScaleSetOSDisk(v.([]interface{}), osType)
}

// Even later:
props.Properties.VirtualMachineProfile = &virtualMachineProfile
```

**Path Tracing:**
1. `disk.Caching` = user input value
2. `virtualMachineProfile.StorageProfile.OsDisk.Caching` = disk.Caching
3. `props.Properties.VirtualMachineProfile` = &virtualMachineProfile
4. Final path: `properties.virtualMachineProfile.storageProfile.osDisk.caching`

**Verified Path:** `body.properties.virtualMachineProfile.storageProfile.osDisk.caching` ✅

## Provider Schema

From `OrchestratedVirtualMachineScaleSetOSDiskSchema()`:

```go
"caching": {
    Type:     pluginsdk.TypeString,
    Required: true,
    ValidateFunc: validation.StringInSlice([]string{
        string(virtualmachinescalesets.CachingTypesNone),
        string(virtualmachinescalesets.CachingTypesReadOnly),
        string(virtualmachinescalesets.CachingTypesReadWrite),
    }, false),
},
```

**Field Attributes:**
- **Type:** String
- **Required:** true (MUST be provided when os_disk block is present)
- **ForceNew:** false (NOT marked - updates are allowed)
- **Validation:** Must be one of: `None`, `ReadOnly`, `ReadWrite`
- **Default:** None specified in schema
- **Computed:** false

## Azure API Schema

**Path:** `body.properties.virtualMachineProfile.storageProfile.osDisk.caching`

**API Documentation:**
> "Specifies the caching requirements. Possible values are: **None,** **ReadOnly,** **ReadWrite.** The default values are: **None for Standard storage. ReadOnly for Premium storage.**"

**Possible Values:** `None`, `ReadOnly`, `ReadWrite`

**Type:** String (enum)

## Hidden Fields

No hidden fields for the `caching` argument itself. The parent `osDisk` object has hidden fields (`createOption`, `osType`) which are handled at the block level (Task #87 documentation).

## Mapping

Terraform (snake_case) → Azure API (camelCase):

| Terraform Field | Azure API Field |
|----------------|-----------------|
| `os_disk.caching` | `osDisk.caching` |

**Value Mapping:** Direct pass-through (no transformation needed):
- `None` → `None`
- `ReadOnly` → `ReadOnly`
- `ReadWrite` → `ReadWrite`

## Special Handling

### Validation

**Category 1 - Value Constraints (MANDATORY):**

From provider schema:

```go
ValidateFunc: validation.StringInSlice([]string{
    string(virtualmachinescalesets.CachingTypesNone),
    string(virtualmachinescalesets.CachingTypesReadOnly),
    string(virtualmachinescalesets.CachingTypesReadWrite),
}, false),
```

**Implementation in variables.tf:**

```hcl
validation {
  condition = (
    var.orchestrated_virtual_machine_scale_set_os_disk == null ||
    contains(["None", "ReadOnly", "ReadWrite"], var.orchestrated_virtual_machine_scale_set_os_disk.caching)
  )
  error_message = "The caching type must be one of: None, ReadOnly, ReadWrite."
}
```

**Rationale:** This validation replicates the exact provider behavior. The condition allows null for the entire `os_disk` object (which is optional), but when `os_disk` is provided, `caching` MUST be one of the three valid values (None, ReadOnly, or ReadWrite).

### ForceNew Handling

**Schema Check:** The field is NOT marked with `ForceNew: true` in the provider schema.

**CustomizeDiff Check:** No CustomizeDiff logic found for `caching` field in the resource function.

**Conclusion:** This field does NOT require ForceNew tracking. Updates to `caching` are allowed without resource replacement.

**Implementation:** Field is NOT added to `replace_triggers_external_values`.

### Sensitive/WriteOnly

The field is NOT marked as Sensitive or WriteOnly. It's a standard configuration field that can be read back from the API.

**Implementation:** Field is placed in `local.body` (not `sensitive_body`).

### Defaults

**Provider Schema:** No default value specified in the schema.

**Azure API Behavior:** According to the API documentation, Azure applies defaults based on storage type:
- Standard storage → Default: `None`
- Premium storage → Default: `ReadOnly`

**Implementation Decision:** We do NOT replicate Azure's default logic because:
1. The provider schema marks the field as `Required: true` (not Optional with Default)
2. The provider does NOT apply any default in the expand function
3. Users MUST explicitly provide this value per provider behavior

Therefore, no default is set in our variable definition. The field remains required when `os_disk` block is present.

## Deferred Work Completion

Checked `following.md` for any work deferred to Task #88: No deferred work found.

## Critical Review & Edge Case Analysis

### Null Semantics

- **When `os_disk` is null:** The entire `osDisk` object is omitted from the API payload. The `caching` field is not included.
- **When `os_disk` is provided:** The `caching` field MUST be present and contain one of the three valid values.
- **Meaning:** No ambiguity - field is required when parent block exists, completely absent otherwise.

### Boundary Conditions

1. **Empty string:** Not allowed - validation enforces one of three specific values
2. **Case sensitivity:** The validation is case-sensitive (matches provider behavior)
3. **Invalid values:** Caught at plan time by validation block
4. **Missing when os_disk exists:** This would fail Terraform's type checking since `caching` is not marked as `optional()` in the object type

### Idempotency

- **Value stability:** Direct string assignment with no transformations
- **No order dependencies:** Single value field, no collections involved
- **Deterministic:** Same input always produces same output
- **Safe for repeated applies:** ✅

### Safe References

```hcl
caching = var.orchestrated_virtual_machine_scale_set_os_disk.caching
```

- **Protection:** Access is guarded by parent condition `var.orchestrated_virtual_machine_scale_set_os_disk != null`
- **No nested access:** Direct field access, no chaining through optional fields
- **Type safety:** Field is required in the object type definition

### Edge Cases

1. **Legacy mode (sku_name not set):**
   - The entire `virtualMachineProfile` is omitted
   - Parent condition handles this: `var.orchestrated_virtual_machine_scale_set_sku_name != null`
   - Field is never evaluated in legacy mode ✅

2. **os_disk provided without caching:**
   - Terraform type checking prevents this at plan time
   - Field is not `optional()` in the object type
   - Error occurs before our code executes ✅

3. **Invalid enum value:**
   - Caught by validation block at plan time
   - Provides clear error message to user
   - Prevents invalid API calls ✅

4. **Update scenario:**
   - Field is NOT ForceNew
   - Azure API accepts caching changes on existing resources
   - Updates work correctly ✅

5. **Interaction with storage account type:**
   - Azure applies different defaults based on storage type, but we don't need to replicate this
   - Provider requires explicit value regardless of storage type
   - Our implementation matches provider behavior ✅

## Checklist

- ✅ Field added to correct local (`body`)
- ✅ Correct path: `body.properties.virtualMachineProfile.storageProfile.osDisk.caching`
- ✅ Validation implemented in `variables.tf` (enum validation)
- ✅ ForceNew NOT added (field allows updates)
- ✅ NOT added to `sensitive_body` (not sensitive)
- ✅ NOT added to `replace_triggers_external_values` (not ForceNew)
- ✅ Comment placeholder replaced with implementation
- ✅ No defaults added (field is Required in provider)
- ✅ Direct string mapping (no transformation)
- ✅ Parent block condition protects access
- ✅ Deferred work checked (none found)
- ✅ Edge case analysis completed
- ✅ Proof document created
- ✅ Logic exactly replicates provider behavior
- ✅ Self-review: Added only Task #88 implementation, no other fields

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2025-12-09
**Task:** #88 - os_disk.caching

### Issues Identified

#### Issue 1: Proof Document Error Message Inconsistency

**Problem:**
The proof document contained an incorrect error message in two locations (lines 47 and 195), stating:
```
error_message = "The caching type must be one of: None, ReadWrite."
```

This was missing "ReadOnly" from the list of valid values, making the proof documentation inconsistent with the actual implementation.

**Executor's Proof Documentation (Incorrect):**
```hcl
error_message = "The caching type must be one of: None, ReadWrite." # Missing ReadOnly
```

**Why This Violates executor.md:**
From executor.md proof document requirements:
> Proof documents must accurately document the implementation with code evidence. The proof must match the actual implementation exactly.

The proof document must correctly reflect all three valid enum values as specified in the provider schema and as correctly implemented in the code.

**Provider's Actual Behavior:**
```go
ValidateFunc: validation.StringInSlice([]string{
    string(virtualmachinescalesets.CachingTypesNone),
    string(virtualmachinescalesets.CachingTypesReadOnly),
    string(virtualmachinescalesets.CachingTypesReadWrite),
}, false),
```

All three values (None, ReadOnly, ReadWrite) are valid.

**Expected Behavior:**
- Error message must list all three valid values: "None", "ReadOnly", and "ReadWrite"
- Proof documentation must match the actual implementation in variables.tf

**Root Cause:**
Documentation error in the proof document - the actual implementation in `variables.tf` (line 851) was correct, but the proof document examples were incomplete.

### Corrections Made

#### Fix 1: Corrected Error Message Documentation

**Changed Files:**
- `88.os_disk.caching.md`: Corrected error message documentation in two locations (lines 47 and 195)

**Corrected Documentation:**
```hcl
error_message = "The caching type must be one of: None, ReadOnly, ReadWrite."
```

**Why This is EXACT:**
- Now correctly lists all three valid enum values as per provider schema
- Matches the actual implementation in variables.tf line 851
- Accurately reflects the provider's validation behavior

**Verification:**
- Provider schema: Accepts "None", "ReadOnly", "ReadWrite" ✅
- Implementation in variables.tf: Validates against all three values ✅
- Proof documentation: Now correctly documents all three values ✅

### Implementation Validation

After correcting the proof documentation, verified the actual implementation:

✅ **Code Implementation (migrate_main.tf line 475):** Correct - direct field mapping
✅ **Validation (variables.tf lines 846-852):** Correct - validates against all three values
✅ **ForceNew Logic:** Correct - field is NOT ForceNew, not in replace_triggers
✅ **Stable Keys:** N/A - field is not in replace_triggers_external_values
✅ **Phase Detection:** Correct - field in local.body (Create phase)
✅ **Type Conversion:** Correct - direct string pass-through
✅ **Null Handling:** Correct - parent null check protects field access
✅ **Validations:** Correct - enum validation implemented in variables.tf
✅ **Deferred Work Completion:** No deferred work for this task
✅ **Deferred Work Recording:** No deferrals made
✅ **Edge Cases:** All edge cases properly analyzed and handled

### Compliance Statement

After corrections to the proof documentation, this implementation EXACTLY replicates the provider behavior as required by `executor.md`. The code implementation was correct from the start - only the proof document needed correction to accurately reflect the implementation.

**Status:** CORRECTED AND APPROVED ✅

---
