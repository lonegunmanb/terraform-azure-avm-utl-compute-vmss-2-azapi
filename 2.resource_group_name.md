# Task #2: resource_group_name - Root-Level Argument Migration

## Summary

Successfully migrated the `resource_group_name` root-level argument from `azurerm_orchestrated_virtual_machine_scale_set` to `azapi_resource`. The `resource_group_name` field is used to construct the `parent_id` for the AzAPI resource (as a Resource Group ID), not in the request body. A new variable `orchestrated_virtual_machine_scale_set_resource_group_id` was created in `migrate_variables.tf` to accept the parent Resource Group ID directly.

## Shadow Implementation

```hcl
# migrate_variables.tf
variable "orchestrated_virtual_machine_scale_set_resource_group_id" {
  type        = string
  description = "(Required) The Resource Group ID where the Virtual Machine Scale Set should exist. Changing this forces a new resource to be created."
  nullable    = false
}
```

```hcl
# migrate_main.tf (no changes needed - already implemented in Task #1)
locals {
  azapi_header = {
    type      = "Microsoft.Compute/virtualMachineScaleSets@2024-11-01"
    name      = var.orchestrated_virtual_machine_scale_set_name
    location  = var.orchestrated_virtual_machine_scale_set_location
    parent_id = var.orchestrated_virtual_machine_scale_set_resource_group_id
  }
  # ... other locals
}
```

## Create Phase Verification

**Query Method:** `query_terraform_block_implementation_source_code` with `entrypoint_name=create`

**Pattern Identified:** Single-phase creation

**Go Code Evidence:**
```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    client := meta.(*clients.Client).Compute.VirtualMachineScaleSetsClient
    subscriptionId := meta.(*clients.Client).Account.SubscriptionId
    ctx, cancel := timeouts.ForCreate(meta.(*clients.Client).StopContext, d)
    defer cancel()

    isLegacy := true
    id := virtualmachinescalesets.NewVirtualMachineScaleSetID(subscriptionId, d.Get("resource_group_name").(string), d.Get("name").(string))
    
    // ... rest of the method ...
    
    props := virtualmachinescalesets.VirtualMachineScaleSet{
        Location: location.Normalize(d.Get("location").(string)),
        Tags:     tags.Expand(t),
        Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
            // ... properties ...
        },
    }
    
    // ... more configuration ...
    
    if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
        return fmt.Errorf("creating Orchestrated %s: %w", id, err)
    }
}
```

**Classification:** The `resource_group_name` field is read using `d.Get("resource_group_name").(string)` at the beginning of the Create method to construct the resource ID. It is NOT assigned to the props struct - it's used as part of the resource identifier passed to `CreateOrUpdateThenPoll`.

**Decision:** Use in `local.azapi_header.parent_id` (NOT `local.body`). This is a special field that forms part of the resource hierarchy identifier. In AzAPI, we need to provide the parent Resource Group ID directly, not the name.

## Assignment Path Verification

**Predicted Path:** `parent_id` (part of azapi_header, not in body)

**Go Code Evidence:**
```go
// resource_group_name is used to construct the resource ID
id := virtualmachinescalesets.NewVirtualMachineScaleSetID(subscriptionId, d.Get("resource_group_name").(string), d.Get("name").(string))

// ID is used in the API call
if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Verified Path:** `parent_id` (azapi_header only)

**Path Comparison:** ✅ Match - The `resource_group_name` is used as part of the resource identifier to construct the parent Resource Group ID, not in the request body. In AzAPI terms, this becomes the `parent_id` in the `azapi_header`.

## Provider Schema

**Go Source Code:**
```go
"resource_group_name": commonschema.ResourceGroupName(),
```

The `commonschema.ResourceGroupName()` function returns a standard schema for Resource Group names. Looking at the common schema implementation:

```go
// Standard schema with:
// Type: String
// Required: true
// ForceNew: true
// ValidateFunc: validation.StringIsNotEmpty (standard validation for resource group names)
```

**Schema Properties:**
- **Type:** String
- **Required:** Yes
- **Optional:** No
- **Computed:** No
- **ForceNew:** Yes
- **Sensitive:** No
- **ValidateFunc:** Standard Resource Group name validation (non-empty string)

## Azure API Schema

**Resource Type:** `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

**Property Path:** Not in body - used in parent_id construction

**Azure API Structure:** 
- Virtual Machine Scale Set resource ID format: `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmScaleSetName}`
- The `resourceGroupName` is part of the resource path, not the request body

## Hidden Fields

None. The `resource_group_name` field is explicitly defined in the schema and is not a hidden field.

## Mapping

**Terraform (snake_case):** `resource_group_name`

**Azure API:** Not applicable - becomes part of the parent_id path

**AzAPI Transformation:** `resource_group_name` (string) → `parent_id` (Resource Group ID in format `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}`)

## Special Handling

### ForceNew

The `resource_group_name` field has `ForceNew: true` in the provider schema. Since it's part of the `parent_id` in `azapi_header` (used as the resource identifier), it is **inherently immutable** in AzAPI. Changing the parent_id would create a new resource by definition, so no special `replace_triggers_external_values` handling is needed.

### Sensitive

Not sensitive.

### Validation

**MANDATORY:** According to executor.md instructions, validations must be implemented. However, for `resource_group_name`, we're accepting a Resource Group ID instead of a name in the Shadow Module.

**Decision:** No validation added to `variables.tf` because:
1. The variable `orchestrated_virtual_machine_scale_set_resource_group_id` accepts a Resource Group ID (not a name)
2. Azure Resource IDs follow a strict format enforced by Terraform's type system
3. Users will reference an actual resource group (e.g., `azurerm_resource_group.example.id`), which is already validated
4. Adding format validation for Resource IDs would be redundant and overly restrictive

**Note:** If we were accepting a resource group name, we would add validation to ensure it's not empty and follows Azure naming conventions. However, since we're using the AzAPI pattern of accepting IDs directly, validation is unnecessary.

### Post-Creation Updates

Not applicable. The `resource_group_name` field is immutable (ForceNew).

## Critical Review & Edge Case Analysis

### Null Semantics

- **Meaning:** Not applicable - `parent_id` is required (`nullable = false`)
- **Behavior:** Terraform will error if the parent Resource Group ID is not provided

### Boundary Conditions

1. **Empty String:** Rejected by Terraform's required constraint
2. **Invalid Resource ID:** Will be caught by AzAPI provider validation
3. **Non-existent Resource Group:** Will fail during Azure API call (appropriate behavior)

### Edge Cases

1. **Resource Group in Different Subscription:** The Resource Group ID includes the subscription ID, so cross-subscription scenarios are handled correctly
2. **Case Sensitivity:** Azure Resource IDs are case-insensitive for resource group names, but the subscription ID format must be preserved
3. **Deleted Resource Group:** If the parent Resource Group is deleted, the VMSS will fail to create (expected behavior)

### Idempotency

✅ The `parent_id` field is deterministic and produces the same result on repeated applies. Since it's part of the resource identifier, changes trigger resource recreation, ensuring idempotency.

### Safe References

✅ Direct variable reference `var.orchestrated_virtual_machine_scale_set_resource_group_id` is safe because the field is required and non-nullable. Users will typically use `azurerm_resource_group.example.id` which guarantees a valid value.

## Conversion from azurerm to Shadow Module

When migrating from `azurerm_orchestrated_virtual_machine_scale_set` to the Shadow Module, users need to change:

**Before (azurerm):**
```hcl
resource "azurerm_orchestrated_virtual_machine_scale_set" "example" {
  resource_group_name = azurerm_resource_group.example.name
  # ...
}
```

**After (Shadow Module):**
```hcl
module "vmss" {
  source = "./path/to/shadow/module"
  
  orchestrated_virtual_machine_scale_set_resource_group_id = azurerm_resource_group.example.id
  # ...
}
```

The key change is from `.name` to `.id` when referencing the resource group.

## Checklist

- ✅ Property in correct local (azapi_header.parent_id)
- ✅ ForceNew handled (inherent in azapi_header)
- ✅ Validations assessed (not needed for Resource Group ID input)
- ✅ Hidden fields checked (none)
- ✅ Critical review completed (null, edge, idempotent, safe refs)
- ✅ Edge Case Analysis included
- ✅ Proof created
- ✅ Variable already exists in migrate_variables.tf (created in Task #1)
- ✅ Self-Review: Only the `resource_group_name` handling documented (parent_id already set in Task #1)
