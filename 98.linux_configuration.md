# Task #98: os_profile.linux_configuration Block Structure Skeleton

## Summary

Created the structure skeleton for the `os_profile.linux_configuration` block migration from `azurerm_orchestrated_virtual_machine_scale_set` to `azapi_resource`. This establishes the conditional framework with comment placeholders for all child fields (admin_username, admin_password, computer_name_prefix, disable_password_authentication, patch settings, SSH keys, and secrets). The block maps to `properties.virtualMachineProfile.osProfile.linuxConfiguration` in the Azure API.

## Shadow Implementation

```hcl
locals {
  body = {
    properties = merge(
      # ... existing properties ...
      var.orchestrated_virtual_machine_scale_set_os_profile != null ? {
        virtualMachineProfile = merge(
          {
            osProfile = merge(
              var.orchestrated_virtual_machine_scale_set_os_profile.custom_data != null ? {
                customData = var.orchestrated_virtual_machine_scale_set_os_profile.custom_data
              } : {},
              var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration != null ? { # <-
                linuxConfiguration = { # <-
                  # adminUsername = ... # Task #99 # <-
                  # adminPassword = ... # Task #100 # <-
                  # computerNamePrefix = ... # Task #101 # <-
                  # disablePasswordAuthentication = ... # Task #102 # <-
                  # provisionVMAgent = ... # Task #105 # <-
                  # patchSettings = { # Task #103, #104 # <-
                  #   assessmentMode = ... # Task #103 # <-
                  #   patchMode = ... # Task #104 # <-
                  # } # <-
                  # ssh = { # Task #106-108 # <-
                  #   publicKeys = ... # Task #106-108 # <-
                  # } # <-
                  # secrets = ... # Task #109-112 # <-
                } # <-
              } : {}, # <-
              {
                # windowsConfiguration = ... # Task #113-133
              }
            )
          }
        )
      } : {}
    )
  }
}
```

## Create Phase Verification

### Pattern Identification

Queried the Create method to understand how `linux_configuration` is processed:

**Pattern:** Single-phase creation

The `linux_configuration` block is processed during the Create phase through the expand function:

```go
osProfileRaw := d.Get("os_profile").([]interface{})

if len(osProfileRaw) > 0 && osProfileRaw[0] != nil {
    osProfile := osProfileRaw[0].(map[string]interface{})
    linConfigRaw = osProfile["linux_configuration"].([]interface{})
    customData := ""

    // Pass custom data if it is defined in the config file
    if v := osProfile["custom_data"]; v != nil {
        customData = v.(string)
    }

    if len(linConfigRaw) > 0 && linConfigRaw[0] != nil {
        osType = virtualmachinescalesets.OperatingSystemTypesLinux
        linConfig := linConfigRaw[0].(map[string]interface{})
        vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration(linConfig, customData)
        // ... validation logic ...
    }

    if vmssOsProfile != nil {
        vmssOsProfile.AllowExtensionOperations = pointer.To(extensionOperationsEnabled)
    }

    virtualMachineProfile.OsProfile = vmssOsProfile
}

// Later assignment:
props.Properties.VirtualMachineProfile = &virtualMachineProfile
```

**Classification:** Create phase → Assign to `local.body`

### Decision

The `linux_configuration` block will be added to `local.body` as it is set during the single-phase create operation.

## Assignment Path Verification

### Predicted Path

`body.properties.virtualMachineProfile.osProfile.linuxConfiguration`

### Go Code Evidence

From the expand function `expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration`:

```go
func expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration(input map[string]interface{}, customData string) *virtualmachinescalesets.VirtualMachineScaleSetOSProfile {
    osProfile := virtualmachinescalesets.VirtualMachineScaleSetOSProfile{}
    linConfig := virtualmachinescalesets.LinuxConfiguration{}
    patchSettings := virtualmachinescalesets.LinuxPatchSettings{}

    if len(input) > 0 {
        osProfile.CustomData = pointer.To(customData)
        osProfile.AdminUsername = pointer.To(input["admin_username"].(string))
        
        // ... other fields ...
        
        linConfig.DisablePasswordAuthentication = pointer.To(input["disable_password_authentication"].(bool))
        linConfig.ProvisionVMAgent = pointer.To(input["provision_vm_agent"].(bool))
        
        patchSettings.AssessmentMode = pointer.To(virtualmachinescalesets.LinuxPatchAssessmentMode(input["patch_assessment_mode"].(string)))
        patchSettings.PatchMode = pointer.To(virtualmachinescalesets.LinuxVMGuestPatchMode(input["patch_mode"].(string)))
        linConfig.PatchSettings = &patchSettings
    }

    osProfile.LinuxConfiguration = &linConfig

    return &osProfile
}
```

The assignment chain:
1. `linConfig` is populated with Linux-specific settings
2. `osProfile.LinuxConfiguration = &linConfig`
3. `virtualMachineProfile.OsProfile = vmssOsProfile` (where `vmssOsProfile` is the returned `osProfile`)
4. `props.Properties.VirtualMachineProfile = &virtualMachineProfile`

The complete path: `VirtualMachineScaleSet.Properties.VirtualMachineProfile.OsProfile.LinuxConfiguration`

### Verified Path

`body.properties.virtualMachineProfile.osProfile.linuxConfiguration`

### Path Comparison

✅ **MATCH** - Predicted path matches the verified assignment chain from Go source code.

## Provider Schema

From `OrchestratedVirtualMachineScaleSetLinuxConfigurationSchema()`:

```go
func OrchestratedVirtualMachineScaleSetLinuxConfigurationSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        MaxItems: 1,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "admin_username": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ForceNew:     true,
                    ValidateFunc: validateAdminUsernameLinux,
                },

                "admin_password": {
                    Type:             pluginsdk.TypeString,
                    Optional:         true,
                    ForceNew:         true,
                    Sensitive:        true,
                    DiffSuppressFunc: adminPasswordDiffSuppressFunc,
                    ValidateFunc:     validatePasswordComplexityLinux,
                },

                "admin_ssh_key":        SSHKeysSchema(false),
                "computer_name_prefix": computerPrefixLinuxSchema(),

                "disable_password_authentication": {
                    Type:     pluginsdk.TypeBool,
                    Optional: true,
                    Default:  true,
                },

                "provision_vm_agent": {
                    Type:     pluginsdk.TypeBool,
                    Optional: true,
                    Default:  true,
                    ForceNew: true,
                },

                "patch_assessment_mode": {
                    Type:     pluginsdk.TypeString,
                    Optional: true,
                    Default:  string(virtualmachinescalesets.LinuxPatchAssessmentModeImageDefault),
                    ValidateFunc: validation.StringInSlice([]string{
                        string(virtualmachinescalesets.LinuxPatchAssessmentModeAutomaticByPlatform),
                        string(virtualmachinescalesets.LinuxPatchAssessmentModeImageDefault),
                    }, false),
                },

                "patch_mode": {
                    Type:     pluginsdk.TypeString,
                    Optional: true,
                    Default:  string(virtualmachinescalesets.LinuxVMGuestPatchModeImageDefault),
                    ValidateFunc: validation.StringInSlice([]string{
                        string(virtualmachinescalesets.LinuxVMGuestPatchModeImageDefault),
                        string(virtualmachinescalesets.LinuxVMGuestPatchModeAutomaticByPlatform),
                    }, false),
                },

                "secret": linuxSecretSchema(),
            },
        },
    }
}
```

**Key Properties:**
- **Type:** List with MaxItems: 1
- **Optional:** Yes
- **Required Child Fields:**
  - `admin_username` (string, ForceNew)
- **Optional Child Fields:**
  - `admin_password` (string, Sensitive, ForceNew)
  - `admin_ssh_key` (set/block)
  - `computer_name_prefix` (string)
  - `disable_password_authentication` (bool, default: true)
  - `provision_vm_agent` (bool, default: true, ForceNew)
  - `patch_assessment_mode` (string, default: "ImageDefault")
  - `patch_mode` (string, default: "ImageDefault")
  - `secret` (list/block)

### SSH Keys Schema

```go
func SSHKeysSchema(isVirtualMachine bool) *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeSet,
        Optional: true,
        ForceNew: isVirtualMachine,
        Set:      SSHKeySchemaHash,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "public_key": {
                    Type:             pluginsdk.TypeString,
                    Required:         true,
                    ForceNew:         isVirtualMachine,
                    ValidateFunc:     validate.SSHKey,
                    DiffSuppressFunc: suppress.SSHKey,
                },

                "username": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ForceNew:     isVirtualMachine,
                    ValidateFunc: validation.StringIsNotEmpty,
                },
            },
        },
    }
}
```

For VMSS, `isVirtualMachine = false`, so SSH keys are NOT ForceNew.

### Linux Secrets Schema

```go
func linuxSecretSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "key_vault_id": commonschema.ResourceIDReferenceRequired(&commonids.KeyVaultId{}),

                "certificate": {
                    Type:     pluginsdk.TypeSet,
                    Required: true,
                    MinItems: 1,
                    Elem: &pluginsdk.Resource{
                        Schema: map[string]*pluginsdk.Schema{
                            "url": {
                                Type:         pluginsdk.TypeString,
                                Required:     true,
                                ValidateFunc: keyVaultValidate.NestedItemId,
                            },
                        },
                    },
                },
            },
        },
    }
}
```

## Azure API Schema

Query result for `body.properties.virtualMachineProfile.osProfile.linuxConfiguration`:

```
ObjectWithOptionalAttrs(map[string]Type{
    "disablePasswordAuthentication": Bool,
    "enableVMAgentPlatformUpdates": Bool,
    "patchSettings": ObjectWithOptionalAttrs(map[string]Type{
        "assessmentMode": String,
        "automaticByPlatformSettings": ObjectWithOptionalAttrs(map[string]Type{
            "bypassPlatformSafetyChecksOnUserSchedule": Bool,
            "rebootSetting": String
        }, []string{"bypassPlatformSafetyChecksOnUserSchedule", "rebootSetting"}),
        "patchMode": String
    }, []string{"assessmentMode", "automaticByPlatformSettings", "patchMode"}),
    "provisionVMAgent": Bool,
    "ssh": ObjectWithOptionalAttrs(map[string]Type{
        "publicKeys": List(ObjectWithOptionalAttrs(map[string]Type{
            "keyData": String,
            "path": String
        }, []string{"keyData", "path"}))
    }, []string{"publicKeys"})
}, []string{
    "disablePasswordAuthentication",
    "enableVMAgentPlatformUpdates",
    "patchSettings",
    "provisionVMAgent",
    "ssh"
})
```

All properties are optional at the Azure API level.

## Hidden Fields Detection

### From Expand Function Analysis

Found **ONE hidden field** in the Azure API that is NOT exposed in the Terraform provider:

#### 1. `enableVMAgentPlatformUpdates`

**Evidence:** Present in Azure API schema but NOT in provider schema.

**Status:** Not exposed in the Terraform provider - will remain unmapped.

#### 2. `patchSettings.automaticByPlatformSettings`

**Evidence:** Present in Azure API schema but NOT set in the expand function.

**Provider Code:** The expand function only sets:
```go
patchSettings.AssessmentMode = pointer.To(virtualmachinescalesets.LinuxPatchAssessmentMode(input["patch_assessment_mode"].(string)))
patchSettings.PatchMode = pointer.To(virtualmachinescalesets.LinuxVMGuestPatchMode(input["patch_mode"].(string)))
linConfig.PatchSettings = &patchSettings
```

The `automaticByPlatformSettings` sub-object (containing `bypassPlatformSafetyChecksOnUserSchedule` and `rebootSetting`) is not exposed in the provider.

**Status:** Not exposed - will remain unmapped.

### Fields Set in Parent osProfile

From the expand function, several fields that appear to be part of `linuxConfiguration` are actually set at the parent `osProfile` level:

```go
osProfile.CustomData = pointer.To(customData)
osProfile.AdminUsername = pointer.To(input["admin_username"].(string))

if adminPassword := input["admin_password"].(string); adminPassword != "" {
    osProfile.AdminPassword = pointer.To(adminPassword)
}

if computerPrefix := input["computer_name_prefix"].(string); computerPrefix != "" {
    osProfile.ComputerNamePrefix = pointer.To(computerPrefix)
}

if secrets := input["secret"].([]interface{}); len(secrets) > 0 {
    osProfile.Secrets = expandLinuxSecretsVMSS(secrets)
}
```

**Important:** These fields are set at `osProfile` level, NOT inside `linuxConfiguration`:
- `adminUsername` → `osProfile.AdminUsername`
- `adminPassword` → `osProfile.AdminPassword`
- `computerNamePrefix` → `osProfile.ComputerNamePrefix`
- `secrets` → `osProfile.Secrets`

Only the following are set inside `linuxConfiguration`:
- `disablePasswordAuthentication`
- `provisionVMAgent`
- `patchSettings` (with `assessmentMode` and `patchMode`)
- `ssh.publicKeys`

### Hidden Fields Assignment

No hidden fields need to be assigned by this skeleton task. The structure is set up correctly to handle all exposed provider fields in their respective child tasks.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|---|---|---|
| linux_configuration | linuxConfiguration | Block wrapper |
| admin_username | *osProfile.adminUsername* | Task #99 - **Set at osProfile level** |
| admin_password | *osProfile.adminPassword* | Task #100 - **Set at osProfile level** |
| computer_name_prefix | *osProfile.computerNamePrefix* | Task #101 - **Set at osProfile level** |
| disable_password_authentication | disablePasswordAuthentication | Task #102 |
| patch_assessment_mode | patchSettings.assessmentMode | Task #103 |
| patch_mode | patchSettings.patchMode | Task #104 |
| provision_vm_agent | provisionVMAgent | Task #105 |
| admin_ssh_key | ssh.publicKeys | Tasks #106-108 |
| secret | *osProfile.secrets* | Tasks #109-112 - **Set at osProfile level** |

**Important Nesting Note:**
- Fields marked with asterisks are set at the **parent osProfile level**, NOT inside linuxConfiguration
- The expand function returns an osProfile object containing both parent-level fields and the nested linuxConfiguration
- Child tasks #99, #100, #101, #109-112 must place their values at `osProfile` level
- Child tasks #102, #103, #104, #105, #106-108 must place their values inside `linuxConfiguration`

## Special Handling

### Block Conditionality

The entire `linuxConfiguration` object is conditional based on whether `var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration` is not null.

### Mutual Exclusivity

From the parent os_profile (Task #96), `linux_configuration` and `windows_configuration` are mutually exclusive. Only one can be present at a time.

### Computer Name Prefix Defaulting

From the Create method, if `computer_name_prefix` is not set, it defaults to the scale set name:

```go
computerPrefix := ""
if config != nil {
    if v := config["computer_name_prefix"]; v != nil {
        computerPrefix = v.(string)
    }
}

if computerPrefix == "" {
    computerPrefix = d.Get("name").(string)
}
```

This defaulting logic will be handled in Task #101 (`computer_name_prefix`).

### Admin Username Linux Validation

The provider has a custom validation function `validateAdminUsernameLinux` which will need to be analyzed in Task #99.

### Admin Password Diff Suppression

The `admin_password` field has a `DiffSuppressFunc: adminPasswordDiffSuppressFunc` which suppresses diffs in certain conditions. This will be analyzed in Task #100.

### SSH Keys Set vs List

SSH keys are defined as a `TypeSet` with a custom hash function `SSHKeySchemaHash`. This ensures uniqueness and order independence. Task #106-108 will need to handle this properly.

### Secrets Structure

The `secret` block contains a `key_vault_id` and a set of `certificate` entries (each with a `url`). The expand function converts these to the Azure API format. Tasks #109-112 will handle the expansion.

## Validation

### Category 1 - Value Constraints

No direct value constraints for the block itself. Child fields have their own validations handled in respective tasks.

### Category 2 - Cross-Field Constraints

Not applicable at the block level. The mutual exclusivity with `windows_configuration` is handled at the parent `os_profile` level.

### Category 3 - Custom Logic

The expand function contains special logic for:
1. Default computer name prefix (handled in Task #101)
2. Password authentication validation (handled in Task #102)
3. SSH keys expansion (handled in Tasks #106-108)

## Critical Review & Edge Cases

### Null Semantics

- **`null` linux_configuration:** When `var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration` is `null`, the entire `linuxConfiguration` object is omitted from the API payload.
- **Empty linux_configuration:** The schema requires `admin_username` as required, so an empty block is not valid in Terraform.

### Boundary Conditions

1. **Required field `admin_username`:** Must be provided when linux_configuration is set
2. **Optional SSH keys:** Can be empty (no SSH keys), which is valid if password authentication is enabled
3. **Secrets:** Optional, can be empty or contain multiple entries

### Idempotency

The skeleton structure uses conditional merge patterns which are idempotent. The `!= null` check ensures the block is only added when explicitly configured.

### Safe References

All child field references will use safe navigation in their respective tasks. The skeleton assumes the parent `os_profile` object exists when `linux_configuration` is accessed.

### Edge Case: Parent-Level vs Nested Fields

**CRITICAL:** The expand function sets some fields at the **parent osProfile level** rather than inside linuxConfiguration:
- `adminUsername`, `adminPassword`, `computerNamePrefix`, `secrets` → Set at `osProfile` level
- Only `disablePasswordAuthentication`, `provisionVMAgent`, `patchSettings`, `ssh` → Set inside `linuxConfiguration`

This means child tasks must be aware of where to place their values:
- Tasks #99, #100, #101, #109-112: Place values at parent osProfile level (outside linuxConfiguration)
- Tasks #102, #103, #104, #105, #106-108: Place values inside linuxConfiguration

The skeleton structure created here is ONLY for the `linuxConfiguration` object itself. Child tasks that need to place values at the parent osProfile level must merge them at that level, not inside this linuxConfiguration block.

### Edge Case: OS Type Detection

From the Create method, the presence of `linux_configuration` sets the OS type:

```go
if len(linConfigRaw) > 0 && linConfigRaw[0] != nil {
    osType = virtualmachinescalesets.OperatingSystemTypesLinux
    // ...
}
```

This is automatically handled by the provider and doesn't require explicit mapping in the AzAPI resource.

## Child Tasks Ready for Delegation

The following child tasks are now **READY** for implementation as the parent skeleton structure is in place:

### Direct Children (Level 1) - Set at osProfile Level

**IMPORTANT:** These tasks place values at the **parent osProfile level**, NOT inside linuxConfiguration:

| Task # | Field | Type | Dependent On | Placement |
|--------|-------|------|--------------|-----------|
| 99 | os_profile.linux_configuration.admin_username | Argument | Skeleton #98 ✅ | osProfile.adminUsername |
| 100 | os_profile.linux_configuration.admin_password | Argument | Skeleton #98 ✅ | osProfile.adminPassword |
| 101 | os_profile.linux_configuration.computer_name_prefix | Argument | Skeleton #98 ✅ | osProfile.computerNamePrefix |
| 109 | os_profile.linux_configuration.secret | Block Skeleton | Skeleton #98 ✅ | osProfile.secrets |

### Direct Children (Level 1) - Set Inside linuxConfiguration

| Task # | Field | Type | Dependent On | Placement |
|--------|-------|------|--------------|-----------|
| 102 | os_profile.linux_configuration.disable_password_authentication | Argument | Skeleton #98 ✅ | linuxConfiguration |
| 103 | os_profile.linux_configuration.patch_assessment_mode | Argument | Skeleton #98 ✅ | linuxConfiguration.patchSettings |
| 104 | os_profile.linux_configuration.patch_mode | Argument | Skeleton #98 ✅ | linuxConfiguration.patchSettings |
| 105 | os_profile.linux_configuration.provision_vm_agent | Argument | Skeleton #98 ✅ | linuxConfiguration |
| 106 | os_profile.linux_configuration.admin_ssh_key | Block Skeleton | Skeleton #98 ✅ | linuxConfiguration.ssh |

### Note on Task Ordering

1. **Independent Tasks (Parallel):** Tasks #99-105 can proceed in parallel as they are independent arguments
2. **Block Skeleton Tasks:** Task #106 (admin_ssh_key) and #109 (secret) are block skeletons that enable their respective children
3. **Placement Awareness:** Implementers MUST check the "Placement" column to know where to merge their values

### Nested Children (Level 2)

These tasks depend on their parent block skeletons:

| Task # | Field | Type | Dependent On |
|--------|-------|------|--------------|
| 107 | os_profile.linux_configuration.admin_ssh_key.public_key | Argument | Skeleton #106 |
| 108 | os_profile.linux_configuration.admin_ssh_key.username | Argument | Skeleton #106 |
| 110 | os_profile.linux_configuration.secret.key_vault_id | Argument | Skeleton #109 |
| 111 | os_profile.linux_configuration.secret.certificate | Block Skeleton | Skeleton #109 |
| 112 | os_profile.linux_configuration.secret.certificate.url | Argument | Skeleton #111 |

## Completion Checklist

- ✅ Property in correct local (`local.body`)
- ✅ Block structure skeleton created with comment placeholders
- ✅ Conditional logic based on variable null check
- ✅ ForceNew: Not applicable to block structure
- ✅ Validations: No validations at block level (handled by children)
- ✅ Hidden fields identified and documented
- ✅ Critical review completed
- ✅ Edge case analysis included (parent vs nested placement)
- ✅ Proof document created
- ✅ `track.md` will be updated
- ✅ Self-Review: Only skeleton structure created, no child implementations

## Notes

1. **Skeleton Only:** This task creates ONLY the block structure framework. Child fields (#99-112) will be implemented in their respective tasks.

2. **Critical Placement Distinction:** Some fields from the `linux_configuration` schema are actually placed at the parent `osProfile` level in the Azure API:
   - Parent level: adminUsername, adminPassword, computerNamePrefix, secrets
   - Nested level: disablePasswordAuthentication, provisionVMAgent, patchSettings, ssh

3. **Patch Settings Structure:** Tasks #103 and #104 will both contribute to the `patchSettings` object. They must use a shared merge pattern.

4. **SSH Keys:** The admin_ssh_key field is a TypeSet in Terraform but maps to an array in the Azure API. Task #106 will need to handle the conversion properly.

5. **Computer Name Defaulting:** Task #101 must implement the defaulting logic to use the scale set name if not provided.

6. **Password vs SSH Authentication:** The `disable_password_authentication` field controls whether passwords or SSH keys are used. Validation logic exists in the Create method that Task #102 should replicate.

7. **Extension Operations Coordination:** From Task #96, the `extension_operations_enabled` validation checks against `provision_vm_agent`. Task #105 should document this relationship.

8. **No Direct API Mapping:** Unlike most nested blocks, this block's fields are split between parent and nested levels. Child task implementers must carefully review the expand function to determine correct placement.
