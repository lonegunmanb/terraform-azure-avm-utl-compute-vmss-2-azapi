# Task #143: rolling_upgrade_policy.max_unhealthy_instance_percent

## Shadow Implementation

```hcl
locals {
  body = {
    properties = merge(
      var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy != null ? {
        upgradePolicy = {
          rollingUpgradePolicy = {
            maxBatchInstancePercent = var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.max_batch_instance_percent
            maxUnhealthyInstancePercent = var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.max_unhealthy_instance_percent # <-
          }
        }
      } : {},
    )
  }
}
```

## Summary

Implemented `rolling_upgrade_policy.max_unhealthy_instance_percent` field by replacing the comment placeholder on line 216 of migrate_main.tf. This required integer field specifies the maximum percentage of total virtual machine instances that can be simultaneously unhealthy before the rolling upgrade aborts.

## Create Phase Verification

**Query**: `query_terraform_block_implementation_source_code(block_type="resource", entrypoint_name="create", terraform_type="azurerm_orchestrated_virtual_machine_scale_set")`

**Pattern Identification**: Single-phase creation using `CreateOrUpdateThenPoll`

**Field Classification**: Create phase (assigned before `CreateOrUpdateThenPoll` call)

**Go Code Evidence**:
```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
  // ...
  upgradeMode := virtualmachinescalesets.UpgradeMode(d.Get("upgrade_mode").(string))
  rollingUpgradePolicy, err := ExpandVirtualMachineScaleSetRollingUpgradePolicy(d.Get("rolling_upgrade_policy").([]interface{}), len(zones) > 0, false)
  if err != nil {
    return fmt.Errorf("expanding `rolling_upgrade_policy`: %w", err)
  }

  props.Properties.UpgradePolicy = &virtualmachinescalesets.UpgradePolicy{
    Mode:                 pointer.To(upgradeMode),
    RollingUpgradePolicy: rollingUpgradePolicy,
  }
  // ...
  if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
  }
  // ...
}
```

**Decision**: Implement in `local.body` (Create phase)

## Assignment Path Verification

**Predicted Path**: `properties.upgradePolicy.rollingUpgradePolicy.maxUnhealthyInstancePercent`

**Tracing**:
1. `props` is type `virtualmachinescalesets.VirtualMachineScaleSet`
2. `props.Properties` is assigned to `&virtualmachinescalesets.VirtualMachineScaleSetProperties{...}`
3. `props.Properties.UpgradePolicy` is assigned to `&virtualmachinescalesets.UpgradePolicy{...}`
4. `props.Properties.UpgradePolicy.RollingUpgradePolicy` is returned from `ExpandVirtualMachineScaleSetRollingUpgradePolicy`

**Go Code Evidence from Expand Function**:
```go
func ExpandVirtualMachineScaleSetRollingUpgradePolicy(input []interface{}, isZonal, overProvision bool) (*virtualmachinescalesets.RollingUpgradePolicy, error) {
  if len(input) == 0 {
    return nil, nil
  }

  raw := input[0].(map[string]interface{})

  rollingUpgradePolicy := &virtualmachinescalesets.RollingUpgradePolicy{
    MaxBatchInstancePercent:             pointer.To(int64(raw["max_batch_instance_percent"].(int))),
    MaxUnhealthyInstancePercent:         pointer.To(int64(raw["max_unhealthy_instance_percent"].(int))),
    MaxUnhealthyUpgradedInstancePercent: pointer.To(int64(raw["max_unhealthy_upgraded_instance_percent"].(int))),
    PauseTimeBetweenBatches:             pointer.To(raw["pause_time_between_batches"].(string)),
    PrioritizeUnhealthyInstances:        pointer.To(raw["prioritize_unhealthy_instances_enabled"].(bool)),
    MaxSurge:                            pointer.To(raw["maximum_surge_instances_enabled"].(bool)),
  }
  // ...
  return rollingUpgradePolicy, nil
}
```

**Verified Path**: `properties.upgradePolicy.rollingUpgradePolicy.maxUnhealthyInstancePercent`

**Path Comparison**: ✅ Match - Predicted path matches implementation

## Provider Schema

**Source**: `query_terraform_block_implementation_source_code(block_type="resource", entrypoint_name="schema", terraform_type="azurerm_orchestrated_virtual_machine_scale_set")`

**Schema Definition**:
```go
func VirtualMachineScaleSetRollingUpgradePolicySchema() *pluginsdk.Schema {
  return &pluginsdk.Schema{
    Type:     pluginsdk.TypeList,
    Optional: true,
    ForceNew: true,
    MaxItems: 1,
    Elem: &pluginsdk.Resource{
      Schema: map[string]*pluginsdk.Schema{
        // ...
        "max_unhealthy_instance_percent": {
          Type:     pluginsdk.TypeInt,
          Required: true,
        },
        // ...
      },
    },
  }
}
```

**Field Properties**:
- **Type**: `TypeInt`
- **Required**: `true`
- **ForceNew**: `true` (at block level)
- **ValidateFunc**: None (no built-in validation in provider schema)

## Azure API Schema

**Resource Type**: `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

**Property Path**: `properties.upgradePolicy.rollingUpgradePolicy.maxUnhealthyInstancePercent`

**Schema Type**: `Number` (all fields in rollingUpgradePolicy are optional at API level)

**API Structure** (from Task #142 proof):
```
upgradePolicy: ObjectWithOptionalAttrs({
  rollingUpgradePolicy: ObjectWithOptionalAttrs({
    maxBatchInstancePercent: Number,
    maxUnhealthyInstancePercent: Number,
    maxUnhealthyUpgradedInstancePercent: Number,
    pauseTimeBetweenBatches: String,
    enableCrossZoneUpgrade: Bool,
    maxSurge: Bool,
    prioritizeUnhealthyInstances: Bool
  })
})
```

## Hidden Fields

None. The field is directly exposed in the provider schema.

## Mapping

**Terraform (snake_case)**: `max_unhealthy_instance_percent`
**Azure API (camelCase)**: `maxUnhealthyInstancePercent`

## Special Handling

### ForceNew Handling

- **Block-level ForceNew**: The entire `rolling_upgrade_policy` block has `ForceNew: true` (handled in Task #141)
- **Field-level ForceNew**: Not applicable - no field-specific ForceNew logic
- **Implementation**: Not required for this field as the block-level ForceNew in `replace_triggers_external_values` handles all fields within the block

### Validation

**Provider Schema**: No built-in validation function in the provider schema.

**Implementation Decision**: No validation added. The field accepts any integer value:
- Azure API documentation describes it as a percentage but doesn't specify explicit range constraints in the schema
- The provider doesn't enforce percentage range validation (0-100)
- Following exact provider behavior: no validation

### Sensitive/WriteOnly

**Status**: Not sensitive or write-only
**Implementation**: Field value placed in `local.body` (not `local.sensitive_body`)

## Deferred Work Completion

**Check**: Reviewed `following.md` for any work deferred to Task #143.

**Result**: No deferred work found for this task.

## Critical Review & Edge Case Analysis

### Null Semantics
- **Null at field level**: Not possible - field is `Required: true` within the parent object
- **Null at parent level**: When `var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy` is `null`, the entire `upgradePolicy.rollingUpgradePolicy` object is omitted via conditional `? : {}` merge pattern
- **API behavior**: When omitted, Azure uses default upgrade behavior (no rolling upgrade policy applied)

### Edge Cases
1. **Zero value (0)**: Valid integer accepted by provider and API, though semantically questionable (means no unhealthy instances allowed)
2. **Negative values**: Provider schema doesn't validate against negatives; Azure API likely rejects these
3. **Values > 100**: Provider schema doesn't validate percentage range; Azure API may accept values > 100 or reject them
4. **Large integers**: No explicit bounds checking in provider; subject to API limits

**Design Decision**: Following exact provider behavior - no validation constraints added. Azure API will validate actual value constraints at deployment time.

### Idempotency
- **Configuration stability**: Direct value assignment from variable ensures stable configuration
- **No ordering concerns**: Single integer value has no ordering dependencies
- **Terraform plan stability**: Value changes detected correctly via standard Terraform diff mechanism

### Safe References
- **Null safety**: Field access protected by parent null check: `var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy != null`
- **Type safety**: Variable type constraint ensures `max_unhealthy_instance_percent` is present as `number` when parent object is non-null
- **No nested access risk**: Direct property access on validated non-null parent object

## Checklist

- ✅ Property in correct local (`local.body.properties`)
- ✅ Comment placeholder replaced with implementation
- ✅ No ForceNew wrapping needed (block-level ForceNew handles all fields)
- ✅ All logic exactly replicated from provider (direct value pass-through)
- ✅ No validations added (matching provider behavior - no validation in schema)
- ✅ No TODO comment needed (not a sensitive field migration)
- ✅ No hidden fields detected
- ✅ Deferred work checked: No work deferred to this task
- ✅ Critical review completed: Null semantics, edge cases, idempotency, safe references analyzed
- ✅ Edge Case Analysis section included in proof
- ✅ Proof document created
- ✅ track.md will be updated to "Pending for check"
- ✅ Self-Review: Only Task #143 implementation added, no other task content included

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #143 - rolling_upgrade_policy.max_unhealthy_instance_percent

### Validation Results

✅ **ForceNew Logic:** Block-level ForceNew correctly implemented in `replace_triggers_external_values` (line 170) wrapping entire `rolling_upgrade_policy` object
✅ **Stable Keys:** Block-level ForceNew key is stable (always present)
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase) 
✅ **Type Conversion:** Direct integer pass-through, no conversion needed
✅ **Null Handling:** Correctly protected by parent null check `var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy != null`
✅ **Validations:** None required - provider schema has no validations for this field
✅ **Shared Path Merge:** No merge conflicts - field is within the same `rollingUpgradePolicy` block as Task #142
✅ **Deferred Work Completion:** No deferred work for this task (verified in following.md)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed (null semantics, zero values, negative values, values > 100)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The field is a required integer within the parent object, with no validation constraints in the provider schema. The implementation:
- Uses direct value assignment from the variable
- Relies on block-level ForceNew in `replace_triggers_external_values` (no field-level ForceNew needed)
- Correctly placed in Create phase (`local.body`)
- Protected by parent null check preventing invalid access
- Matches exact provider behavior: no validation added (provider has no ValidateFunc)

**Status:** APPROVED ✅

---
