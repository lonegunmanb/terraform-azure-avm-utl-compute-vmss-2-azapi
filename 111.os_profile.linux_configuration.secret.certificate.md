# Task #111: os_profile.linux_configuration.secret.certificate - Block Structure Skeleton

## Summary
Created the structure skeleton for the `certificate` block within `os_profile.linux_configuration.secret`. This is a Required block (MinItems: 1) containing certificate configurations. Individual field implementations are delegated to child tasks.

## Shadow Implementation
```hcl
vaultCertificates = [
  for certificate in secret.certificate : {
    # certificateUrl = ... # Task #112
  }
]
```

## Create Phase Verification

**Query:** `query_terraform_block_implementation_source_code` with `entrypoint_name=create`

**Pattern Identification:** Single-phase creation pattern

```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    // ...
    if len(linConfigRaw) > 0 && linConfigRaw[0] != nil {
        linConfig := linConfigRaw[0].(map[string]interface{})
        vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration(linConfig, customData)
        // ...
    }
    
    virtualMachineProfile.OsProfile = vmssOsProfile
    
    // ...
    props.Properties.VirtualMachineProfile = &virtualMachineProfile
    
    if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
        return fmt.Errorf("creating Orchestrated %s: %w", id, err)
    }
}
```

**Classification:** The `certificate` block is part of the `osProfile` which is set BEFORE the `CreateOrUpdateThenPoll` call, meaning it's in the **Create phase**. No two-phase pattern detected.

**Decision:** Implement in `local.body`

## Assignment Path Verification

**Predicted Path:** `properties.virtualMachineProfile.osProfile.secrets[].vaultCertificates`

**Provider Code Evidence:**

1. **Expand function** (`expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration`):
```go
func expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration(input map[string]interface{}, customData string) *virtualmachinescalesets.VirtualMachineScaleSetOSProfile {
    osProfile := virtualmachinescalesets.VirtualMachineScaleSetOSProfile{}
    
    if secrets := input["secret"].([]interface{}); len(secrets) > 0 {
        osProfile.Secrets = expandLinuxSecretsVMSS(secrets)
    }
    
    return &osProfile
}
```

2. **Secret expand function** (`expandLinuxSecretsVMSS`):
```go
func expandLinuxSecretsVMSS(input []interface{}) *[]virtualmachinescalesets.VaultSecretGroup {
    output := make([]virtualmachinescalesets.VaultSecretGroup, 0)
    
    for _, raw := range input {
        v := raw.(map[string]interface{})
        
        keyVaultId := v["key_vault_id"].(string)
        certificatesRaw := v["certificate"].(*pluginsdk.Set).List()
        certificates := make([]virtualmachinescalesets.VaultCertificate, 0)
        for _, certificateRaw := range certificatesRaw {
            certificateV := certificateRaw.(map[string]interface{})
            
            url := certificateV["url"].(string)
            certificates = append(certificates, virtualmachinescalesets.VaultCertificate{
                CertificateURL: pointer.To(url),
            })
        }
        
        output = append(output, virtualmachinescalesets.VaultSecretGroup{
            SourceVault: &virtualmachinescalesets.SubResource{
                Id: pointer.To(keyVaultId),
            },
            VaultCertificates: &certificates,
        })
    }
    
    return &output
}
```

3. **Assignment in Create**:
```go
// In resourceOrchestratedVirtualMachineScaleSetCreate
virtualMachineProfile.OsProfile = vmssOsProfile  // <- osProfile contains Secrets
props.Properties.VirtualMachineProfile = &virtualMachineProfile  // <- adds virtualMachineProfile nesting
```

**Verified Path:** `properties.virtualMachineProfile.osProfile.secrets[].vaultCertificates`

**Path Comparison:** ✅ Match - Predicted path matches verified path

## Provider Schema

```go
func linuxSecretSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "key_vault_id": commonschema.ResourceIDReferenceRequired(&commonids.KeyVaultId{}),
                
                // whilst we /could/ flatten this to `certificate_urls` we're intentionally not to keep this
                // closer to the Windows VMSS resource, which will also take a `store` param
                "certificate": {
                    Type:     pluginsdk.TypeSet,
                    Required: true,
                    MinItems: 1,
                    Elem: &pluginsdk.Resource{
                        Schema: map[string]*pluginsdk.Schema{
                            "url": {
                                Type:         pluginsdk.TypeString,
                                Required:     true,
                                ValidateFunc: keyVaultValidate.NestedItemId,
                            },
                        },
                    },
                },
            },
        },
    }
}
```

**Key Details:**
- Type: Set (list in schema)
- Required: true
- MinItems: 1
- Contains single field: `url` (Required)

## Azure API Schema

**Resource Type:** `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

**Property Path:** `body.properties.virtualMachineProfile.osProfile.secrets[].vaultCertificates`

**Schema Type:** Array of objects containing certificate configurations

**Description:** "Specifies set of certificates that should be installed onto the virtual machines in the scale set."

## Hidden Fields

**Query:** Searched expand function `expandLinuxSecretsVMSS`

**Finding:** No hidden fields detected. The expand function only processes the `url` field from the certificate block and maps it to `CertificateURL` in the API.

**Evidence:**
```go
for _, certificateRaw := range certificatesRaw {
    certificateV := certificateRaw.(map[string]interface{})
    
    url := certificateV["url"].(string)
    certificates = append(certificates, virtualmachinescalesets.VaultCertificate{
        CertificateURL: pointer.To(url),  // Only field used
    })
}
```

## Mapping

| Terraform Field | Azure API Property |
|-----------------|-------------------|
| `certificate` (set) | `vaultCertificates` (array) |

**Naming Convention:** 
- Terraform: snake_case `certificate`
- Azure API: camelCase `vaultCertificates`

## Special Handling

### Block Structure
- **Type:** Set in schema, implemented as array in API
- **Required:** Yes (MinItems: 1)
- **Cardinality:** Multiple certificates can be specified per secret

### ForceNew
Not applicable for block skeleton - individual fields may have ForceNew behavior

### Sensitive
Not applicable for block structure itself

### Validation
Block-level validation:
- MinItems: 1 (at least one certificate required)

### Post-Creation Updates
Not applicable - single-phase creation

## Child Tasks Ready for Delegation

Based on the schema and expand function analysis, the following child task is now ready:

| Task # | Field | Type | Required | Status |
|--------|-------|------|----------|--------|
| 112 | os_profile.linux_configuration.secret.certificate.url | Argument | Yes | Ready |

## Critical Review & Edge Case Analysis

### Null Semantics
- **Parent Block (`secret`):** When `secret` is null or empty list, entire `secrets` property is omitted (handled by parent task #109)
- **This Block (`certificate`):** Provider schema has MinItems: 1, so empty certificate set is invalid
- **Implementation:** Uses `for` loop over `secret.certificate`, automatically handles null by producing empty array when parent is null

### Edge Cases
1. **Empty Certificate Set:** Schema validation (MinItems: 1) prevents empty set at provider level
2. **Multiple Certificates:** Supported - expand function iterates over all certificates in set
3. **Set vs List:** Terraform schema uses Set, but API expects array - `for` loop handles conversion

### Idempotency
✅ **Guaranteed:** The `for` loop iterates over `secret.certificate` set, producing consistent array output. Set ordering in Terraform is stable based on element hash.

### Safe References
✅ **All references safe:**
- `secret.certificate` is safely accessed within parent condition checking secret existence
- Parent condition: `var...secret != null && length(var...secret) > 0`
- Inner loop references `certificate` which is guaranteed to exist due to MinItems: 1 validation

### Block Framework Correctness
✅ **Proper structure:**
- Nested within parent `secrets` array using `for secret in`
- Creates `vaultCertificates` array for each secret
- Inner `for certificate in` loop ready for Task #112 to populate properties

## Checklist

- ✅ Block skeleton created in correct local (`local.body`)
- ✅ Proper conditional structure (handled by parent task #109)
- ✅ Comment placeholders for child fields added
- ✅ Hidden fields checked (none found)
- ✅ Child tasks identified and documented (#112)
- ✅ Critical review completed (null semantics, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis section included
- ✅ Assignment path verified with full trace
- ✅ Create phase verified (single-phase, Create phase)
- ✅ Proof document created
- ✅ track.md will be updated to "Pending for check"
- ✅ Self-review: Only block skeleton added, no individual field implementations

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #111 - os_profile.linux_configuration.secret.certificate

### Validation Results

✅ **Block Structure:** Correctly creates skeleton for `vaultCertificates` array within parent `secrets` array
✅ **Nesting:** Properly nested within parent condition from Task #109
✅ **Comment Placeholders:** Task #112 placeholder correctly added for child field `certificateUrl`
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase, single-phase pattern)
✅ **Hidden Fields:** Comprehensive expand function analysis completed - no hidden fields found
✅ **Naming Convention:** Correct transformation from `certificate` (snake_case) to `vaultCertificates` (camelCase)
✅ **Type Conversion:** Proper Set to Array conversion using `for` loop
✅ **Assignment Path:** Full trace verification completed with all struct assignments documented
✅ **Deferred Work Completion:** No deferred work for this task in following.md
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed (null semantics, empty sets, idempotency, safe references)
✅ **Scope Compliance:** Only block skeleton implemented, no field implementations added (correctly delegated to Task #112)

### Compliance Statement

This implementation EXACTLY follows Type 3 Block Structure Skeleton requirements from `executor.md`. The block skeleton correctly:
- Creates conditional structure inherited from parent
- Uses `for` loop for Set to Array conversion
- Adds comment placeholder for child field
- Maintains proper nesting within `secrets` array
- Delegates field implementation to Task #112

No deviations, simplifications, or scope violations found.

**Status:** APPROVED ✅

---
