# Task #137 - plan.publisher - COMPLETED

## Summary

Implemented the Required argument `plan.publisher` (string) within the existing `plan` block skeleton. The field is a simple string with no validations, directly mapped to the Azure API `publisher` field. The field is ForceNew and tracked in `replace_triggers_external_values`.

## Shadow Implementation

```hcl
locals {
  body = merge(
    # ... existing body content ...
    var.orchestrated_virtual_machine_scale_set_plan != null ? {
      plan = {
        name = var.orchestrated_virtual_machine_scale_set_plan.name
        product = var.orchestrated_virtual_machine_scale_set_plan.product
        publisher = var.orchestrated_virtual_machine_scale_set_plan.publisher # <-
      }
    } : {}
  )

  replace_triggers_external_values = {
    # ... existing triggers ...
    plan_name = { value = var.orchestrated_virtual_machine_scale_set_plan != null ? var.orchestrated_virtual_machine_scale_set_plan.name : "" }
    plan_product = { value = var.orchestrated_virtual_machine_scale_set_plan != null ? var.orchestrated_virtual_machine_scale_set_plan.product : "" }
    plan_publisher = { value = var.orchestrated_virtual_machine_scale_set_plan != null ? var.orchestrated_virtual_machine_scale_set_plan.publisher : "" } # <-
  }
}
```

## Create Phase Verification

### Query Create Method

Queried `resourceOrchestratedVirtualMachineScaleSetCreate` function:

```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	isLegacy := true
	// ...
	
	// Only inclued the virtual machine profile if this is not a legacy configuration
	if !isLegacy {
		if v, ok := d.GetOk("plan"); ok {
			props.Plan = expandPlanVMSS(v.([]interface{}))
		}
		// ...
	}
	// ...
	
	log.Printf("[DEBUG] Creating Orchestrated %s.", id)
	if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
		return fmt.Errorf("creating Orchestrated %s: %w", id, err)
	}
}
```

### Pattern Analysis

**Pattern:** Single-phase Create

The `plan.publisher` field is:
1. Read from Terraform config via `d.GetOk("plan")`
2. Expanded using `expandPlanVMSS()`
3. Assigned to `props.Plan` before the create API call
4. Sent in the initial `CreateOrUpdateThenPoll()` call

**Classification:** Create Phase - field is set before the create call and included in the initial API request.

**Decision:** Implement in `local.body` (NOT in `local.post_creation_updates`).

## Assignment Path Verification

### Predicted Path

`body.plan.publisher`

### Go Code Evidence - expandPlanVMSS Function

```go
func expandPlanVMSS(input []interface{}) *virtualmachinescalesets.Plan {
	if len(input) == 0 || input[0] == nil {
		return nil
	}

	raw := input[0].(map[string]interface{})

	return &virtualmachinescalesets.Plan{
		Name:      pointer.To(raw["name"].(string)),
		Product:   pointer.To(raw["product"].(string)),
		Publisher: pointer.To(raw["publisher"].(string)),
	}
}
```

### Go Code Evidence - Assignment in Create Method

```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	props := virtualmachinescalesets.VirtualMachineScaleSet{
		Location: location.Normalize(d.Get("location").(string)),
		Tags:     tags.Expand(t),
		Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
			// ...
		},
	}
	
	// ...
	
	if v, ok := d.GetOk("plan"); ok {
		props.Plan = expandPlanVMSS(v.([]interface{}))  // Direct assignment to props.Plan
	}
	// ...
}
```

### Verified Path

The `expandPlanVMSS` function creates a `virtualmachinescalesets.Plan` object with `Name`, `Product`, and `Publisher` fields. The `Publisher` field is set from `raw["publisher"].(string)`.

This is assigned directly to `props.Plan`. In the Azure API, the `plan` is a root-level field in the Virtual Machine Scale Set resource, NOT nested under `properties`.

**Verified Path:** `body.plan.publisher`

### Path Comparison

- **Predicted:** `body.plan.publisher` ✅
- **Verified:** `body.plan.publisher` ✅
- **Match:** YES

## Provider Schema

From `planSchema()` function:

```go
func planSchema() *pluginsdk.Schema {
	return &pluginsdk.Schema{
		Type:     pluginsdk.TypeList,
		Optional: true,
		ForceNew: true,
		MaxItems: 1,
		Elem: &pluginsdk.Resource{
			Schema: map[string]*pluginsdk.Schema{
				"name": {
					Type:     pluginsdk.TypeString,
					Required: true,
					ForceNew: true,
				},

				"product": {
					Type:     pluginsdk.TypeString,
					Required: true,
					ForceNew: true,
				},

				"publisher": {
					Type:     pluginsdk.TypeString,
					Required: true,
					ForceNew: true,
				},
			},
		},
	}
}
```

**Key Properties:**
- Type: TypeString
- Required: true
- ForceNew: true
- No validations
- No default value
- No DiffSuppressFunc
- No ConflictsWith/RequiredWith

## Azure API Schema

From Azure API schema for `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`:

```
body.plan: ObjectWithOptionalAttrs(map[string]Type{
  "name": String,
  "product": String, 
  "promotionCode": String,
  "publisher": String
}, []string{"name", "product", "promotionCode", "publisher"})
```

**Azure API Field:**
- `publisher` (string) - The publisher ID
- Located at `body.plan.publisher` (root level of body, NOT under properties)
- All fields in plan are optional in API schema

## Hidden Fields

None. The `expandPlanVMSS` function only maps the three fields exposed in the Terraform schema (name, product, publisher). The Azure API also has a `promotionCode` field, but it's not exposed in Terraform and was handled in the parent skeleton task (#134).

## Mapping (snake_case → camelCase)

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|------------------------|----------------------|-------|
| publisher | publisher | Direct mapping, no conversion needed |

## Special Handling

### ForceNew

The field is marked as `ForceNew: true` in the provider schema. This means any change to `plan.publisher` will trigger resource replacement.

**Implementation:** Added to `replace_triggers_external_values` with stable key:

```hcl
plan_publisher = { value = var.orchestrated_virtual_machine_scale_set_plan != null ? var.orchestrated_virtual_machine_scale_set_plan.publisher : "" }
```

**Key Stability:** The key `plan_publisher` is always present in the map. When `plan` block is null, the value is an empty string. This ensures the key doesn't appear/disappear across applies.

### Validations

**Provider Validations:** None

The provider schema shows:
- Type: TypeString
- Required: true
- No ValidateFunc
- No validation logic in expand function
- No validation logic in Create method

**Conclusion:** No validations to implement in `variables.tf`.

### Sensitive/WriteOnly

**Provider Schema:** No `Sensitive: true` flag
**Azure API:** Field is not marked as WriteOnly

**Conclusion:** Field goes in `local.body` (NOT `local.sensitive_body`).

## Deferred Work Completion

Checked `following.md` for any work deferred to Task #137: None found.

## Critical Review & Edge Case Analysis

### Null Semantics

- **Field is null:** Not possible - field is Required in schema
- **Parent block is null:** Handled by conditional `var.orchestrated_virtual_machine_scale_set_plan != null` in skeleton (Task #134)
- **Empty string:** Allowed by schema (TypeString with no validations). Empty string is a valid publisher value.

### Boundary Conditions

- **Empty string:** Valid - no minimum length validation in provider
- **Very long string:** No maximum length validation in provider schema
- **Special characters:** No character restrictions in provider schema
- **Required field:** Schema enforces this - Terraform will validate before our module receives the value

### Idempotency

- Simple string field - no ordering concerns
- Direct assignment - no transformation logic
- Same input always produces same output

### Safe References

- Parent conditional check `var.orchestrated_virtual_machine_scale_set_plan != null` ensures plan object exists before accessing `.publisher`
- Field is Required in schema, so `.publisher` will always be present when plan object exists
- No nested null checks needed

### ForceNew Stability

- Used stable key wrapping: `plan_publisher = { value = ... }`
- Key is always present in map (empty string when plan is null)
- Prevents false replacements due to key appearance/disappearance

## Checklist

- ✅ Property in correct local (`local.body.plan.publisher`)
- ✅ ForceNew tracked in `replace_triggers_external_values` with stable key
- ✅ Assignment path verified (`body.plan.publisher` matches provider behavior)
- ✅ No validations to implement (none in provider schema)
- ✅ Not sensitive (goes in `body`, not `sensitive_body`)
- ✅ No hidden fields for this specific field
- ✅ No deferred work to complete from `following.md`
- ✅ No work to defer to other tasks
- ✅ Critical review completed (null semantics, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis section included
- ✅ Comment placeholder replaced in skeleton
- ✅ Create phase verified (single-phase, Create phase)
- ✅ Proof document created
- ✅ Only Task #137 scope implemented (no other fields added)
- ✅ Implementation exactly replicates provider behavior

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #137 - plan.publisher

### Validation Results

✅ **ForceNew Logic:** Simple ForceNew (schema `ForceNew: true`) correctly implemented with stable key wrapping in `replace_triggers_external_values`
✅ **Stable Keys:** Key `plan_publisher` is always present in map, uses empty string when plan is null (no appearance/disappearance)
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase, single-phase pattern)
✅ **Type Conversion:** Direct string assignment, no conversion needed
✅ **Null Handling:** Parent conditional check ensures safe access; field is Required so always present when parent exists
✅ **Validations:** None required (provider schema has no validations for publisher field)
✅ **Sensitive/WriteOnly Handling:** Correctly placed in `body` (NOT `sensitive_body`) - field is not sensitive
✅ **Assignment Path:** Correctly placed at `body.plan.publisher` (plan is root-level in Azure API, not under properties)
✅ **Shared Path Merge Check:** Plan block appears only once at root level (lines 648-654), no duplicate keys, no merge conflicts
✅ **Deferred Work Completion:** No deferred work for this task (checked `following.md`)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Scope Compliance:** Only implements plan.publisher field (Task #137), no content from other tasks added
✅ **Edge Cases:** All edge cases properly analyzed (null semantics, boundary conditions, idempotency, safe references)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The field is:
- A Required string argument within the plan block
- Marked as ForceNew in provider schema
- Directly mapped to Azure API `publisher` field at `body.plan.publisher`
- Has no validations in provider schema
- Not sensitive/writeonly

The implementation uses stable key wrapping for ForceNew tracking, ensuring the key is always present to prevent false replacements. The proof document contains all required sections with proper Go code evidence. No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
