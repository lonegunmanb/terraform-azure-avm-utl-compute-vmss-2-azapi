# Task #46 - extension.type

## Shadow Implementation

**File: `migrate_main.tf`**

```hcl
locals {
  body = {
    properties = merge(
      var.orchestrated_virtual_machine_scale_set_sku_name != null ? {
        virtualMachineProfile = merge(
          var.orchestrated_virtual_machine_scale_set_extension != null || var.orchestrated_virtual_machine_scale_set_extensions_time_budget != null ? {
            extensionProfile = merge(
              var.orchestrated_virtual_machine_scale_set_extension != null ? {
                extensions = [
                  for ext in var.orchestrated_virtual_machine_scale_set_extension : {
                    name = ext.name
                    properties = {
                      publisher = ext.publisher
                      type      = ext.type # <-
                      # typeHandlerVersion = ... # Task #47
                      # ... other fields
                    }
                  }
                ]
              } : {},
              # ... extensions_time_budget merge
            )
          } : {}
        )
      } : {}
    )
  }
}
```

**File: `variables.tf`**

```hcl
variable "orchestrated_virtual_machine_scale_set_extension" {
  type = set(object({
    # ... other fields
    type = string # <-
    # ... other fields
  }))
  
  validation { # <-
    condition = ( # <-
      var.orchestrated_virtual_machine_scale_set_extension == null || # <-
      alltrue([for ext in var.orchestrated_virtual_machine_scale_set_extension : ext.type != ""]) # <-
    ) # <-
    error_message = "The extension type must not be empty." # <-
  } # <-
}
```

## Summary

Implemented `extension.type` field which maps to `properties.virtualMachineProfile.extensionProfile.extensions[].properties.type` in Azure API. The field is Required with StringIsNotEmpty validation in the provider schema. The type value is also used by the provider for health extension detection.

## Create Phase Verification

### Query Create Method

From `resourceOrchestratedVirtualMachineScaleSetCreate` source code:

```go
if v, ok := d.GetOk("extension"); ok {
    var err error
    virtualMachineProfile.ExtensionProfile, hasHealthExtension, err = expandOrchestratedVirtualMachineScaleSetExtensions(v.(*pluginsdk.Set).List())
    if err != nil {
        return err
    }
}

// Later in the Create method (before CreateOrUpdateThenPoll):
if !isLegacy {
    props.Properties.VirtualMachineProfile = &virtualMachineProfile
}

log.Printf("[DEBUG] Creating Orchestrated %s.", id)
if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Pattern:** Single-phase creation pattern. Extension data is expanded via `expandOrchestratedVirtualMachineScaleSetExtensions` and assigned to `virtualMachineProfile.ExtensionProfile` which is then assigned to `props.Properties.VirtualMachineProfile` before the `CreateOrUpdateThenPoll` call.

**Classification:** Create phase - field is set before the create API call.

**Decision:** Implement in `local.body` (NOT in `local.post_creation_updates`).

## Assignment Path Verification

### Predicted Path

`properties.virtualMachineProfile.extensionProfile.extensions[].properties.type`

### Go Code Evidence

From `expandOrchestratedVirtualMachineScaleSetExtensions` function:

```go
func expandOrchestratedVirtualMachineScaleSetExtensions(input []interface{}) (extensionProfile *virtualmachinescalesets.VirtualMachineScaleSetExtensionProfile, hasHealthExtension bool, err error) {
    extensionProfile = &virtualmachinescalesets.VirtualMachineScaleSetExtensionProfile{}
    if len(input) == 0 {
        return nil, false, nil
    }

    extensions := make([]virtualmachinescalesets.VirtualMachineScaleSetExtension, 0)
    for _, v := range input {
        extensionRaw := v.(map[string]interface{})
        extension := virtualmachinescalesets.VirtualMachineScaleSetExtension{
            Name: pointer.To(extensionRaw["name"].(string)),
        }
        extensionType := extensionRaw["type"].(string) // <- Extracts type into variable
        
        autoUpgradeMinorVersion, _ := extensionRaw["auto_upgrade_minor_version_enabled"].(bool)
        
        extensionProps := virtualmachinescalesets.VirtualMachineScaleSetExtensionProperties{
            Publisher:               pointer.To(extensionRaw["publisher"].(string)),
            Type:                    &extensionType, // <- Assigns to Type field using pointer
            TypeHandlerVersion:      pointer.To(extensionRaw["type_handler_version"].(string)),
            AutoUpgradeMinorVersion: pointer.To(autoUpgradeMinorVersion),
        }
        
        // Health extension detection logic using extensionType variable
        if extensionType == "ApplicationHealthLinux" || extensionType == "ApplicationHealthWindows" {
            hasHealthExtension = true
        }
        
        // ... other properties
        
        extension.Properties = &extensionProps // <- Assigns properties to extension
        extensions = append(extensions, extension)
    }
    extensionProfile.Extensions = &extensions  // <- Assigns to Extensions field

    return extensionProfile, hasHealthExtension, nil
}

// Assignment trace in Create method:
virtualMachineProfile.ExtensionProfile = expandedProfile  // <- Returns extensionProfile
// ... later ...
props.Properties.VirtualMachineProfile = &virtualMachineProfile  // <- Adds VirtualMachineProfile nesting
```

**Trace:**
1. `expandOrchestratedVirtualMachineScaleSetExtensions` extracts `type` value into `extensionType` variable
2. Creates `VirtualMachineScaleSetExtensionProperties` with `Type` field set to `&extensionType`
3. Properties are assigned to `extension.Properties`
4. Extensions are assigned to `extensionProfile.Extensions`
5. `extensionProfile` is assigned to `virtualMachineProfile.ExtensionProfile`
6. `virtualMachineProfile` is assigned to `props.Properties.VirtualMachineProfile`
7. Final path: `properties.virtualMachineProfile.extensionProfile.extensions[].properties.type`

**Key Observation:** The `type` field is inside the `properties` sub-object of each extension, NOT at the root level like `name`. The provider extracts it into a variable first for health extension detection logic, then assigns it to the properties struct.

### Verified Path

`properties.virtualMachineProfile.extensionProfile.extensions[].properties.type`

### Path Comparison

✅ **MATCH** - Predicted path matches verified path. The `type` field is correctly placed inside the `properties` sub-object.

## Provider Schema

From `OrchestratedVirtualMachineScaleSetExtensionsSchema` function:

```go
func OrchestratedVirtualMachineScaleSetExtensionsSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeSet,
        Optional: true,
        Computed: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "name": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ValidateFunc: validation.StringIsNotEmpty,
                },

                "publisher": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ValidateFunc: validation.StringIsNotEmpty,
                },

                "type": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ValidateFunc: validation.StringIsNotEmpty,
                },

                "type_handler_version": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ValidateFunc: validation.StringIsNotEmpty,
                },
                // ... other fields
            },
        },
    }
}
```

**Key Properties:**
- **Type:** `TypeString`
- **Required:** `true`
- **Validation:** `validation.StringIsNotEmpty` - ensures the type is not an empty string
- **ForceNew:** Not present (not a ForceNew field)
- **Computed:** Not present (not a Computed field)
- **Sensitive:** Not present (not sensitive)
- **DiffSuppressFunc:** Not present

## Azure API Schema

**Path:** `properties.virtualMachineProfile.extensionProfile.extensions[].properties.type`

**Type:** String

**Extension Properties Structure:**
```
{
  "name": "string",  // Root level
  "properties": {    // Properties sub-object
    "publisher": "string",
    "type": "string",
    "typeHandlerVersion": "string",
    // ... other fields
  }
}
```

## Hidden Fields

None. The `type` field is directly mapped from Terraform configuration without any transformations or computed values. The provider does use the value for health extension detection (checking if type is "ApplicationHealthLinux" or "ApplicationHealthWindows"), but this is internal logic that doesn't affect the API payload.

## Mapping

**Terraform → Azure API:**

| Terraform Field | Azure API Field | Notes |
|----------------|-----------------|-------|
| `extension[].type` | `extensions[].properties.type` | No naming conversion needed |

**Naming:** The field name `type` remains unchanged (no snake_case to camelCase conversion).

## Special Handling

### No ForceNew Logic

The `type` field does NOT have `ForceNew: true` in the provider schema. However, extensions are part of a set, and changing the type effectively creates a new extension entry in the set.

**Decision:** No explicit ForceNew tracking needed for this field. The set-based nature of the `extension` block handles identity changes automatically through Terraform's set hashing mechanism.

### Validation Implementation

The provider schema includes `ValidateFunc: validation.StringIsNotEmpty`. Per executor.md lines 95-100, ALL value constraint validations MUST be replicated in `variables.tf`.

**Implementation:**
```hcl
validation {
  condition = (
    var.orchestrated_virtual_machine_scale_set_extension == null ||
    alltrue([for ext in var.orchestrated_virtual_machine_scale_set_extension : ext.type != ""])
  )
  error_message = "The extension type must not be empty."
}
```

**Why This is EXACT:**
1. Replicates `validation.StringIsNotEmpty` from the provider
2. Checks all extension objects in the set using `alltrue()`
3. Correctly handles the case when the entire extension set is `null`
4. The error message matches the provider's intent (preventing empty type values)

### Health Extension Detection

**Provider Logic:** The expand function has special logic to detect health extensions:

```go
if extensionType == "ApplicationHealthLinux" || extensionType == "ApplicationHealthWindows" {
    hasHealthExtension = true
}
```

This detection is used to set a boolean flag that's returned from the expand function. However, this is internal provider logic that:
1. Does NOT affect the API payload
2. Does NOT modify the type value sent to Azure
3. Is only used for logging: `log.Printf("[DEBUG] Orchestrated %s has a Health Extension defined", id)`

**Decision:** No need to replicate this internal detection logic in the shadow module. The type value is passed through unchanged to the Azure API.

### Direct Assignment Pattern

Unlike some fields that use helper functions for transformation, the `type` field follows a simple pattern:
1. Extract value from Terraform config: `extensionType := extensionRaw["type"].(string)`
2. Assign to properties struct using pointer: `Type: &extensionType`

**Implementation:** Direct mapping with no transformation: `type = ext.type`

## Deferred Work Completion

Checked `following.md` - **File does not exist.** No deferred work to complete for this task.

## Critical Review & Edge Case Analysis

### Null Semantics

- **`ext.type == null`:** Not possible. The field is defined as `type = string` (not `optional(string)`) in the variable type, so Terraform enforces non-null constraint at plan time.
- **`ext.type == ""`:** Would violate the StringIsNotEmpty validation. The validation block explicitly prevents empty strings.

**Note:** The validation ensures empty strings are rejected at plan time, exactly matching the provider's behavior.

### Edge Cases

1. **Empty Extension Set:** If `var.orchestrated_virtual_machine_scale_set_extension == null`, the entire extension skeleton is omitted (handled by Task #43). If the set is empty (`[]`), an empty extensions array would be created, which is valid.

2. **Health Extension Types:** When `type` is "ApplicationHealthLinux" or "ApplicationHealthWindows", the provider sets an internal flag for logging. This does NOT affect the API payload or our implementation.

3. **Type Length:** The provider schema does not specify a maximum length validation for type names. Azure API likely has limits, but we don't replicate them here (following provider behavior).

4. **Special Characters:** No validation for allowed characters in the provider schema. We follow provider behavior by not adding restrictions. Common types include periods (e.g., "CustomScriptExtension").

5. **Case Sensitivity:** The provider does not normalize case. We pass the value through unchanged, preserving user input exactly.

6. **Known Extension Types:** Azure has many documented extension types (e.g., "CustomScriptExtension", "AzureDiskEncryption", "ApplicationHealthLinux"). The provider does not validate against a known list - it accepts any non-empty string.

### Idempotency

- **String Value:** Direct mapping of string value from Terraform to Azure API ensures idempotency.
- **No Transformations:** No case conversions, no trimming, no normalization - the value passes through unchanged.
- **Set Identity:** The type field contributes to set element identity in Terraform along with other fields (name, publisher, etc.).

### Safe References

- **Null Safety:** The field is accessed as `ext.type` within a `for` loop iterating over a set. The loop only executes if the set is non-null (checked by Task #43's conditional: `var.orchestrated_virtual_machine_scale_set_extension != null`).
- **Type Safety:** The type constraint `type = string` ensures the field is always a string when accessed.
- **Validation Safety:** The validation block ensures the string is never empty, matching provider behavior.

## Checklist

- ✅ Property in correct local (`local.body`)
- ✅ Correct path (`extensions[].properties.type` inside properties sub-object)
- ✅ No ForceNew needed (set-based identity handling)
- ✅ Validation IMPLEMENTED in variables.tf (StringIsNotEmpty)
- ✅ Hidden fields checked (none - health extension detection is internal only)
- ✅ Provider schema analyzed
- ✅ Azure API schema verified
- ✅ Create phase verified (single-phase, before API call)
- ✅ Assignment path traced and verified
- ✅ Mapping documented
- ✅ Edge cases analyzed
- ✅ Critical review completed
- ✅ Deferred work checked (none exists)
- ✅ Implementation exactly matches provider behavior
- ✅ Direct assignment pattern (no transformation)
- ✅ Proof document created
- ✅ Self-review: Only implemented extension.type field as required by Task #46

---

**Status:** ✅ Ready for Checker Review

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent  
**Date:** 2025-12-08  
**Task:** #46 - extension.type

### Validation Results

#### Implementation Review

**migrate_main.tf (Lines 249-279):**
```hcl
var.orchestrated_virtual_machine_scale_set_extension != null || var.orchestrated_virtual_machine_scale_set_extensions_time_budget != null ? {
  extensionProfile = merge(
    var.orchestrated_virtual_machine_scale_set_extension != null ? {
      extensions = [
        for ext in var.orchestrated_virtual_machine_scale_set_extension : {
          name = ext.name
          properties = {
            publisher = ext.publisher
            type      = ext.type  # <- Task #46
            # typeHandlerVersion = ... # Task #47
          }
        }
      ]
    } : {},
```

**variables.tf (Lines 285-344):**
```hcl
variable "orchestrated_virtual_machine_scale_set_extension" {
  type = set(object({
    # ... other fields
    type = string  # <- Line 295
    # ... other fields
  }))
  
  validation {  # <- Lines 337-343
    condition = (
      var.orchestrated_virtual_machine_scale_set_extension == null ||
      alltrue([for ext in var.orchestrated_virtual_machine_scale_set_extension : ext.type != ""])
    )
    error_message = "The extension type must not be empty."
  }
}
```

#### Compliance Checks

✅ **ForceNew Logic:** Not applicable - the field does NOT have `ForceNew: true` in schema. Set-based identity handling is automatic through Terraform's set mechanism (confirmed by proof document analysis).

✅ **Stable Keys:** Not applicable - no `replace_triggers_external_values` entry needed for this field.

✅ **Phase Detection:** Correctly placed in `local.body` - field is set in Create phase before `CreateOrUpdateThenPoll` call (verified from proof document Go code evidence).

✅ **Assignment Path:** Correctly implements path `extensions[].properties.type`:
- Field is inside `properties` sub-object (NOT at root level like `name`)
- Matches provider's expand function structure
- Proof document shows complete trace through all struct assignments

✅ **Type Conversion:** Direct string mapping - no conversion needed. Type `string` in Terraform matches Azure API string type.

✅ **Null Handling:** Field is defined as `type = string` (not optional) in object type, ensuring non-null constraint at plan time.

✅ **Validations:** `validation.StringIsNotEmpty` replicated exactly:
- Implemented in `variables.tf` validation block (lines 337-343)
- Uses `alltrue()` to check all extension objects in set
- Correctly handles null set case with `var.orchestrated_virtual_machine_scale_set_extension == null`
- Error message matches provider intent
- **Method Priority Compliance:** Used validation block in `variables.tf` (preferred method), NOT deferred to Azure API or `migrate_validation.tf`

✅ **Hidden Fields:** None - type field is directly mapped without transformations. Provider's health extension detection (`ApplicationHealthLinux`/`ApplicationHealthWindows`) is internal logging logic that doesn't affect API payload (correctly documented in proof).

✅ **Sensitive Fields:** Not applicable - field is not sensitive or writeonly.

✅ **Deferred Work Completion:** No `following.md` file exists - no deferred work to complete.

✅ **Deferred Work Recording:** No deferrals made by this task - not applicable.

✅ **Edge Cases:** Proof document provides comprehensive analysis:
- Empty strings rejected by validation (matches provider)
- Null set handled correctly
- Set-based identity changes handled automatically
- No transformations applied (direct passthrough)
- Health extension types handled correctly (internal only)

✅ **Merge Structure:** No shared path conflicts - `extensionProfile` appears only once in virtualMachineProfile merge.

✅ **Scope Compliance:** Implementation adds ONLY the `type` field (line 257 in migrate_main.tf). Other extension fields remain as placeholders for future tasks.

### Provider Behavior Replication

**From provider `expandOrchestratedVirtualMachineScaleSetExtensions`:**
```go
extensionType := extensionRaw["type"].(string)
// ...
extensionProps := virtualmachinescalesets.VirtualMachineScaleSetExtensionProperties{
    Publisher:               pointer.To(extensionRaw["publisher"].(string)),
    Type:                    &extensionType,  // <- Assigns to Type field
    TypeHandlerVersion:      pointer.To(extensionRaw["type_handler_version"].(string)),
    // ...
}
extension.Properties = &extensionProps  // <- Properties sub-object
```

**Shadow module implementation:** Direct mapping `type = ext.type` inside `properties` sub-object - EXACTLY matches provider structure.

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`:

1. **Field Placement:** Correctly placed inside `properties` sub-object of each extension (NOT at root level)
2. **Validation:** `StringIsNotEmpty` replicated exactly in `variables.tf` validation block
3. **Assignment Path:** Matches provider's struct assignment: `extensions[].properties.type`
4. **No Transformations:** Direct passthrough of string value (matches provider)
5. **Phase:** Correctly implemented in Create phase (`local.body`)
6. **Scope:** Only implemented Task #46 content, no additions from other tasks

No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
