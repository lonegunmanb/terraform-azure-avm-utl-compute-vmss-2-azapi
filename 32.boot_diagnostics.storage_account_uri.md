# Task #32 - boot_diagnostics.storage_account_uri

## Summary

Implemented the `storage_account_uri` argument within the `boot_diagnostics` block, mapping to Azure API field `properties.virtualMachineProfile.diagnosticsProfile.bootDiagnostics.storageUri`. When null, the field defaults to empty string `""` to enable managed boot diagnostics. When set, it specifies the custom storage account URI for boot diagnostics output.

## Shadow Implementation

```hcl
locals {
  body = merge(
    {
      properties = merge(
        var.orchestrated_virtual_machine_scale_set_sku_name != null ? {
          virtualMachineProfile = merge(
            var.orchestrated_virtual_machine_scale_set_boot_diagnostics != null ? { # <-
              diagnosticsProfile = { # <-
                bootDiagnostics = merge( # <-
                  { # <-
                    enabled = true # <-
                  }, # <-
                  var.orchestrated_virtual_machine_scale_set_boot_diagnostics.storage_account_uri != null ? { # <-
                    storageUri = var.orchestrated_virtual_machine_scale_set_boot_diagnostics.storage_account_uri # <-
                  } : { # <-
                    storageUri = "" # <-
                  } # <-
                ) # <-
              } # <-
            } : {} # <-
          )
        } : {}
      )
    }
  )
}
```

## Create Phase Verification

### Pattern Identification

Queried the Create method (`resourceOrchestratedVirtualMachineScaleSetCreate`):

```go
if v, ok := d.GetOk("boot_diagnostics"); ok {
    virtualMachineProfile.DiagnosticsProfile = expandBootDiagnosticsVMSS(v.([]interface{}))
}

// Later...
if !isLegacy {
    props.Properties.VirtualMachineProfile = &virtualMachineProfile
}

log.Printf("[DEBUG] Creating Orchestrated %s.", id)
if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Pattern:** Single-phase creation - the field is set before the `CreateOrUpdateThenPoll` call.

**Classification:** Create phase field → belongs in `local.body`.

### Assignment Decision

The `storage_account_uri` field is part of the `boot_diagnostics` block, which is processed by `expandBootDiagnosticsVMSS` and assigned to `virtualMachineProfile.DiagnosticsProfile` during the Create phase. Therefore, it belongs in `local.body`.

## Assignment Path Verification

### Predicted Path

`properties.virtualMachineProfile.diagnosticsProfile.bootDiagnostics.storageUri`

### Go Code Evidence

From `expandBootDiagnosticsVMSS`:

```go
func expandBootDiagnosticsVMSS(input []interface{}) *virtualmachinescalesets.DiagnosticsProfile {
    if len(input) == 0 {
        return &virtualmachinescalesets.DiagnosticsProfile{
            BootDiagnostics: &virtualmachinescalesets.BootDiagnostics{
                Enabled:    pointer.To(false),
                StorageUri: pointer.To(""),
            },
        }
    }

    // this serves the managed boot diagnostics, in this case we only have this empty block without `storage_account_uri` set
    if input[0] == nil {
        return &virtualmachinescalesets.DiagnosticsProfile{
            BootDiagnostics: &virtualmachinescalesets.BootDiagnostics{
                Enabled:    pointer.To(true),
                StorageUri: pointer.To(""),
            },
        }
    }

    raw := input[0].(map[string]interface{})

    storageAccountUri := raw["storage_account_uri"].(string)

    return &virtualmachinescalesets.DiagnosticsProfile{
        BootDiagnostics: &virtualmachinescalesets.BootDiagnostics{
            Enabled:    pointer.To(true),
            StorageUri: pointer.To(storageAccountUri),
        },
    }
}
```

From Create method:
```go
if v, ok := d.GetOk("boot_diagnostics"); ok {
    virtualMachineProfile.DiagnosticsProfile = expandBootDiagnosticsVMSS(v.([]interface{}))
}

// Later...
props.Properties.VirtualMachineProfile = &virtualMachineProfile
```

**Assignments:**
1. `BootDiagnostics: &virtualmachinescalesets.BootDiagnostics{ StorageUri: pointer.To(storageAccountUri) }` → creates `bootDiagnostics.storageUri`
2. `return &virtualmachinescalesets.DiagnosticsProfile{ BootDiagnostics: ... }` → wraps in `diagnosticsProfile`
3. `virtualMachineProfile.DiagnosticsProfile = ...` → assigns to `virtualMachineProfile.diagnosticsProfile`
4. `props.Properties.VirtualMachineProfile = &virtualMachineProfile` → adds `properties.virtualMachineProfile` nesting

### Verified Path

`properties.virtualMachineProfile.diagnosticsProfile.bootDiagnostics.storageUri`

### Path Comparison

✅ **MATCH** - Predicted path matches verified path exactly.

## Provider Schema

From `bootDiagnosticsSchema()`:

```go
func bootDiagnosticsSchema() *pluginsdk.Schema {
    // lintignore:XS003
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        MaxItems: 1,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                // TODO: should this be `storage_account_endpoint`?
                "storage_account_uri": {
                    Type:     pluginsdk.TypeString,
                    Optional: true,
                    // TODO: validation
                },
            },
        },
    }
}
```

**Key Properties:**
- **Type:** String
- **Optional:** true
- **ForceNew:** false (not specified)
- **Computed:** false
- **Validation:** None (commented as TODO in provider)

## Azure API Schema

From Azure API documentation:

```json
{
  "storageUri": "Uri of the storage account to use for placing the console output and screenshot. If storageUri is not specified while enabling boot diagnostics, managed storage will be used."
}
```

**Property Path:** `body.properties.virtualMachineProfile.diagnosticsProfile.bootDiagnostics.storageUri`

**API Behavior:**
- When `storageUri` is empty string `""`: Azure uses managed storage for boot diagnostics
- When `storageUri` is set to a valid URI: Azure uses the specified storage account

## Hidden Fields

No hidden fields for this specific argument. The hidden field `enabled` was already handled in Task #31 at the parent block level.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) |
|------------------------|----------------------|
| storage_account_uri | storageUri |

## Special Handling

### Null vs Empty String Semantics

The provider has explicit logic for handling three states:

1. **Block absent** (`null`): Entire diagnosticsProfile omitted (handled by Task #31)
2. **Block empty or storage_account_uri is null** (`{storage_account_uri = null}`): `storageUri = ""` → Managed boot diagnostics
3. **storage_account_uri set**: `storageUri = <value>` → Custom storage account

From `expandBootDiagnosticsVMSS`:
- `if input[0] == nil` (empty block) → `StorageUri: pointer.To("")`
- Otherwise → `StorageUri: pointer.To(storageAccountUri)` (reads from `raw["storage_account_uri"]`)

### Implementation Logic

```hcl
var.orchestrated_virtual_machine_scale_set_boot_diagnostics.storage_account_uri != null ? {
  storageUri = var.orchestrated_virtual_machine_scale_set_boot_diagnostics.storage_account_uri
} : {
  storageUri = ""
}
```

This exactly replicates the provider logic:
- When `storage_account_uri` is set → use the value
- When `storage_account_uri` is `null` → use empty string `""`

### Validations

**No validations required.** The provider schema has a `// TODO: validation` comment but no actual validation implemented. Per `executor.md`, we only replicate validations that exist in the provider.

### ForceNew Handling

**No ForceNew required.** The field is not marked as `ForceNew` in the schema and has no `CustomizeDiff` logic that would trigger replacement.

## Critical Review & Edge Cases

### Null Semantics

- **`var.orchestrated_virtual_machine_scale_set_boot_diagnostics == null`**: Entire diagnosticsProfile omitted (handled by Task #31 parent block conditional)
- **`var.orchestrated_virtual_machine_scale_set_boot_diagnostics.storage_account_uri == null`**: `storageUri = ""` → Managed boot diagnostics
- **`var.orchestrated_virtual_machine_scale_set_boot_diagnostics.storage_account_uri == "https://..."`**: `storageUri = "https://..."` → Custom storage account

### Boundary Conditions

1. **Empty string value**: If user explicitly sets `storage_account_uri = ""`, it will be passed as `storageUri = ""`, resulting in managed boot diagnostics (same behavior as null)
2. **Invalid URI**: No validation in provider, will be rejected by Azure API if invalid format
3. **Non-existent storage account**: No provider-level validation, Azure API will validate

### Idempotency

The implementation is idempotent:
- Repeated applies with same `storage_account_uri` value produce identical API payload
- Conditional uses `merge()` to build the storageUri field consistently
- No order dependencies

### Safe References

All references use safe navigation:
- Parent block null check: `var.orchestrated_virtual_machine_scale_set_boot_diagnostics != null`
- Field null check: `var.orchestrated_virtual_machine_scale_set_boot_diagnostics.storage_account_uri != null`
- No direct nested field access without null checks

### Edge Case Analysis

**Scenario 1: User sets boot_diagnostics = {} (empty block)**
- Terraform: `var.orchestrated_virtual_machine_scale_set_boot_diagnostics.storage_account_uri == null`
- Shadow Module: `storageUri = ""`
- Azure: Managed boot diagnostics enabled
- ✅ Matches provider behavior

**Scenario 2: User sets boot_diagnostics = { storage_account_uri = null }**
- Terraform: `var.orchestrated_virtual_machine_scale_set_boot_diagnostics.storage_account_uri == null`
- Shadow Module: `storageUri = ""`
- Azure: Managed boot diagnostics enabled
- ✅ Matches provider behavior

**Scenario 3: User sets boot_diagnostics = { storage_account_uri = "https://myaccount.blob.core.windows.net/" }**
- Terraform: `var.orchestrated_virtual_machine_scale_set_boot_diagnostics.storage_account_uri == "https://..."`
- Shadow Module: `storageUri = "https://..."`
- Azure: Custom storage account used
- ✅ Matches provider behavior

**Scenario 4: User sets boot_diagnostics = { storage_account_uri = "" }**
- Terraform: `var.orchestrated_virtual_machine_scale_set_boot_diagnostics.storage_account_uri == ""`
- Shadow Module: `storageUri = ""` (empty string is not null, so it takes the first branch but with empty value)
- Azure: Managed boot diagnostics enabled
- ✅ Matches provider behavior (empty string treated same as managed diagnostics)

## Checklist

- ✅ Property in correct local (`local.body`)
- ✅ Path verified against Go source code
- ✅ Null semantics correctly handled (null → empty string)
- ✅ No ForceNew required (field not marked ForceNew)
- ✅ No validations required (provider has no validations)
- ✅ No sensitive handling required (field is not sensitive)
- ✅ Hidden fields checked (none for this field)
- ✅ Critical review completed (null, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis in proof
- ✅ Proof document created with all required sections
- ✅ Implementation exactly matches provider behavior from `expandBootDiagnosticsVMSS`

## Implementation Verification

The implementation exactly replicates the provider's `expandBootDiagnosticsVMSS` function behavior:

**Provider Logic:**
```go
storageAccountUri := raw["storage_account_uri"].(string)
return &virtualmachinescalesets.DiagnosticsProfile{
    BootDiagnostics: &virtualmachinescalesets.BootDiagnostics{
        Enabled:    pointer.To(true),
        StorageUri: pointer.To(storageAccountUri),
    },
}
```

**Shadow Module Logic:**
```hcl
var.orchestrated_virtual_machine_scale_set_boot_diagnostics.storage_account_uri != null ? {
  storageUri = var.orchestrated_virtual_machine_scale_set_boot_diagnostics.storage_account_uri
} : {
  storageUri = ""
}
```

Both implementations:
1. Check if the value is provided
2. If provided, use the value directly
3. If not provided (null), use empty string `""`
4. Empty string triggers Azure managed boot diagnostics

The implementation contains NO deviations, simplifications, or "safer alternatives" - it is an exact replication of the provider's behavior.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-08
**Task:** #32 - boot_diagnostics.storage_account_uri

### Validation Results

✅ **ForceNew Logic:** No ForceNew handling required (field not marked ForceNew in schema, no CustomizeDiff)
✅ **Stable Keys:** N/A (no ForceNew triggers for this field)
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase, single-phase creation)
✅ **Type Conversion:** Correct - String to String (no conversion needed)
✅ **Null Handling:** Correctly propagates null → empty string `""` for managed boot diagnostics
✅ **Validations:** None required (provider has no validations for this field)
✅ **Edge Cases:** All edge cases properly analyzed (null, empty string, custom URI, managed diagnostics)
✅ **Sensitive Field:** Not sensitive - correctly placed in `body` not `sensitive_body`
✅ **Safe References:** Proper null checks on parent block before accessing field
✅ **Shared Path Merge:** No issues - diagnosticsProfile appears only once

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The logic from `expandBootDiagnosticsVMSS` is precisely replicated:
- When `storage_account_uri` is null → `storageUri = ""` (managed diagnostics)
- When `storage_account_uri` is set → `storageUri = <value>` (custom storage account)

No deviations, simplifications, or "safer alternatives" were found. The implementation handles all edge cases correctly including empty strings, null values, and custom URIs.

**Status:** APPROVED ✅

---
