# Task #119: os_profile.windows_configuration.patch_assessment_mode

## Summary

Implemented the `patch_assessment_mode` argument for Windows configuration in the Shadow Module. This field controls the mode of VM Guest Patching for Windows virtual machines, with allowed values "AutomaticByPlatform" and "ImageDefault" (no default in provider schema). The field maps to `patchSettings.assessmentMode` in the Azure API.

## Shadow Implementation

```hcl
# variables.tf
variable "orchestrated_virtual_machine_scale_set_os_profile" {
  type = object({
    windows_configuration = optional(object({
      patch_assessment_mode = optional(string) # <-
    }))
  })

  validation { # <-
    condition = var.orchestrated_virtual_machine_scale_set_os_profile == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_assessment_mode == null || contains(["AutomaticByPlatform", "ImageDefault"], var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_assessment_mode) # <-
    error_message = "The patch_assessment_mode must be either 'AutomaticByPlatform' or 'ImageDefault'." # <-
  } # <-

  validation { # <-
    condition = var.orchestrated_virtual_machine_scale_set_os_profile == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_assessment_mode != "AutomaticByPlatform" || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.provision_vm_agent != false # <-
    error_message = "When patch_assessment_mode is set to 'AutomaticByPlatform', provision_vm_agent must be set to true." # <-
  } # <-
}

# migrate_main.tf
locals {
  body = {
    properties = merge(
      var.orchestrated_virtual_machine_scale_set_os_profile != null ? {
        virtualMachineProfile = merge(
          {
            osProfile = merge(
              var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration != null ? merge( # <-
                { # <-
                  windowsConfiguration = merge( # <-
                    { # <-
                      enableAutomaticUpdates = var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.enable_automatic_updates # <-
                    }, # <-
                    { # <-
                      patchSettings = merge( # <-
                        { # <-
                          enableHotpatching = var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.hotpatching_enabled # <-
                        }, # <-
                        var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_assessment_mode != null ? { # <-
                          assessmentMode = var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_assessment_mode # <-
                        } : {} # <-
                      ) # <-
                    } # <-
                  ) # <-
                } # <-
              ) : {} # <-
            )
          }
        )
      } : {}
    )
  }
}
```

## Create Phase Verification

### Pattern Identification

**Queried Create Method:**

Based on the Windows configuration schema function `expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration` (referenced from Task #113):

```go
func expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(input map[string]interface{}, customData string) *virtualmachinescalesets.VirtualMachineScaleSetOSProfile {
    osProfile := virtualmachinescalesets.VirtualMachineScaleSetOSProfile{}
    winConfig := virtualmachinescalesets.WindowsConfiguration{}
    patchSettings := virtualmachinescalesets.PatchSettings{}

    if len(input) > 0 {
        // ... other fields ...
        
        patchSettings.AssessmentMode = pointer.To(virtualmachinescalesets.WindowsPatchAssessmentMode(input["patch_assessment_mode"].(string)))
        patchSettings.PatchMode = pointer.To(virtualmachinescalesets.WindowsVMGuestPatchMode(input["patch_mode"].(string)))
        patchSettings.EnableHotpatching = pointer.To(input["hotpatching_enabled"].(bool))
        winConfig.PatchSettings = &patchSettings
    }

    osProfile.WindowsConfiguration = &winConfig

    return &osProfile
}
```

And from Create method:
```go
if len(winConfigRaw) > 0 && winConfigRaw[0] != nil {
    osType = virtualmachinescalesets.OperatingSystemTypesWindows
    winConfig := winConfigRaw[0].(map[string]interface{})
    vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(winConfig, customData)

    // Later assignment
    virtualMachineProfile.OsProfile = vmssOsProfile
}

// Final assignment in single phase
props.Properties.VirtualMachineProfile = &virtualMachineProfile
client.CreateOrUpdateThenPoll(ctx, id, props, ...)
```

**Pattern:** Single-phase creation. The field is set during the Create phase before the `CreateOrUpdateThenPoll` call.

**Classification:** Create phase → Assign to `local.body`

### Decision

The `patch_assessment_mode` field will be added to `local.body` as it's set during the single-phase create operation. No two-phase pattern detected.

## Assignment Path Verification

### Predicted Path

`body.properties.virtualMachineProfile.osProfile.windowsConfiguration.patchSettings.assessmentMode`

### Go Code Evidence

From the expand function chain:

```go
// Step 1: expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration
patchSettings.AssessmentMode = pointer.To(virtualmachinescalesets.WindowsPatchAssessmentMode(input["patch_assessment_mode"].(string)))
winConfig.PatchSettings = &patchSettings
osProfile.WindowsConfiguration = &winConfig
return &osProfile

// Step 2: In Create method
virtualMachineProfile.OsProfile = vmssOsProfile

// Step 3: In Create method
props.Properties.VirtualMachineProfile = &virtualMachineProfile

// Step 4: API call
client.CreateOrUpdateThenPoll(ctx, id, props, ...)
```

**Verified Path:** `properties.virtualMachineProfile.osProfile.windowsConfiguration.patchSettings.assessmentMode`

**Path Comparison:** ✅ Match - predicted path is correct

## Provider Schema

**Query:** Based on provider source code (schema for windows_configuration)

**Field Properties:**
- Type: String
- Optional: true
- Default: None (no default in schema)
- ForceNew: false (not specified)
- Sensitive: false
- Computed: false
- ValidateFunc: StringInSlice with values ["AutomaticByPlatform", "ImageDefault"]

## Azure API Schema

**Query:** `query_azapi_resource_schema(resource_type="Microsoft.Compute/virtualMachineScaleSets", api_version="2024-11-01", path="body.properties.virtualMachineProfile.osProfile.windowsConfiguration.patchSettings.assessmentMode")`

**Result:** String

**Query:** `query_azapi_resource_document` for the same path

**Result:** "Specifies the mode of VM Guest patch assessment for the IaaS virtual machine.<br /><br /> Possible values are:<br /><br /> **ImageDefault** - You control the timing of patch assessments on a virtual machine.<br /><br /> **AutomaticByPlatform** - The platform will trigger periodic patch assessments. The property provisionVMAgent must be true. (Possible values: ImageDefault,AutomaticByPlatform)"

**API Property:** `properties.virtualMachineProfile.osProfile.windowsConfiguration.patchSettings.assessmentMode`

**Type:** String (optional)

**Valid Values:** "ImageDefault", "AutomaticByPlatform"

## Hidden Fields

None. The field is directly exposed in the Terraform schema.

## Mapping

**Terraform (snake_case):** `patch_assessment_mode`

**Azure API (camelCase):** `assessmentMode`

**Mapping Rule:** Direct mapping with case conversion (snake_case → camelCase)

## Special Handling

### Validation (Category 1 - Value Constraints)

**Implemented in variables.tf:**

1. **Value constraint validation:**
   ```hcl
   validation {
     condition = var.orchestrated_virtual_machine_scale_set_os_profile == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_assessment_mode == null || contains(["AutomaticByPlatform", "ImageDefault"], var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_assessment_mode)
     error_message = "The patch_assessment_mode must be either 'AutomaticByPlatform' or 'ImageDefault'."
   }
   ```

   **Evidence:** Azure API documentation specifies possible values as "ImageDefault" and "AutomaticByPlatform"

### Validation (Category 2 - Cross-Field Constraints)

**Implemented in variables.tf:**

2. **Cross-field validation with provision_vm_agent:**
   ```hcl
   validation {
     condition = var.orchestrated_virtual_machine_scale_set_os_profile == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration == null || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.patch_assessment_mode != "AutomaticByPlatform" || var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.provision_vm_agent != false
     error_message = "When patch_assessment_mode is set to 'AutomaticByPlatform', provision_vm_agent must be set to true."
   }
   ```

   **Evidence:** Azure API documentation states "The property provisionVMAgent must be true" when using AutomaticByPlatform mode. This validation ensures that when patch_assessment_mode is "AutomaticByPlatform", provision_vm_agent is not explicitly set to false. This allows both `true` and `null` (which defaults to true in Task #121) values.

   **Note:** Task #121 implements provision_vm_agent with a default of `true`, so the validation condition checks `!= false` to allow both explicit `true` and default `null` (which becomes `true`) values.

### ForceNew

Not applicable. The provider schema does not specify ForceNew for this field, and no CustomizeDiff logic was found for this field.

### Sensitive

Not applicable. The field is not sensitive.

### Post-Creation Update

Not applicable. The field is set in the Create phase.

## Deferred Work Completion

Checked `following.md` - no work was deferred to Task #119.

## Critical Review & Edge Case Analysis

### Null Semantics

- **null value:** Field is omitted from the API request. Azure uses its default behavior (ImageDefault mode).
- **"ImageDefault" value:** Explicitly sets assessment mode to ImageDefault.
- **"AutomaticByPlatform" value:** Explicitly sets assessment mode to AutomaticByPlatform. Requires provision_vm_agent to be true.

### Edge Cases

1. **Empty string:** Rejected by validation - must be one of the allowed values.
2. **Invalid value:** Rejected by validation - must be "ImageDefault" or "AutomaticByPlatform".
3. **AutomaticByPlatform without provisionVMAgent:** Rejected by cross-field validation.
4. **Conditional block:** The patchSettings block is conditionally created only when patch_assessment_mode is not null, allowing other patch settings (enableHotpatching) to still be set when patch_assessment_mode is null.

### Idempotency

✅ The implementation is idempotent:
- Same input always produces same output
- No order-dependent operations
- Deterministic conditional logic

### Safe References

✅ All references are safe:
- Parent block (`windows_configuration`) existence is checked before accessing `patch_assessment_mode`
- Cross-field validation safely checks provision_vm_agent using `!= false` instead of `== true` to handle null values correctly

## Checklist

- ✅ Property in correct local (body)
- ✅ ForceNew wrapped: N/A (not ForceNew)
- ✅ ALL logic EXACTLY replicated from provider (validations match provider behavior)
- ✅ Validations IMPLEMENTED in variables.tf (value constraint + cross-field validation)
- ✅ TODO comment: N/A (not a sensitive field)
- ✅ Hidden fields checked: None
- ✅ Deferred work in following.md: None to record
- ✅ Deferred work from following.md: None found
- ✅ Critical review (null, edge, idempotent, safe refs): Completed
- ✅ Edge Case Analysis in proof: Included above
- ✅ Proof created: This document
- ✅ track.md updated: Will update to "Pending for check"
- ✅ Self-Review: Implementation only covers patch_assessment_mode for Windows configuration, no other fields added

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #119 - os_profile.windows_configuration.patch_assessment_mode

### Issues Identified

#### Issue 1: Shared Path Merge Violation - patchSettings appearing twice

**Problem:**
The `patchSettings` key appeared twice at the same merge level in the `windowsConfiguration` object, causing the second occurrence to overwrite the first when the condition was false. This violates executor.md line 132's explicit requirement for nested merge on shared paths.

**Executor's Implementation:**
```hcl
windowsConfiguration = merge(
  { enableAutomaticUpdates = ... },
  var...patch_assessment_mode != null ? {
    patchSettings = merge({ enableHotpatching = ... }, { assessmentMode = ... })
  } : {
    patchSettings = { enableHotpatching = ... }  # Second occurrence overwrites first!
  }
)
```

**Why This Violates executor.md:**
From executor.md line 132:
> ⚠️ `merge()` is SHALLOW! Use nested `merge()` for shared paths

The `patchSettings` key appeared at the same level in both the true and false branches of the conditional. When `patch_assessment_mode` is null, the second `patchSettings` object would be used, but this creates an unstable structure where the entire `patchSettings` object appears/disappears between the two branches instead of maintaining a stable parent with only children changing.

**Provider's Actual Behavior:**
The provider always sets `patchSettings` as a stable parent object and conditionally includes child fields within it. The `enableHotpatching` field is always set, while `assessmentMode` is only set when provided.

**Expected Behavior:**
- `patchSettings` should appear **once** as a stable parent key
- `enableHotpatching` should always be present within `patchSettings`
- `assessmentMode` should conditionally appear within `patchSettings` using nested merge

**Root Cause:**
Executor used a top-level conditional for the entire `patchSettings` object instead of using nested merge to conditionally add only the `assessmentMode` field within a stable `patchSettings` parent.

### Corrections Made

#### Fix 1: Restructured to use nested merge for patchSettings

**Changed Files:**
- `migrate_main.tf`: Restructured windowsConfiguration merge to use nested merge for patchSettings
- `119.os_profile.windows_configuration.patch_assessment_mode.md`: Updated Shadow Implementation section to reflect corrected code

**New Implementation:**
```hcl
windowsConfiguration = merge(
  {
    enableAutomaticUpdates = var...enable_automatic_updates
  },
  {
    patchSettings = merge(
      {
        enableHotpatching = var...hotpatching_enabled
      },
      var...patch_assessment_mode != null ? {
        assessmentMode = var...patch_assessment_mode
      } : {}
    )
  }
)
```

**Why This is EXACT:**
- `patchSettings` now appears **exactly once** at the top level of windowsConfiguration merge
- The nested `merge()` within `patchSettings` ensures `enableHotpatching` is always present
- `assessmentMode` is conditionally added using nested merge (empty object `{}` when null)
- Matches the provider's behavior of stable parent with conditional children
- No risk of overwriting the entire `patchSettings` object

**Verification:**
- Scenario 1: `patch_assessment_mode = "AutomaticByPlatform"` → `{ patchSettings: { enableHotpatching: true/false, assessmentMode: "AutomaticByPlatform" } }` ✅
- Scenario 2: `patch_assessment_mode = "ImageDefault"` → `{ patchSettings: { enableHotpatching: true/false, assessmentMode: "ImageDefault" } }` ✅
- Scenario 3: `patch_assessment_mode = null` → `{ patchSettings: { enableHotpatching: true/false } }` ✅
- Edge Case: Multiple applies with changing values → patchSettings key remains stable, only child values change ✅

### Compliance Statement

After corrections, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`. The shared path merge issue has been resolved using nested merge, ensuring the `patchSettings` key remains stable across all conditions.

**Status:** CORRECTED AND APPROVED ✅

---
