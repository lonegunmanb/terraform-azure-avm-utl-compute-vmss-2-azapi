# Task #128 - os_profile.windows_configuration.secret.certificate - Block Structure Skeleton

## Summary

Created block structure skeleton for `os_profile.windows_configuration.secret.certificate` nested block. This block converts the Terraform TypeSet of certificates into a JSON array of `vaultCertificates` objects for the Azure API. The skeleton creates the array structure with comment placeholders for child fields (#129-130). No hidden fields were found in the expand function.

## Shadow Implementation

```hcl
locals {
  body = {
    properties = {
      virtualMachineProfile = {
        osProfile = merge(
          var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration != null &&
          var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.secret != null &&
          length(var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.secret) > 0 ? {
            secrets = [
              for secret in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.secret : {
                sourceVault = {
                  id = secret.key_vault_id
                }
                vaultCertificates = [ # <-
                  for cert in secret.certificate : { # <-
                    # certificateStore = ... # Task #129 # <-
                    # certificateUrl = ... # Task #130 # <-
                  } # <-
                ] # <-
              }
            ]
          } : {}
        )
      }
    }
  }
}
```

## Create Phase Verification

### Pattern Identification

Queried Create method to identify the creation pattern.

**Evidence from Create method:**

The certificate block is processed during the single-phase creation as part of the Windows secrets expansion. From the `resourceOrchestratedVirtualMachineScaleSetCreate` function (via `expandWindowsSecretsVMSS`):

```go
// In resourceOrchestratedVirtualMachineScaleSetCreate
if len(winConfigRaw) > 0 && winConfigRaw[0] != nil {
    osType = virtualmachinescalesets.OperatingSystemTypesWindows
    winConfig := winConfigRaw[0].(map[string]interface{})
    vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(winConfig, customData)
    
    // Inside expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration:
    profile.Secrets = expandWindowsSecretsVMSS(config["secret"].([]interface{}))
}

// In expandWindowsSecretsVMSS (from shared_schema.go):
func expandWindowsSecretsVMSS(input []interface{}) *[]virtualmachinescalesets.VaultSecretGroup {
    output := make([]virtualmachinescalesets.VaultSecretGroup, 0)

    for _, raw := range input {
        v := raw.(map[string]interface{})

        keyVaultId := v["key_vault_id"].(string)
        certificatesRaw := v["certificate"].(*pluginsdk.Set).List() // <- TypeSet converted to List
        certificates := make([]virtualmachinescalesets.VaultCertificate, 0)
        for _, certificateRaw := range certificatesRaw {
            certificateV := certificateRaw.(map[string]interface{})

            store := certificateV["store"].(string)
            url := certificateV["url"].(string)
            certificates = append(certificates, virtualmachinescalesets.VaultCertificate{
                CertificateStore: pointer.To(store),
                CertificateURL:   pointer.To(url),
            })
        }

        output = append(output, virtualmachinescalesets.VaultSecretGroup{
            SourceVault: &virtualmachinescalesets.SubResource{
                Id: pointer.To(keyVaultId),
            },
            VaultCertificates: &certificates, // <- Array of certificates
        })
    }

    return &output
}

// Later assignment:
props.Properties.VirtualMachineProfile.OsProfile = vmssOsProfile
```

**Pattern:** Single-phase creation (Create phase only)

**Classification:** Create phase field - certificates are processed during the initial `expandWindowsSecretsVMSS` call before the create API call

**Decision:** Implement in `local.body`

### Two-Phase Check

No two-phase pattern detected. The field is set once during Create and sent in the initial CreateOrUpdate call.

## Assignment Path Verification

### Predicted Path

Based on the Terraform schema `os_profile.windows_configuration.secret.certificate`, the Azure API path should be:
```
properties.virtualMachineProfile.osProfile.secrets[].vaultCertificates[]
```

### Go Code Evidence

From `expandWindowsSecretsVMSS` in `shared_schema.go`:

```go
func expandWindowsSecretsVMSS(input []interface{}) *[]virtualmachinescalesets.VaultSecretGroup {
    output := make([]virtualmachinescalesets.VaultSecretGroup, 0)

    for _, raw := range input {
        v := raw.(map[string]interface{})

        keyVaultId := v["key_vault_id"].(string)
        certificatesRaw := v["certificate"].(*pluginsdk.Set).List() // <- Convert TypeSet to List
        certificates := make([]virtualmachinescalesets.VaultCertificate, 0)
        for _, certificateRaw := range certificatesRaw {
            certificateV := certificateRaw.(map[string]interface{})

            store := certificateV["store"].(string)
            url := certificateV["url"].(string)
            certificates = append(certificates, virtualmachinescalesets.VaultCertificate{
                CertificateStore: pointer.To(store),     // <- Maps to certificateStore
                CertificateURL:   pointer.To(url),       // <- Maps to certificateUrl
            })
        }

        output = append(output, virtualmachinescalesets.VaultSecretGroup{
            SourceVault: &virtualmachinescalesets.SubResource{
                Id: pointer.To(keyVaultId),
            },
            VaultCertificates: &certificates,  // <- Array assigned to VaultCertificates
        })
    }

    return &output
}
```

**Critical Assignment in Create method:**

From `resourceOrchestratedVirtualMachineScaleSetCreate`:

```go
winConfig := winConfigRaw[0].(map[string]interface{})
profile.Secrets = expandWindowsSecretsVMSS(winConfig["secret"].([]interface{}))

props := virtualmachinescalesets.VirtualMachineScaleSet{
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        VirtualMachineProfile: &profile,  // <- profile contains Secrets with VaultCertificates
    },
}
```

### Verified Path

```
properties.virtualMachineProfile.osProfile.secrets[]
  .vaultCertificates[]
    .certificateStore  (Task #129)
    .certificateUrl    (Task #130)
```

### Path Comparison

- **Predicted:** `properties.virtualMachineProfile.osProfile.secrets[].vaultCertificates[]`
- **Verified:** `properties.virtualMachineProfile.osProfile.secrets[].vaultCertificates[]`
- **Match:** ✅ Yes

## Provider Schema

From `query_terraform_schema` output:

```json
{
  "nesting_mode": "set",
  "block": {
    "attributes": {
      "store": {
        "type": "string",
        "description_kind": "plain",
        "required": true
      },
      "url": {
        "type": "string",
        "description_kind": "plain",
        "required": true
      }
    },
    "description_kind": "plain"
  },
  "min_items": 1
}
```

**Key Schema Details:**
- **Type:** Set of objects (nesting_mode: set) - **IMPORTANT: TypeSet in Terraform**
- **Required Fields:**
  - `store` (string, required) - Windows certificate store name
  - `url` (string, required) - Key Vault certificate URL
- **MinItems:** 1 - At least one certificate must be present when the `certificate` block is specified
- **Optional:** The `certificate` block itself is required when parent `secret` block exists (min_items: 1)
- **ForceNew:** Not explicitly marked at the certificate level

From `windowsSecretSchema()` in `shared_schema.go`:

```go
"certificate": {
    Type:     pluginsdk.TypeSet,  // <- TypeSet, not TypeList
    Required: true,
    MinItems: 1,
    Elem: &pluginsdk.Resource{
        Schema: map[string]*pluginsdk.Schema{
            "store": {
                Type:     pluginsdk.TypeString,
                Required: true,
            },
            "url": {
                Type:         pluginsdk.TypeString,
                Required:     true,
                ValidateFunc: keyVaultValidate.NestedItemId,
            },
        },
    },
}
```

## Azure API Schema

From Go SDK types in `virtualmachinescalesets` package:

```go
type VaultSecretGroup struct {
    SourceVault       *SubResource         `json:"sourceVault,omitempty"`
    VaultCertificates *[]VaultCertificate  `json:"vaultCertificates,omitempty"`
}

type VaultCertificate struct {
    CertificateStore *string `json:"certificateStore,omitempty"`  // Windows-specific
    CertificateURL   *string `json:"certificateUrl,omitempty"`
}
```

**API Path:**
```
properties.virtualMachineProfile.osProfile.secrets[]
  .vaultCertificates[]
    .certificateStore  (Windows-only, Task #129)
    .certificateUrl    (Task #130)
```

**Key Difference from Linux:** Windows certificates include `certificateStore` field (the Windows certificate store name like "My", "Root", etc.), while Linux certificates only have the URL.

## Hidden Fields

### Analysis of Expand Function

From `expandWindowsSecretsVMSS`:

```go
certificatesRaw := v["certificate"].(*pluginsdk.Set).List()
certificates := make([]virtualmachinescalesets.VaultCertificate, 0)
for _, certificateRaw := range certificatesRaw {
    certificateV := certificateRaw.(map[string]interface{})

    store := certificateV["store"].(string)
    url := certificateV["url"].(string)
    certificates = append(certificates, virtualmachinescalesets.VaultCertificate{
        CertificateStore: pointer.To(store),  // From Terraform: certificate[].store
        CertificateURL:   pointer.To(url),    // From Terraform: certificate[].url
    })
}

output = append(output, virtualmachinescalesets.VaultSecretGroup{
    SourceVault: &virtualmachinescalesets.SubResource{
        Id: pointer.To(keyVaultId),
    },
    VaultCertificates: &certificates,  // Array of VaultCertificate
})
```

**Hidden Fields:** None

All fields are directly mapped from Terraform schema:
- `certificate[].store` → `vaultCertificates[].certificateStore`
- `certificate[].url` → `vaultCertificates[].certificateUrl`

No additional hardcoded values, no computed fields, and no hidden API-only fields.

## Mapping

| Terraform Field | Azure API Field | Notes |
|----------------|-----------------|-------|
| `certificate[]` | `vaultCertificates[]` | TypeSet converted to array |
| `certificate.store` | `vaultCertificates[].certificateStore` | Task #129 - Windows certificate store name |
| `certificate.url` | `vaultCertificates[].certificateUrl` | Task #130 - Key Vault certificate URL |

**Naming Convention:**
- `certificate` (snake_case) → `vaultCertificates` (camelCase)
- `store` (snake_case) → `certificateStore` (camelCase)
- `url` (snake_case) → `certificateUrl` (camelCase, note: URL capitalization)

## Special Handling

### Block Structure

**Nesting Mode:** Set (TypeSet in Terraform) - **CRITICAL for understanding iteration**

**TypeSet to List Conversion:** The provider converts the TypeSet to a List before processing:
```go
certificatesRaw := v["certificate"].(*pluginsdk.Set).List()
```

In Terraform HCL, we can iterate over a set directly using `for ... in`:
```hcl
for cert in secret.certificate : {
  # Terraform automatically handles set iteration
}
```

**Conditionality:** The `vaultCertificates` field is present when:
1. Parent `secret` block exists (checked by parent skeleton #126)
2. `certificate` set is not empty (enforced by min_items: 1 in schema)

**Implementation:**
```hcl
vaultCertificates = [
  for cert in secret.certificate : {
    # child fields here (Tasks #129, #130)
  }
]
```

### TypeSet Behavior

**Important Characteristics:**
- **Order Independence:** TypeSet in Terraform does not guarantee order. Terraform may reorder elements based on a hash function.
- **Uniqueness:** Sets enforce uniqueness based on the hash of the entire certificate object (both `store` and `url`).
- **Iteration:** Despite being a set, we can iterate using `for ... in`, and Terraform converts it to a list-like iteration internally.

**Azure API Expectation:** The API receives `vaultCertificates` as a JSON array. Since each certificate has both a `certificateStore` and `certificateUrl`, order independence is acceptable - Windows will install each certificate to its designated store regardless of order.

**Handling in Shadow Module:** The `for cert in secret.certificate` expression correctly iterates over the set and produces an array output. Terraform handles the set-to-list conversion automatically.

### ForceNew Behavior

No explicit `ForceNew: true` at the certificate level in the schema. However:
- The parent `secret` block is part of `osProfile` which is typically immutable after creation
- Modifying certificates may trigger updates or require replacement depending on Azure API behavior
- No DiffSuppressFunc or CustomizeDiff logic found specifically for certificates

**Decision:** No special ForceNew handling required at the skeleton level. Child tasks (#129, #130) will determine if individual fields need ForceNew triggers.

### Validation

**Schema Validation:**
- `min_items: 1` - At least one certificate must be present when the `certificate` block is specified
- `url` has validation: `keyVaultValidate.NestedItemId` (validates Key Vault certificate URL format)
- `store` has no explicit validation in provider, but Azure API will validate the store name

**These validations are already enforced by the Terraform schema and don't need replication in `variables.tf` for this skeleton task.**

Child tasks will handle field-specific validations:
- Task #129 (`store`): No additional validation beyond being a required string
- Task #130 (`url`): Already validated by schema's `keyVaultValidate.NestedItemId`

## Critical Review & Edge Cases

### Null Semantics

**`null` certificate set:**
- Cannot happen due to `Required: true` in schema
- When parent `secret` block exists, `certificate` must be present with at least 1 item (min_items: 1)

**Empty certificate set:**
- Cannot happen due to `min_items: 1` enforcement
- Schema prevents an empty set from being passed

**Present certificates:**
- Each certificate in the set produces one `VaultCertificate` object in the array
- The for loop processes all certificates in the set

### Boundary Conditions

1. **Single certificate:** Valid and supported - most common case
2. **Multiple certificates:** Valid - one Key Vault can provision multiple certs to different stores
3. **No certificates:** Invalid - schema enforces min_items: 1, would fail at plan time
4. **Duplicate certificates:** TypeSet enforces uniqueness based on hash of (store, url) pair

### Idempotency

The implementation is idempotent:
- For loop processes certificates in set order (which may vary between runs due to TypeSet hashing)
- Each certificate block is independently processed
- No state dependencies between iterations
- No side effects from the loop
- **Order independence is acceptable** because each certificate specifies its target store

**Azure API Behavior:** Windows installs each certificate to the specified store. The installation order doesn't matter as long as all certificates are installed correctly.

### Safe References

**Variable Access Chain:**
```hcl
secret.certificate
```

**Safety Checks:**
1. ✅ Parent check: `secret != null` (from parent loop in Task #126)
2. ✅ Field check: `certificate` is Required, cannot be null
3. ✅ MinItems check: Schema enforces min_items: 1

**Safe because:** The parent `for secret in ...` loop only executes when secrets exist, and within each secret, the `certificate` field is required and must have at least 1 item.

### Edge Case: Set Ordering

**Issue:** TypeSet may reorder certificates between Terraform runs based on hash function.

**Impact:** 
- The `vaultCertificates` array sent to Azure may have different ordering between runs
- Azure API accepts this because each certificate specifies its target `certificateStore`
- No functional impact on Windows VM - all certificates are installed to correct stores

**Handling:** No special handling needed. The order independence is a feature, not a bug.

### Edge Case: Windows-Specific Store Field

The key difference between Windows and Linux secrets is the `certificateStore` field:
- **Linux:** Certificates are provisioned to the VM filesystem (no store field)
- **Windows:** Certificates are installed to specific Windows certificate stores

**Common Windows Certificate Store Names:**
- `My` - Personal certificates
- `Root` - Trusted Root Certification Authorities
- `CA` - Intermediate Certification Authorities
- `Trust` - Enterprise Trust
- `TrustedPublisher` - Trusted Publishers
- `AuthRoot` - Third-Party Root Certification Authorities

**Handling:** Task #129 will implement the `store` field mapping. The provider doesn't validate store names (left to Azure API).

### Edge Case: Mutual Exclusivity with Linux

From the parent `os_profile` block (Task #96), `linux_configuration` and `windows_configuration` are mutually exclusive. Only one can be present.

**Impact:** This certificate skeleton only activates when `windows_configuration` is present, which means Linux-specific secrets (without `certificateStore`) are not applicable here.

**Handling:** Correctly isolated - this skeleton only activates within the Windows configuration context.

### Edge Case: Key Vault Certificate URL Format

The `url` field must be a valid Key Vault certificate URL format, validated by `keyVaultValidate.NestedItemId`.

**Example URL format:**
```
https://<keyvault-name>.vault.azure.net/secrets/<secret-name>/<version>
```

**Note:** Certificates in Key Vault are stored as secrets with additional metadata.

**Handling:** Task #130 will implement the URL field. The validation is already enforced by the schema, but Task #130 may need to replicate it in `variables.tf`.

## Child Tasks Ready for Delegation

The following child tasks are now **READY** for implementation since the certificate skeleton structure (#128) is complete:

| Task # | Field | Type | Notes |
|--------|-------|------|-------|
| 129 | os_profile.windows_configuration.secret.certificate.store | Argument (Required) | Windows certificate store name (e.g., "My", "Root") |
| 130 | os_profile.windows_configuration.secret.certificate.url | Argument (Required) | Key Vault certificate URL, validated by keyVaultValidate.NestedItemId |

**Dependency Flow:**
- Both Tasks #129 and #130 can work in parallel (siblings under #128)
- Both must complete to finalize the certificate implementation
- Tasks #127 (key_vault_id) was already unblocked by Task #126

**Implementation Notes for Child Tasks:**
- Task #129: Direct string mapping, no validation in provider (Azure API validates), Windows-specific field
- Task #130: Direct string mapping, URL validation already in schema (may need replication in variables.tf)

## Deferred Work Completion

Checked `following.md` for work deferred to Task #128: **None found**.

No deferred work to complete for this task.

## Completion Checklist

- ✅ Property in correct local (`local.body`)
- ✅ Block structure skeleton created with comment placeholders
- ✅ TypeSet to array conversion using `for ... in` loop
- ✅ Placement within parent `secrets` array (nested under secret loop)
- ✅ ForceNew: Not applicable at skeleton level (no special handling needed)
- ✅ Validations: Schema enforces min_items: 1 and URL format (no additional validation needed at skeleton level)
- ✅ Hidden fields: None found (all fields directly mapped from Terraform)
- ✅ Deferred work checked: None found for this task
- ✅ Critical review completed
- ✅ Edge case analysis included (TypeSet ordering, Windows-specific store, mutual exclusivity, Key Vault URL format)
- ✅ Proof document created
- ✅ `track.md` will be updated to "Pending for check"
- ✅ Self-Review: Only skeleton structure created, no child implementations added

## Notes

1. **TypeSet to Array Conversion:** The `for cert in secret.certificate` expression correctly handles the TypeSet-to-array conversion. Terraform automatically iterates over the set and produces an array output.

2. **Order Independence:** Since `certificate` is a TypeSet, the order may vary between runs. This is acceptable because each certificate specifies its target `certificateStore`, so installation order doesn't matter.

3. **MinItems Enforcement:** The schema enforces `min_items: 1`, preventing empty certificate sets. This skeleton doesn't need additional null checks for the certificate set itself.

4. **Windows-Specific Implementation:** This skeleton is specifically for Windows secrets. The key difference from Linux (Task #111) is the presence of the `certificateStore` field in Task #129.

5. **Key Vault URL Validation:** The provider validates certificate URLs using `keyVaultValidate.NestedItemId`. Task #130 should replicate this validation in `variables.tf` (same as Linux Task #112).

6. **No Hidden Fields:** The expand function shows a clean 1:1 mapping from Terraform fields to API fields with no additional computed values or hardcoded settings.

7. **Integration with Parent:** This skeleton integrates with the `secrets` array structure created in Task #126, which is at the `osProfile` level (NOT inside `windowsConfiguration`).

8. **Shared Structure:** Both Linux and Windows use the same `VaultSecretGroup` structure with `SourceVault` and `VaultCertificates`. The only difference is Windows includes the `CertificateStore` field in each certificate.

9. **Certificate Store Names:** Common Windows certificate store names include "My" (personal), "Root" (trusted root), "CA" (intermediate), etc. The provider doesn't validate these names, leaving it to the Azure API.

10. **Consistency with Linux Implementation:** This implementation maintains structural consistency with the Linux certificate implementation (Task #111), differing only in the additional `store` field (Task #129) for Windows certificates.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent  
**Date:** 2025-12-11  
**Task:** #128 - os_profile.windows_configuration.secret.certificate

### Validation Results

✅ **Task Type:** Correctly identified as Type 3 (Block Structure Skeleton)  
✅ **Skeleton Structure:** Exact match with proof document, proper comment placeholders for Tasks #129-130  
✅ **TypeSet Handling:** Correct `for cert in secret.certificate` iteration with array output  
✅ **Placement:** Correctly in `local.body` within parent `secrets` array structure  
✅ **Conditionality:** Proper null checks on all parent conditions  
✅ **Shared Path Merge:** No merge conflicts, `secrets` key appears only once  
✅ **Field Naming:** `vaultCertificates` correctly uses camelCase per Azure API  
✅ **Hidden Fields:** None found, clean 1:1 mapping verified  
✅ **Phase Detection:** Create phase only, correctly placed  
✅ **Assignment Path:** Verified as `properties.virtualMachineProfile.osProfile.secrets[].vaultCertificates[]`  
✅ **Deferred Work Completion:** No deferred work found for this task in following.md  
✅ **Deferred Work Recording:** No deferrals made by this task  
✅ **Edge Cases:** Comprehensive analysis including TypeSet ordering, Windows-specific behavior, mutual exclusivity  
✅ **Proof Document:** Complete with all required sections, Go code evidence, no forbidden simplification phrases  
✅ **Integration:** Properly nested within parent Task #126 structure  
✅ **Scope Compliance:** Only skeleton implemented, no child fields added

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The skeleton correctly:
- Creates the `vaultCertificates` array structure using TypeSet iteration
- Maintains proper nesting within the parent `secrets` array
- Provides comment placeholders for child tasks #129 (store) and #130 (url)
- Handles Windows-specific certificate structure (differs from Linux by including `certificateStore`)
- Documents comprehensive provider source code analysis with complete tracing

No deviations, simplifications, or "safer alternatives" were found. The implementation is a precise Type 3 skeleton task following all executor.md requirements.

**Status:** APPROVED ✅

---
