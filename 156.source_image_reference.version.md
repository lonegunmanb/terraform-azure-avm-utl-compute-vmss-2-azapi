# Task #156: source_image_reference.version - Block Argument

## Summary
Implemented `version` field for `source_image_reference` block at `properties.virtualMachineProfile.storageProfile.imageReference.version` as a Required argument with StringIsNotEmpty validation. This field does NOT have ForceNew behavior.

## Shadow Implementation

```hcl
# In variables.tf - Validation
validation {
  condition     = var.orchestrated_virtual_machine_scale_set_source_image_reference == null || (var.orchestrated_virtual_machine_scale_set_source_image_reference.version != null && var.orchestrated_virtual_machine_scale_set_source_image_reference.version != "")
  error_message = "The `version` field in `source_image_reference` must not be empty."
}

# In migrate_main.tf - local.body
var.orchestrated_virtual_machine_scale_set_source_image_reference != null ? {
  imageReference = {
    offer     = var.orchestrated_virtual_machine_scale_set_source_image_reference.offer
    publisher = var.orchestrated_virtual_machine_scale_set_source_image_reference.publisher
    sku       = var.orchestrated_virtual_machine_scale_set_source_image_reference.sku
    version   = var.orchestrated_virtual_machine_scale_set_source_image_reference.version  # <- Task #156
  }
} : {}
```

## Create Phase Verification

**Pattern:** Single-phase Create

**Evidence from Create method:**
```go
sourceImageReferenceRaw := d.Get("source_image_reference").([]interface{})
sourceImageId := d.Get("source_image_id").(string)
if len(sourceImageReferenceRaw) != 0 || sourceImageId != "" {
    sourceImageReference := expandSourceImageReferenceVMSS(sourceImageReferenceRaw, sourceImageId)
    virtualMachineProfile.StorageProfile.ImageReference = sourceImageReference
}

// Later:
props := virtualmachinescalesets.VirtualMachineScaleSet{
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        VirtualMachineProfile: &virtualMachineProfile,
    },
}

if err := client.CreateOrUpdateThenPoll(ctx, id, props, ...); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Classification:** Create phase - The field is set in `virtualMachineProfile.StorageProfile.ImageReference` before the `CreateOrUpdateThenPoll` call.

**Decision:** Implement in `local.body`, not `post_creation_updates`.

## Assignment Path Verification

**Predicted Path:**
```
properties.virtualMachineProfile.storageProfile.imageReference.version
```

**Go Code Evidence:**
```go
// In expandSourceImageReferenceVMSS:
raw := referenceInput[0].(map[string]interface{})
return &virtualmachinescalesets.ImageReference{
    Publisher: pointer.To(raw["publisher"].(string)),
    Offer:     pointer.To(raw["offer"].(string)),
    Sku:       pointer.To(raw["sku"].(string)),
    Version:   pointer.To(raw["version"].(string)),  // <- version field
}

// In Create method:
virtualMachineProfile.StorageProfile.ImageReference = sourceImageReference

// Finally:
props.Properties.VirtualMachineProfile = &virtualMachineProfile
```

**Traced Assignments:**
1. `ImageReference.Version = pointer.To(raw["version"].(string))`
2. `virtualMachineProfile.StorageProfile.ImageReference = sourceImageReference`
3. `props.Properties.VirtualMachineProfile = &virtualMachineProfile`
4. Final path: `properties.virtualMachineProfile.storageProfile.imageReference.version`

**Verified Path:** `properties.virtualMachineProfile.storageProfile.imageReference.version`

**Path Comparison:** ✅ MATCH

## Provider Schema

```go
"version": {
    Type:         pluginsdk.TypeString,
    Required:     true,
    ValidateFunc: validation.StringIsNotEmpty,
},
```

**Key Points:**
- **Type:** String
- **Required:** Yes
- **ForceNew:** NO (unlike publisher and offer)
- **Validation:** StringIsNotEmpty

## Azure API Schema

**Query Result:** `String`

**Property Path:** `body.properties.virtualMachineProfile.storageProfile.imageReference.version`

**Azure API Type:** String (optional in Azure API, but Required in Terraform schema)

## Hidden Fields

**Query:** Checked `expandSourceImageReferenceVMSS` function.

```go
func expandSourceImageReferenceVMSS(referenceInput []interface{}, imageId string) *virtualmachinescalesets.ImageReference {
    if imageId != "" {
        // ... handles source_image_id routing (Task #18)
    }

    raw := referenceInput[0].(map[string]interface{})
    return &virtualmachinescalesets.ImageReference{
        Publisher: pointer.To(raw["publisher"].(string)),
        Offer:     pointer.To(raw["offer"].(string)),
        Sku:       pointer.To(raw["sku"].(string)),
        Version:   pointer.To(raw["version"].(string)),
    }
}
```

**Result:** ✅ **NO hidden fields** - Direct 1:1 mapping from Terraform field to API field.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|------------------------|----------------------|-------|
| version | version | Direct mapping (no case change) |

## Special Handling

### 1. Validation (MANDATORY)
**Provider Schema:** `ValidateFunc: validation.StringIsNotEmpty`

**Implementation:** Added validation block in `variables.tf`:
```hcl
validation {
  condition     = var.orchestrated_virtual_machine_scale_set_source_image_reference == null || (var.orchestrated_virtual_machine_scale_set_source_image_reference.version != null && var.orchestrated_virtual_machine_scale_set_source_image_reference.version != "")
  error_message = "The `version` field in `source_image_reference` must not be empty."
}
```

**Rationale:** MUST replicate provider validation - cannot defer to Azure API.

### 2. NO ForceNew
**Critical Difference from Siblings:**
- `publisher`: ForceNew = true (Task #154)
- `offer`: ForceNew = true (Task #153)
- `sku`: ForceNew = NO (Task #155)
- `version`: ForceNew = NO (Task #156) ← Current

**Implementation:** NO entry in `replace_triggers_external_values` for version field.

**Verification from Schema:**
```go
// publisher and offer have ForceNew:
"publisher": {
    Type:         pluginsdk.TypeString,
    Required:     true,
    ForceNew:     true,  // <- ForceNew
    ValidateFunc: validation.StringIsNotEmpty,
},

// version does NOT have ForceNew:
"version": {
    Type:         pluginsdk.TypeString,
    Required:     true,
    // NO ForceNew here
    ValidateFunc: validation.StringIsNotEmpty,
},
```

**Result:** Version changes allow in-place updates.

### 3. No CustomizeDiff Logic
**Verification:** Reviewed resource function CustomizeDiff - no logic involving version field.

## Deferred Work Completion

**Checked `following.md`:** 

Found deferred work from Task #118:
```
| #118 | Multiple (#120, #121, #18, #152-156, #43-56) | Validation | Complex hotpatching validations requiring image reference parsing and cross-field checks. (1) When using hotpatch-enabled images: patch_mode must be AutomaticByPlatform, provision_vm_agent must be true, health extension required, hotpatching_enabled must be true. (2) When NOT using hotpatch-enabled images: hotpatching_enabled must be false. Implementation requires isValidHotPatchSourceImageReference() logic. | Pending |
```

**Analysis:**
- This validation requires `isValidHotPatchSourceImageReference()` which parses publisher, offer, and SKU to determine if it's a hotpatch-enabled image
- The validation logic depends on having all three fields available: publisher, offer, sku
- **Task #156 (version)** is NOT involved in the hotpatching validation logic - the version field is not checked by `isValidHotPatchSourceImageReference()`

**Evidence from Provider Code:**
```go
func isValidHotPatchSourceImageReference(referenceInput []interface{}, imageId string) bool {
    if imageId != "" {
        return false
    }

    if len(referenceInput) == 0 {
        return false
    }

    raw := referenceInput[0].(map[string]interface{})
    pub := raw["publisher"].(string)     // <- publisher used
    offer := raw["offer"].(string)       // <- offer used
    sku := raw["sku"].(string)           // <- sku used
    // NOTE: version is NOT used in this function

    supportedSkus := []string{
        "2022-datacenter-azure-edition-core",
        "2022-datacenter-azure-edition-core-smalldisk",
        "2022-datacenter-azure-edition-hotpatch",
        "2022-datacenter-azure-edition-hotpatch-smalldisk",
        "2025-datacenter-azure-edition",
        "2025-datacenter-azure-edition-smalldisk",
        "2025-datacenter-azure-edition-core",
        "2025-datacenter-azure-edition-core-smalldisk",
    }

    if pub == "MicrosoftWindowsServer" && offer == "WindowsServer" && slices.Contains(supportedSkus, sku) {
        return true
    }

    return false
}
```

**Decision:** NO deferred work for Task #156 (version). The hotpatching validation uses only publisher, offer, and sku fields. The version field is not involved.

**Update to following.md:** No update needed for Task #156 - deferred work status remains "Pending" as it's owned by other tasks (primarily Task #155 sku which is the last required field for the validation logic).

## Critical Review & Edge Cases

### Null Semantics
- **Block Level:** Parent block can be null (user may use source_image_id instead)
- **Field Level:** version is Required, so cannot be null when block exists
- **Empty String:** Prevented by StringIsNotEmpty validation

### Boundary Conditions
- **Valid Values:** Any non-empty string (e.g., "latest", "16.04.201909091", "1.0.0")
- **Special Value:** "latest" is commonly used and valid
- **Version Format:** Azure API accepts various formats - no specific format validation in provider

### Idempotency
- ✅ Direct string assignment is deterministic
- ✅ No transformation or normalization applied
- ✅ Value is passed as-is to Azure API

### Safe References
- ✅ Null check at block level: `var.orchestrated_virtual_machine_scale_set_source_image_reference != null`
- ✅ Field is Required within block, so no additional null handling needed
- ✅ Parent skeleton (Task #152) ensures block-level safety

### Edge Case Analysis

**Case 1: Version update without ForceNew**
- **Scenario:** User changes version from "1.0.0" to "1.0.1"
- **Behavior:** In-place update (no ForceNew)
- **Implementation:** Correctly implemented - no entry in replace_triggers_external_values
- **Validation:** Matches provider schema behavior

**Case 2: Empty string value**
- **Scenario:** User sets version = ""
- **Prevention:** Validation blocks empty string
- **Error Message:** "The `version` field in `source_image_reference` must not be empty."

**Case 3: Special version values**
- **Scenario:** User sets version = "latest"
- **Behavior:** Accepted and passed to Azure API
- **Implementation:** ✅ Works correctly - no special handling needed

**Case 4: Cross-field consistency with ForceNew siblings**
- **Scenario:** User changes publisher (ForceNew) and version (no ForceNew)
- **Behavior:** Resource replacement triggered by publisher change
- **Result:** Version change is included in replacement
- **Implementation:** ✅ Correct - ForceNew is per-field

## Checklist

- ✅ Field implemented in `local.body` at correct path
- ✅ Validation added in `variables.tf` (StringIsNotEmpty)
- ✅ NO ForceNew tracking (correct - version allows in-place updates)
- ✅ Comment placeholder replaced in skeleton (Task #152)
- ✅ Create phase verified (single-phase, direct assignment)
- ✅ Assignment path traced and verified
- ✅ No hidden fields found
- ✅ Deferred work checked - NOT applicable to Task #156 (version not used in hotpatching validation)
- ✅ Edge cases analyzed comprehensively
- ✅ Null safety ensured at block level
- ✅ Validation replicates exact provider behavior
- ✅ Implementation exactly matches provider schema (Required, no ForceNew)
- ✅ Critical review completed
- ✅ Proof document created
- ✅ Track.md status to be updated to "Pending for check"

## Implementation Exactly Matches Provider

**Schema Compliance:**
```go
// Provider Schema
"version": {
    Type:         pluginsdk.TypeString,
    Required:     true,
    ValidateFunc: validation.StringIsNotEmpty,
}

// Shadow Implementation
version = var.orchestrated_virtual_machine_scale_set_source_image_reference.version

// Validation
validation {
  condition     = ... version != null && version != ""
  error_message = "The `version` field in `source_image_reference` must not be empty."
}
```

**Behavior Match:**
- ✅ Required field → Non-nullable in object type
- ✅ StringIsNotEmpty → Validation block replicates
- ✅ No ForceNew → No entry in replace_triggers_external_values
- ✅ Direct mapping → No transformation logic

**No Deviations:** Implementation is EXACT replication of provider behavior.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #156 - source_image_reference.version

### Validation Results

✅ **ForceNew Logic:** Correctly NO ForceNew - version field allows in-place updates (schema has no ForceNew: true)
✅ **Stable Keys:** No entry in `replace_triggers_external_values` (correct - not a ForceNew field)
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase)
✅ **Type Conversion:** Direct string mapping (no conversion needed)
✅ **Null Handling:** Correctly uses block-level null check on parent
✅ **Validations:** StringIsNotEmpty validation exactly replicated in variables.tf
✅ **Deferred Work Completion:** Correctly analyzed - version NOT used in hotpatching validation (Task #118 deferral does not apply to this field)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed - special values ("latest"), empty string handling, cross-field consistency

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The version field correctly:
- Has NO ForceNew behavior (matches schema)
- Implements StringIsNotEmpty validation in variables.tf
- Is placed in the correct path in local.body
- Allows in-place updates when changed
- Differs from publisher/offer siblings which DO have ForceNew

No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
