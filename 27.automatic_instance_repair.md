# Task #27 - automatic_instance_repair Block Skeleton

## Summary

Created conditional structure skeleton for `automatic_instance_repair` block that maps to Azure API `properties.automaticRepairsPolicy`. The skeleton contains placeholders for three child fields (Task #28-30).

## Shadow Implementation

```hcl
locals {
  body = merge(
    {
      properties = merge(
        var.orchestrated_virtual_machine_scale_set_automatic_instance_repair != null ? {
          automaticRepairsPolicy = {
            # enabled = ... # Task #28
            # repairAction = ... # Task #29
            # gracePeriod = ... # Task #30
          }
        } : {}
      )
    }
  )
}
```

## Create Phase Verification

### Query Create Method

Queried Create method using `query_terraform_block_implementation_source_code(entrypoint_name="create")`.

### Pattern Identification

**Single-Phase Pattern**: The Create method uses `CreateOrUpdateThenPoll` which handles creation in a single API call.

```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    // ... properties construction ...
    
    if v, ok := d.GetOk("automatic_instance_repair"); ok {
        if !hasHealthExtension {
            return fmt.Errorf("`automatic_instance_repair` can only be enabled when an application health extension is configured")
        }
        
        props.Properties.AutomaticRepairsPolicy = ExpandVirtualMachineScaleSetAutomaticRepairsPolicy(v.([]interface{}))
    }
    
    // ... more properties ...
    
    if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
        return fmt.Errorf("creating Orchestrated %s: %w", id, err)
    }
    
    return resourceOrchestratedVirtualMachineScaleSetRead(d, meta)
}
```

### Field Classification

**Create Phase Assignment**: The field is set BEFORE the `CreateOrUpdateThenPoll` call, making it a Create phase field.

**Decision**: Implement in `local.body` (not in `post_creation_updates`).

## Assignment Path Verification

### Predicted Path

```
automatic_instance_repair (Terraform variable)
  └─> AutomaticRepairsPolicy (props.Properties field)
    └─> properties.automaticRepairsPolicy (Azure API)
```

### Go Code Evidence

From Create method:
```go
props := virtualmachinescalesets.VirtualMachineScaleSet{
    Location: location.Normalize(d.Get("location").(string)),
    Tags:     tags.Expand(t),
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        PlatformFaultDomainCount: pointer.To(int64(d.Get("platform_fault_domain_count").(int))),
        OrchestrationMode: pointer.To(virtualmachinescalesets.OrchestrationModeFlexible),
    },
}

// ... later in the function ...

if v, ok := d.GetOk("automatic_instance_repair"); ok {
    if !hasHealthExtension {
        return fmt.Errorf("`automatic_instance_repair` can only be enabled when an application health extension is configured")
    }
    
    props.Properties.AutomaticRepairsPolicy = ExpandVirtualMachineScaleSetAutomaticRepairsPolicy(v.([]interface{}))
}
```

The assignment is: `props.Properties.AutomaticRepairsPolicy = ...`

### Verified Path

```
automatic_instance_repair (Terraform)
  └─> props.Properties.AutomaticRepairsPolicy (Go struct)
    └─> properties.automaticRepairsPolicy (Azure API)
```

### Path Comparison

✅ **Match**: The predicted path matches the verified path. The field is assigned to `props.Properties.AutomaticRepairsPolicy`, which maps to `properties.automaticRepairsPolicy` in the Azure API body.

## Provider Schema

From `virtual_machine_scale_set.go`:

```go
func VirtualMachineScaleSetAutomaticRepairsPolicySchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        Computed: true,
        MaxItems: 1,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "enabled": {
                    Type:     pluginsdk.TypeBool,
                    Required: true,
                },
                // NOTE: O+C 'grace_period' and 'action' will always return a value once they've been set.
                "grace_period": {
                    Type:         pluginsdk.TypeString,
                    Optional:     true,
                    Computed:     true,
                    ValidateFunc: azValidate.ISO8601DurationBetween("PT10M", "PT90M"),
                },
                "action": {
                    Type:         pluginsdk.TypeString,
                    Optional:     true,
                    Computed:     true,
                    ValidateFunc: validation.StringInSlice(virtualmachinescalesets.PossibleValuesForRepairAction(), false),
                },
            },
        },
    }
}
```

**Schema Properties**:
- **Type**: List (MaxItems: 1)
- **Optional**: Yes (can be null)
- **Computed**: Yes
- **Children**: 3 fields
  - `enabled` (Required, bool)
  - `grace_period` (Optional, Computed, string with validation)
  - `action` (Optional, Computed, string with validation)

## Azure API Schema

From Azure API schema query:

```
properties.automaticRepairsPolicy: ObjectWithOptionalAttrs(map[string]Type{
  "enabled": Bool,
  "gracePeriod": String,
  "repairAction": String
}, []string{"enabled", "gracePeriod", "repairAction"})
```

**API Properties**:
- All three fields are optional at the API level
- Field names: `enabled`, `gracePeriod`, `repairAction`

## Hidden Fields Check

### Expand Function Analysis

From `virtual_machine_scale_set.go`:

```go
func ExpandVirtualMachineScaleSetAutomaticRepairsPolicy(input []interface{}) *virtualmachinescalesets.AutomaticRepairsPolicy {
    if len(input) == 0 {
        return nil
    }

    v := input[0].(map[string]interface{})

    result := virtualmachinescalesets.AutomaticRepairsPolicy{}

    result.Enabled = pointer.To(v["enabled"].(bool))
    result.GracePeriod = pointer.To(v["grace_period"].(string))

    if v["action"].(string) != "" {
        result.RepairAction = pointer.To(virtualmachinescalesets.RepairAction(v["action"].(string)))
    }

    return &result
}
```

**Hidden Fields Analysis**:
- ✅ No hidden fields detected
- The expand function only sets the three documented fields: `Enabled`, `GracePeriod`, and `RepairAction`
- All fields come from the Terraform configuration (`v["enabled"]`, `v["grace_period"]`, `v["action"]`)
- No hardcoded values or computed fields are injected

**Conclusion**: All fields are explicitly configured by child tasks. No hidden fields need to be added in this skeleton task.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) |
|------------------------|----------------------|
| automatic_instance_repair | automaticRepairsPolicy |
| enabled | enabled |
| grace_period | gracePeriod |
| action | repairAction |

## Special Handling

### Block Conditionality

The block is **optional** (can be null). The skeleton uses conditional expression:
```hcl
var.orchestrated_virtual_machine_scale_set_automatic_instance_repair != null ? {
  automaticRepairsPolicy = { ... }
} : {}
```

This ensures the `automaticRepairsPolicy` object is only included in the API body when the user provides the block.

### Child Task Delegation

The skeleton contains comment placeholders for three child argument tasks:
- **Task #28**: `automatic_instance_repair.enabled` (Required field)
- **Task #29**: `automatic_instance_repair.action` (Optional field)
- **Task #30**: `automatic_instance_repair.grace_period` (Optional field)

Each child task will replace its respective placeholder comment with the actual implementation.

### ForceNew Behavior

**Note from Schema**: The block itself is not marked as `ForceNew`, and none of the fields within it have `ForceNew: true`. This means all fields can be updated in place without forcing a resource replacement.

### Validation Dependencies

**Important Provider Logic**: The Create method validates that `automatic_instance_repair` can only be enabled when a health extension is configured:

```go
if v, ok := d.GetOk("automatic_instance_repair"); ok {
    if !hasHealthExtension {
        return fmt.Errorf("`automatic_instance_repair` can only be enabled when an application health extension is configured")
    }
    // ...
}
```

This validation logic is handled by the AzureRM provider, not by Azure API. Since we're using AzAPI provider, users must ensure they configure a health extension before enabling automatic instance repair. This is a **user responsibility** - the Shadow Module does not replicate this validation because:
1. It would require complex analysis of extension configurations
2. Azure API will reject invalid configurations anyway
3. Users should understand this requirement from Azure documentation

## Critical Review & Edge Case Analysis

### Null Semantics

**Block is null**: When `var.orchestrated_virtual_machine_scale_set_automatic_instance_repair` is null, the conditional returns `{}`, which means `automaticRepairsPolicy` is NOT included in the API body. This matches provider behavior where the block is completely omitted if not set.

**Block is provided**: When the block is provided (non-null), the object is created with fields populated by child tasks.

### Boundary Conditions

**Empty block not possible**: Since `enabled` is a Required field (Task #28), users cannot provide an empty block. Terraform will enforce this at plan time.

### Idempotency

**Structure is idempotent**: The conditional expression produces the same structure for the same input. The presence or absence of the block is deterministic based on the variable value.

### Safe References

**Null-safe**: The condition checks `!= null` before accessing the variable, preventing null reference errors.

**Child tasks will handle field access**: Each child task will safely access its field from the parent object structure.

### Edge Cases

1. **Block provided but all optional fields empty**: Handled by child Task #28-30 implementations
2. **Invalid ISO8601 duration**: Handled by Task #30 validation
3. **Invalid repair action value**: Handled by Task #29 validation
4. **Enabling without health extension**: Azure API will reject (user responsibility)

## Checklist

- ✅ Property in correct local (`body`)
- ✅ Conditional wrapping for optional block
- ✅ Hidden fields checked (none found)
- ✅ Critical review completed
- ✅ Edge case analysis documented
- ✅ Proof created
- ✅ Task list updated in track.md

## Child Tasks Ready for Delegation

The following child tasks are now **ready** for implementation since the block skeleton is complete:

- **Task #28**: `automatic_instance_repair.enabled` (Required bool)
- **Task #29**: `automatic_instance_repair.action` (Optional string with enum validation)
- **Task #30**: `automatic_instance_repair.grace_period` (Optional string with ISO8601 duration validation)

All three tasks can be worked on independently once the skeleton is merged.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-08
**Task:** #27 - automatic_instance_repair

### Validation Results

✅ **Type 3 Skeleton Pattern:** Correctly implements conditional block skeleton with comment placeholders for child fields (Tasks #28-30)
✅ **Merge Structure:** No shallow merge violations - `properties` appears once, `automaticRepairsPolicy` properly nested
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase, before CreateOrUpdateThenPoll)
✅ **Assignment Path:** Verified path `props.Properties.AutomaticRepairsPolicy` → `properties.automaticRepairsPolicy`
✅ **Hidden Fields:** Expand function analyzed - no hidden fields or hardcoded values detected
✅ **Null Handling:** Correctly uses conditional `!= null` check to omit block when not set
✅ **Edge Cases:** Proof document includes comprehensive edge case analysis
✅ **Proof Quality:** All required sections present with Go code evidence

### Compliance Statement

This implementation EXACTLY follows the Type 3 block skeleton pattern as required by `executor.md` (lines 309-321). The skeleton creates the proper conditional structure for `automaticRepairsPolicy` with placeholders for three child argument tasks. No deviations, simplifications, or violations found.

**Status:** APPROVED ✅

---
