# Task #81: network_interface.ip_configuration.public_ip_address.public_ip_prefix_id - Block Argument

## Summary

Implemented the `public_ip_prefix_id` argument for `public_ip_address` block. This optional field allows specifying the ID of a Public IP Prefix from which Public IP Addresses should be allocated. The field has ForceNew: true behavior requiring replacement when changed.

## Shadow Implementation

```hcl
# First conditional branch (when domain_name_label is set)
ip_config.public_ip_address[0].idle_timeout_in_minutes != null && ip_config.public_ip_address[0].idle_timeout_in_minutes > 0 ? { # <-
  idleTimeoutInMinutes = ip_config.public_ip_address[0].idle_timeout_in_minutes # <-
} : {}, # <-
ip_config.public_ip_address[0].public_ip_prefix_id != null && ip_config.public_ip_address[0].public_ip_prefix_id != "" ? { # <-
  publicIPPrefix = { # <-
    id = ip_config.public_ip_address[0].public_ip_prefix_id # <-
  } # <-
} : {} # <-

# Second conditional branch (when idle_timeout_in_minutes is set but not domain_name_label)
} : ip_config.public_ip_address[0].idle_timeout_in_minutes != null && ip_config.public_ip_address[0].idle_timeout_in_minutes > 0 ? { # <-
  properties = merge( # <-
    { # <-
      idleTimeoutInMinutes = ip_config.public_ip_address[0].idle_timeout_in_minutes # <-
    }, # <-
    ip_config.public_ip_address[0].public_ip_prefix_id != null && ip_config.public_ip_address[0].public_ip_prefix_id != "" ? { # <-
      publicIPPrefix = { # <-
        id = ip_config.public_ip_address[0].public_ip_prefix_id # <-
      } # <-
    } : {} # <-
  ) # <-
} : ip_config.public_ip_address[0].public_ip_prefix_id != null && ip_config.public_ip_address[0].public_ip_prefix_id != "" ? { # <-
  properties = { # <-
    publicIPPrefix = { # <-
      id = ip_config.public_ip_address[0].public_ip_prefix_id # <-
    } # <-
  } # <-
} : {} # <-

# ForceNew trigger
public_ip_prefix_id = { # <-
  value = var.orchestrated_virtual_machine_scale_set_network_interface != null ? jsonencode([ # <-
    for nic in var.orchestrated_virtual_machine_scale_set_network_interface : [ # <-
      for ip_config in nic.ip_configuration : ip_config.public_ip_address != null && length(ip_config.public_ip_address) > 0 ? ip_config.public_ip_address[0].public_ip_prefix_id : null # <-
    ] # <-
  ]) : "" # <-
} # <-
```

## Create Phase Verification

### Query Result

Queried the Create method using the source code from GitHub:

```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    // ... setup code ...
    
    if v, ok := d.GetOk("network_interface"); ok {
        networkInterfaces, err := ExpandOrchestratedVirtualMachineScaleSetNetworkInterface(v.([]interface{}))
        if err != nil {
            return fmt.Errorf("expanding `network_interface`: %w", err)
        }
        
        networkProfile.NetworkInterfaceConfigurations = networkInterfaces
        virtualMachineProfile.NetworkProfile = networkProfile
    }
    
    // ...
    props.Properties.VirtualMachineProfile = &virtualMachineProfile
    
    if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
        return fmt.Errorf("creating Orchestrated %s: %w", id, err)
    }
}
```

### Create Pattern

**Pattern:** Single-phase create

The resource uses `CreateOrUpdateThenPoll` which is a single-phase creation pattern. The `public_ip_prefix_id` field is expanded within the network interface configuration hierarchy before the API call and included in the initial create request.

### Field Phase Classification

**Phase:** Create phase

The `public_ip_prefix_id` field is:
1. Expanded via `ExpandOrchestratedVirtualMachineScaleSetNetworkInterface` → `expandOrchestratedVirtualMachineScaleSetIPConfiguration` → `expandOrchestratedVirtualMachineScaleSetPublicIPAddress`
2. Set in the `virtualMachineProfile.NetworkProfile` before the create call
3. Sent to the API in the initial `CreateOrUpdateThenPoll` request

**Decision:** Implement in `local.body` (Create phase)

## Assignment Path Verification

### Predicted Path

Based on Azure API schema and parent block structure:
```
body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].properties.ipConfigurations[].properties.publicIPAddressConfiguration.properties.publicIPPrefix.id
```

### Go Code Evidence

From `expandOrchestratedVirtualMachineScaleSetPublicIPAddress`:

```go
func expandOrchestratedVirtualMachineScaleSetPublicIPAddress(raw map[string]interface{}) *virtualmachinescalesets.VirtualMachineScaleSetPublicIPAddressConfiguration {
    // ... other fields ...
    
    publicIPAddressConfig := virtualmachinescalesets.VirtualMachineScaleSetPublicIPAddressConfiguration{
        Name: raw["name"].(string),
        Properties: &virtualmachinescalesets.VirtualMachineScaleSetPublicIPAddressConfigurationProperties{ // ← .Properties assignment
            IPTags: &ipTags,
        },
    }
    
    // ... domain_name_label, idle_timeout_in_minutes handling ...
    
    if publicIPPrefixID := raw["public_ip_prefix_id"].(string); publicIPPrefixID != "" { // ← Conditional check for non-empty
        publicIPAddressConfig.Properties.PublicIPPrefix = &virtualmachinescalesets.SubResource{ // ← Assigned to .Properties.PublicIPPrefix
            Id: pointer.To(publicIPPrefixID), // ← Wrapped in SubResource with Id field
        }
    }
    
    // ... sku_name, version handling ...
    
    return &publicIPAddressConfig
}
```

From `expandOrchestratedVirtualMachineScaleSetIPConfiguration`:

```go
publicIPConfigsRaw := raw["public_ip_address"].([]interface{})
if len(publicIPConfigsRaw) > 0 && publicIPConfigsRaw[0] != nil {
    publicIPConfigRaw := publicIPConfigsRaw[0].(map[string]interface{})
    publicIPAddressConfig := expandOrchestratedVirtualMachineScaleSetPublicIPAddress(publicIPConfigRaw)
    ipConfiguration.Properties.PublicIPAddressConfiguration = publicIPAddressConfig // ← Assigned to .Properties.PublicIPAddressConfiguration
}
```

### Verified Path

```
body
└── properties (assigned via props.Properties)
    └── virtualMachineProfile (assigned via props.Properties.VirtualMachineProfile)
        └── networkProfile (assigned via virtualMachineProfile.NetworkProfile)
            └── networkInterfaceConfigurations (assigned via networkProfile.NetworkInterfaceConfigurations)
                └── [array elements]
                    └── properties (assigned via config.Properties)
                        └── ipConfigurations (assigned via config.Properties.IPConfigurations)
                            └── [array elements]
                                └── properties (assigned via ipConfiguration.Properties)
                                    └── publicIPAddressConfiguration (assigned via ipConfiguration.Properties.PublicIPAddressConfiguration)
                                        └── properties (assigned via publicIPAddressConfig.Properties)
                                            └── publicIPPrefix (assigned via publicIPAddressConfig.Properties.PublicIPPrefix)
                                                └── id (assigned via SubResource.Id)
```

### Path Comparison

**Match:** ✅ The predicted path matches the verified path exactly.

The assignment follows this chain:
1. `publicIPAddressConfig.Properties.PublicIPPrefix = &SubResource{ Id: pointer.To(publicIPPrefixID) }`
2. `ipConfiguration.Properties.PublicIPAddressConfiguration = publicIPAddressConfig`
3. `config.Properties.IPConfigurations` includes the ipConfiguration
4. `networkProfile.NetworkInterfaceConfigurations` includes the config
5. `virtualMachineProfile.NetworkProfile = networkProfile`
6. `props.Properties.VirtualMachineProfile = &virtualMachineProfile`

## Provider Schema

```go
func orchestratedVirtualMachineScaleSetPublicIPAddressSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                // ... other fields ...
                "public_ip_prefix_id": {
                    Type:         pluginsdk.TypeString,
                    Optional:     true,
                    ForceNew:     true, // ← ForceNew behavior
                    ValidateFunc: publicipprefixes.ValidatePublicIPPrefixID, // ← Azure Resource ID validation
                },
                // ... other fields ...
            },
        },
    }
}
```

**Field Type:** `TypeString` (Optional)
**ForceNew:** `true` - Changing this forces a new resource to be created
**Validation:** `publicipprefixes.ValidatePublicIPPrefixID` - Validates Azure Resource ID format for Public IP Prefix

## Azure API Schema

Query attempted: `body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations.properties.ipConfigurations.properties.publicIPAddressConfiguration.properties.publicIPPrefix`

From broader schema query result:
```
publicIPPrefix: ObjectWithOptionalAttrs(map[string]Type{
  "id": String
}, []string{"id"})
```

**Structure:**
- `publicIPPrefix` is an optional object
- Contains single field: `id` (String, optional)
- The `id` field holds the Azure Resource ID of the Public IP Prefix

## Hidden Fields Check

### Expand Function Analysis

From the expand function quoted above, the logic is:

```go
if publicIPPrefixID := raw["public_ip_prefix_id"].(string); publicIPPrefixID != "" {
    publicIPAddressConfig.Properties.PublicIPPrefix = &virtualmachinescalesets.SubResource{
        Id: pointer.To(publicIPPrefixID),
    }
}
```

### Hidden Fields Result

**NO HIDDEN FIELDS FOUND** - The expand function:
- Only uses the `public_ip_prefix_id` field from schema
- No hardcoded values
- No computed fields
- No additional fields beyond what's in the schema

The field is conditionally set only when the user provides a non-empty string value. Otherwise, the entire `PublicIPPrefix` object is omitted from the API request.

## Mapping

| Terraform Field | Azure API Field | Notes |
|----------------|----------------|-------|
| `public_ip_address[0].public_ip_prefix_id` | `publicIPAddressConfiguration.properties.publicIPPrefix.id` | Wrapped in SubResource object |

**Naming:** `public_ip_prefix_id` → `publicIPPrefix.id` (snake_case → camelCase, wrapped in object)

## Special Handling

### ForceNew Behavior

**ForceNew:** `true` in schema

The field is marked with `ForceNew: true`, meaning any change to this value requires resource replacement. This is appropriate because changing the Public IP Prefix source for a scale set's public IPs cannot be done in-place.

**Implementation in replace_triggers_external_values:**

```hcl
public_ip_prefix_id = {
  value = var.orchestrated_virtual_machine_scale_set_network_interface != null ? jsonencode([
    for nic in var.orchestrated_virtual_machine_scale_set_network_interface : [
      for ip_config in nic.ip_configuration : ip_config.public_ip_address != null && length(ip_config.public_ip_address) > 0 ? ip_config.public_ip_address[0].public_ip_prefix_id : null
    ]
  ]) : ""
}
```

**Rationale:** 
- Uses **Mode 1 - Direct Value Tracking** (wrapped in `{ value = ... }`)
- Tracks the actual field value changes across all network interfaces and IP configurations
- Key is always present (stable), value changes trigger replacement
- Nested loop structure captures all public_ip_prefix_id values from all NICs and IP configs
- Returns null for IP configs without public_ip_address or when public_ip_address is empty
- Encodes as JSON to handle the nested array structure

### Conditional Assignment

The field is conditionally assigned in three different locations due to the nested conditional structure created by previous tasks:

1. **First branch:** When `domain_name_label` is set (inside existing properties merge)
2. **Second branch:** When only `idle_timeout_in_minutes` is set (new properties merge)
3. **Third branch:** When neither is set but `public_ip_prefix_id` is set (new properties object)

This follows the pattern established by Task #79 (domain_name_label) and Task #80 (idle_timeout_in_minutes) where properties is only created when needed.

**Empty String Check:**

```hcl
ip_config.public_ip_address[0].public_ip_prefix_id != null && ip_config.public_ip_address[0].public_ip_prefix_id != ""
```

Matches provider logic:
```go
if publicIPPrefixID := raw["public_ip_prefix_id"].(string); publicIPPrefixID != "" {
```

Both null and empty string are treated as "not provided" - the field is omitted entirely.

### SubResource Wrapper

The API requires wrapping the ID in a SubResource object:

```hcl
publicIPPrefix = {
  id = ip_config.public_ip_address[0].public_ip_prefix_id
}
```

This matches the provider's structure:
```go
PublicIPPrefix = &virtualmachinescalesets.SubResource{
    Id: pointer.To(publicIPPrefixID),
}
```

## Validation

### Provider Validation

From schema:
```go
ValidateFunc: publicipprefixes.ValidatePublicIPPrefixID
```

This validates that the value is a valid Azure Public IP Prefix Resource ID in the format:
```
/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/publicIPPrefixes/{publicIpPrefixName}
```

### Validation Decision

**NOT IMPLEMENTED in variables.tf**

According to executor.md:
> ❌ Skip ONLY Azure Resource ID format validations (e.g., `/subscriptions/.../resourceGroups/...`) - these are verified by resource references

Since `public_ip_prefix_id` is an Azure Resource ID that references an existing Public IP Prefix resource, the Resource ID format validation is intentionally skipped. The reference will be validated by Terraform's resource reference system.

The field in variables.tf remains:
```hcl
public_ip_prefix_id = optional(string)
```

No validation block is added.

## Deferred Work Completion

Checked `following.md` for any work deferred to Task #81: **None found.**

No validation, logic, or implementation was deferred to this task from earlier tasks.

## Critical Review & Edge Case Analysis

### Null Semantics

**Null meaning:** "Do not use a Public IP Prefix - let Azure assign IPs from its pool"

When `public_ip_prefix_id` is null or empty string:
- The entire `publicIPPrefix` object is omitted from the API request
- Azure will allocate public IPs from its default pool rather than from a user-specified prefix
- This is the default behavior and most common scenario

When set to a valid Resource ID:
- Public IPs for all scale set instances will be allocated from the specified Public IP Prefix
- All IPs will share the same prefix range
- Useful for network policy and firewall rule management

### Edge Cases

1. **Empty string vs null:**
   - Check: `!= null && != ""`
   - Both treated identically: field omitted
   - Provider checks: `publicIPPrefixID != ""`
   - Our logic matches exactly

2. **Invalid Resource ID:**
   - No validation in variables.tf (per executor.md rules)
   - Azure API will return error if ID is invalid
   - User relies on Terraform resource references for correctness

3. **Multiple network interfaces with different prefixes:**
   - Each NIC → each IP config can have different public_ip_prefix_id
   - ForceNew tracks all values: `[[nic1_ip1_prefix, nic1_ip2_prefix], [nic2_ip1_prefix]]`
   - Any change in any prefix triggers replacement (correct ForceNew behavior)

4. **Prefix capacity:**
   - If the specified prefix doesn't have enough available IPs for all instances
   - Azure API will fail during provisioning
   - This is runtime validation, cannot be done at plan time

5. **Conditional structure integration:**
   - Three branches ensure `publicIPPrefix` is added to properties whenever set
   - Branch 1: domain_name_label set → merge into existing properties
   - Branch 2: idle_timeout set but not domain_name → merge into properties
   - Branch 3: only public_ip_prefix_id set → create new properties
   - This maintains proper structure regardless of which fields are set

### Idempotency

**Idempotent:** ✅ Yes

- Conditional checks are deterministic based on input
- No state-dependent logic
- ForceNew tracking captures all prefix IDs consistently
- Repeated applies with same input produce same output
- JSON encoding of nested arrays is deterministic (stable order from input)

### Safe References

**Safe:** ✅ Yes

- Check `ip_config.public_ip_address != null` at parent level (Task #77)
- Check `length(ip_config.public_ip_address) > 0` before accessing `[0]`
- Check `public_ip_prefix_id != null` before accessing value
- Check `public_ip_prefix_id != ""` before assigning
- No nested access without proper null guards

### ForceNew Completeness

**Complete:** ✅ Yes

The ForceNew tracking in `replace_triggers_external_values` correctly:
- Iterates through all network interfaces
- Iterates through all IP configurations per NIC
- Checks for presence of public_ip_address
- Extracts public_ip_prefix_id for each (or null if not set)
- Encodes the complete nested structure as JSON
- Changes to any prefix at any level will trigger replacement

This ensures that if the user changes the public IP prefix for any NIC/IP config, the VMSS will be replaced as required by the ForceNew constraint.

## Checklist

- ✅ Property in correct local (`local.body`)
- ✅ ForceNew handling (wrapped in `{ value = ... }` with nested loop tracking)
- ✅ All logic exactly replicated from provider (conditional assignment, empty string check, SubResource wrapper)
- ✅ Validations implemented (skipped per executor.md - Resource ID validation not needed)
- ✅ TODO comments (N/A - not a sensitive field, no independent ephemeral variable needed)
- ✅ Hidden fields checked (none found)
- ✅ Deferred work in following.md (N/A - no work deferred to other tasks)
- ✅ Deferred work from following.md (checked - none found)
- ✅ Critical review (null semantics, edge cases, idempotency, safe references, ForceNew completeness)
- ✅ Edge Case Analysis section included
- ✅ Proof created
- ✅ `track.md` ready to update to "Pending for check"
- ✅ Self-review: Added ONLY public_ip_prefix_id field (Task #81), did not implement other fields

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-09
**Task:** #81 - network_interface.ip_configuration.public_ip_address.public_ip_prefix_id

### Validation Results

✅ **ForceNew Logic:** Simple ForceNew (schema `ForceNew: true`) correctly implemented using Mode 1 - Direct Value Tracking with stable key wrapper `{ value = ... }`
✅ **Stable Keys:** Key `public_ip_prefix_id` is always present in `replace_triggers_external_values`, uses stable wrapper pattern
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase) - verified with Go code evidence showing field set before `CreateOrUpdateThenPoll`
✅ **Type Conversion:** Correct conversion - wraps ID in SubResource structure `publicIPPrefix = { id = ... }` matching provider's expand function exactly
✅ **Null Handling:** Correctly handles both null and empty string (`!= null && != ""`) matching provider logic exactly
✅ **Validations:** Resource ID format validation intentionally skipped per executor.md line 102 (Azure Resource ID validations not needed)
✅ **Conditional Logic:** Three-branch ternary structure correctly integrates with existing domain_name_label and idle_timeout_in_minutes fields - mutually exclusive branches prevent key conflicts
✅ **Shared Path Merge Check:** No violations - `properties` appears in mutually exclusive branches (ternary), within each branch all keys are unique (dnsSettings, idleTimeoutInMinutes, publicIPPrefix)
✅ **Deferred Work Completion:** No deferred work for this task - properly checked `following.md`
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** Comprehensive analysis covering null semantics, empty strings, invalid IDs, multiple NICs, capacity constraints, idempotency, safe references

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The field correctly:
- Wraps the public IP prefix Resource ID in a SubResource structure with `id` field
- Omits the entire `publicIPPrefix` object when value is null or empty string
- Triggers ForceNew on any change across all network interfaces and IP configurations
- Integrates seamlessly with the existing three-branch conditional structure for publicIPAddressConfiguration properties
- Follows all validation, null handling, and structural requirements from the provider source code

No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
