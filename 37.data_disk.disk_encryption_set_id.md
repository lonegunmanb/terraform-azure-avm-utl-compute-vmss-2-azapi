# Task #37: data_disk.disk_encryption_set_id

## Shadow Implementation

```hcl
locals {
  replace_triggers_external_values = {
    # ... other triggers ...
    data_disk_disk_encryption_set_id = { value = var.orchestrated_virtual_machine_scale_set_data_disk != null ? jsonencode([for disk in var.orchestrated_virtual_machine_scale_set_data_disk : disk.disk_encryption_set_id]) : "" } # <-
  }

  body = merge(
    {
      properties = merge(
        # ... other properties ...
        var.orchestrated_virtual_machine_scale_set_sku_name != null ? {
          virtualMachineProfile = merge(
            # ... other profile settings ...
            var.orchestrated_virtual_machine_scale_set_data_disk != null || var.orchestrated_virtual_machine_scale_set_os_disk != null ? {
              storageProfile = merge(
                var.orchestrated_virtual_machine_scale_set_data_disk != null ? {
                  dataDisks = [
                    for data_disk in var.orchestrated_virtual_machine_scale_set_data_disk : {
                      caching = data_disk.caching
                      managedDisk = merge( # <-
                        {
                          storageAccountType = data_disk.storage_account_type
                        },
                        data_disk.disk_encryption_set_id != null && data_disk.disk_encryption_set_id != "" ? { # <-
                          diskEncryptionSet = { # <-
                            id = data_disk.disk_encryption_set_id # <-
                          } # <-
                        } : {} # <-
                      ) # <-
                      createOption = data_disk.create_option
                      diskIOPSReadWrite = data_disk.ultra_ssd_disk_iops_read_write != null && data_disk.ultra_ssd_disk_iops_read_write > 0 ? data_disk.ultra_ssd_disk_iops_read_write : null
                      diskMBpsReadWrite = data_disk.ultra_ssd_disk_mbps_read_write != null && data_disk.ultra_ssd_disk_mbps_read_write > 0 ? data_disk.ultra_ssd_disk_mbps_read_write : null
                    }
                  ]
                } : {}
              )
            } : {}
          )
        } : {}
      )
    }
  )
}
```

## Summary

Implemented `disk_encryption_set_id` field for data disks. This optional field specifies the Disk Encryption Set ID to encrypt data disks. The field is ForceNew in the provider schema and conditionally added to `managedDisk.diskEncryptionSet.id` only when non-null and non-empty.

## Create Phase Verification

**Query:** `resourceOrchestratedVirtualMachineScaleSetCreate` method

**Pattern:** Single-phase Create

**Evidence from Create method (lines 383-391 in create function):**

```go
if v, ok := d.GetOk("data_disk"); ok {
    ultraSSDEnabled := d.Get("additional_capabilities.0.ultra_ssd_enabled").(bool)
    dataDisks, err := ExpandOrchestratedVirtualMachineScaleSetDataDisk(v.([]interface{}), ultraSSDEnabled)
    if err != nil {
        return fmt.Errorf("expanding `data_disk`: %w", err)
    }
    virtualMachineProfile.StorageProfile.DataDisks = dataDisks
}
```

Then later (line 454):
```go
if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Classification:** Create phase field - The `data_disk` block (including `disk_encryption_set_id`) is processed via the expand function and assigned to `virtualMachineProfile.StorageProfile.DataDisks` before the single `CreateOrUpdateThenPoll` call.

**Decision:** Implement in `local.body` (NOT in `post_creation_updates`).

## Assignment Path Verification

**Predicted Path:** `body.properties.virtualMachineProfile.storageProfile.dataDisks[].managedDisk.diskEncryptionSet.id`

**Go Code Evidence:**

From expand function (lines 215-219):
```go
if id := raw["disk_encryption_set_id"].(string); id != "" {
    disk.ManagedDisk.DiskEncryptionSet = &virtualmachinescalesets.SubResource{
        Id: pointer.To(id),
    }
}
```

From expand function structure (lines 198-205):
```go
disk := virtualmachinescalesets.VirtualMachineScaleSetDataDisk{
    Caching: pointer.To(virtualmachinescalesets.CachingTypes(raw["caching"].(string))),
    ManagedDisk: &virtualmachinescalesets.VirtualMachineScaleSetManagedDiskParameters{
        StorageAccountType: pointer.To(storageAccountType),
    },
    WriteAcceleratorEnabled: pointer.To(raw["write_accelerator_enabled"].(bool)),
    CreateOption:            virtualmachinescalesets.DiskCreateOptionTypes(raw["create_option"].(string)),
}
```

From Create method (lines 383-391):
```go
if v, ok := d.GetOk("data_disk"); ok {
    ultraSSDEnabled := d.Get("additional_capabilities.0.ultra_ssd_enabled").(bool)
    dataDisks, err := ExpandOrchestratedVirtualMachineScaleSetDataDisk(v.([]interface{}), ultraSSDEnabled)
    if err != nil {
        return fmt.Errorf("expanding `data_disk`: %w", err)
    }
    virtualMachineProfile.StorageProfile.DataDisks = dataDisks
}
```

**Tracing Assignments:**
1. `disk_encryption_set_id` → `disk.ManagedDisk.DiskEncryptionSet.Id`
2. `disk` → element in `dataDisks` array returned by expand function
3. `dataDisks` → `virtualMachineProfile.StorageProfile.DataDisks`
4. `virtualMachineProfile` → `props.Properties.VirtualMachineProfile` (line 450)
5. `props` → sent to API via `CreateOrUpdateThenPoll`

**Verified Path:** `properties.virtualMachineProfile.storageProfile.dataDisks[].managedDisk.diskEncryptionSet.id`

**Path Comparison:** ✅ Match - The predicted path matches the verified assignment path.

## Provider Schema

From `OrchestratedVirtualMachineScaleSetDataDiskSchema()`:

```go
"disk_encryption_set_id": {
    Type:     pluginsdk.TypeString,
    Optional: true,
    ForceNew: true,
    ValidateFunc: validate.DiskEncryptionSetID,
}
```

**Key Properties:**
- **Type:** String
- **Optional:** true
- **ForceNew:** true
- **Validation:** `validate.DiskEncryptionSetID` (Azure Resource ID format validation)

## Azure API Schema

**Resource Type:** `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

**Property Path:** `body.properties.virtualMachineProfile.storageProfile.dataDisks[].managedDisk.diskEncryptionSet.id`

**Query Result:**
```
ObjectWithOptionalAttrs(map[string]Type{"id":String}, []string{"id"})
```

**Type:** Object with optional `id` string field

**API Structure:**
- `dataDisks` - Array of data disk objects
- `managedDisk` - Object containing disk management parameters
- `diskEncryptionSet` - Object containing encryption set reference
- `id` - String containing the Disk Encryption Set resource ID

## Hidden Fields

**Analysis:** No hidden fields detected.

**Evidence from expand function (lines 215-219):**
```go
if id := raw["disk_encryption_set_id"].(string); id != "" {
    disk.ManagedDisk.DiskEncryptionSet = &virtualmachinescalesets.SubResource{
        Id: pointer.To(id),
    }
}
```

The expand function only sets `diskEncryptionSet.id` when the input value is non-empty. No additional fields or hardcoded values are added.

## Mapping

| AzureRM (Terraform) | Azure API | Transformation |
|---------------------|-----------|----------------|
| `data_disk.disk_encryption_set_id` | `dataDisks[].managedDisk.diskEncryptionSet.id` | snake_case → camelCase |

## Special Handling

### ForceNew Behavior

**Schema:** `ForceNew: true`

**Implementation:** Added to `replace_triggers_external_values` to track all disk encryption set IDs:

```hcl
replace_triggers_external_values = {
  data_disk_disk_encryption_set_id = { value = var.orchestrated_virtual_machine_scale_set_data_disk != null ? jsonencode([for disk in var.orchestrated_virtual_machine_scale_set_data_disk : disk.disk_encryption_set_id]) : "" }
}
```

**Rationale:** The field has `ForceNew: true` in the schema. Changes to any disk's encryption set ID require resource replacement. The trigger serializes all disk encryption set IDs as JSON to detect any changes across the entire data disk list.

### Conditional Assignment

**Logic:** The `diskEncryptionSet` object is only added to `managedDisk` when `disk_encryption_set_id` is non-null and non-empty.

**Provider Code (lines 215-219):**
```go
if id := raw["disk_encryption_set_id"].(string); id != "" {
    disk.ManagedDisk.DiskEncryptionSet = &virtualmachinescalesets.SubResource{
        Id: pointer.To(id),
    }
}
```

**Shadow Implementation:**
```hcl
managedDisk = merge(
  {
    storageAccountType = data_disk.storage_account_type
  },
  data_disk.disk_encryption_set_id != null && data_disk.disk_encryption_set_id != "" ? {
    diskEncryptionSet = {
      id = data_disk.disk_encryption_set_id
    }
  } : {}
)
```

**Exact Replication:** ✅ The implementation exactly matches the provider's conditional logic using merge to add the `diskEncryptionSet` object only when the ID is present and non-empty.

### Validation

**Provider Validation:** `validate.DiskEncryptionSetID`

**Analysis:** This validation checks Azure Resource ID format for Disk Encryption Set resources (pattern: `/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/diskEncryptionSets/{diskEncryptionSetName}`).

**Decision:** ❌ Skip - Per executor.md rules, Azure Resource ID format validations are skipped as they are verified by resource references. Users will reference disk encryption set resources by ID, and Terraform's resource reference system ensures valid IDs.

### List Iteration

**Pattern:** The field is inside a list block (`data_disk`), requiring iteration over all data disks.

**Implementation:** Uses `for` expression to process each disk in the list:
```hcl
dataDisks = [
  for data_disk in var.orchestrated_virtual_machine_scale_set_data_disk : {
    # ... disk properties including disk_encryption_set_id ...
  }
]
```

## Deferred Work Completion

**Check:** Reviewed `following.md` - file does not exist, no deferred work to complete.

## Critical Review & Edge Cases

### Edge Case Analysis

1. **Null vs Empty String Semantics:**
   - **Provider behavior:** Only sets `diskEncryptionSet` when `id != ""`
   - **Shadow implementation:** Checks both `!= null && != ""` to match provider exactly
   - **Result:** Both null and empty string result in no `diskEncryptionSet` object in API payload

2. **List Index Stability:**
   - **Concern:** Changing disk order or adding/removing disks could cause mismatches
   - **Mitigation:** ForceNew tracking uses `jsonencode([for disk ...])` to capture the complete ordered list
   - **Result:** Any change in disk count, order, or encryption set IDs triggers replacement

3. **Merge Pattern:**
   - **Pattern:** Using `merge()` to conditionally add `diskEncryptionSet` object
   - **Verification:** Matches provider's conditional pointer assignment pattern
   - **Result:** Clean object structure without null nested objects when field is absent

4. **Resource Deletion:**
   - **Scenario:** If disk encryption set is deleted but still referenced
   - **Behavior:** Azure API will reject the operation with appropriate error
   - **Shadow handling:** Passes through the ID value as-is, letting Azure API validate

5. **Cross-Disk Dependencies:**
   - **Consideration:** Each disk's encryption set ID is independent
   - **Implementation:** Properly iterates through all disks, applying per-disk logic
   - **Result:** Supports mixed scenarios (some disks encrypted, some not)

### Idempotency

**Verification:** 
- Empty string and null both result in no `diskEncryptionSet` object
- Non-empty strings always produce identical `diskEncryptionSet.id` structure
- ForceNew triggers prevent unexpected updates
- List ordering is preserved through `for` expression

**Result:** ✅ Implementation is idempotent

### Safe References

**Analysis:**
```hcl
data_disk.disk_encryption_set_id != null && data_disk.disk_encryption_set_id != ""
```

**Safety:** ✅ Checks for null before comparing to empty string, preventing errors when field is absent.

## Checklist

- ✅ Property in correct local (`body`)
- ✅ ForceNew wrapped in `replace_triggers_external_values` with stable key
- ✅ All logic EXACTLY replicated from provider (conditional assignment with merge)
- ✅ Validations analyzed - Azure Resource ID validation skipped per rules
- ✅ Hidden fields checked - none found
- ✅ Deferred work checked - no `following.md` file exists
- ✅ Critical review completed (null semantics, list iteration, merge pattern, idempotency)
- ✅ Edge Case Analysis included (null vs empty, list stability, merge pattern, deletion, cross-disk dependencies)
- ✅ Proof document created
- ✅ Ready for track.md update to "Pending"
- ✅ Self-Review: Only implemented disk_encryption_set_id (Task #37), no other fields added

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-08
**Task:** #37 - data_disk.disk_encryption_set_id

### Validation Results

✅ **ForceNew Logic:** Simple ForceNew with `ForceNew: true` in schema - correctly implemented using Mode 1 (Direct Value Tracking with stable key wrapping)

✅ **Stable Keys:** Key `data_disk_disk_encryption_set_id` is always present in `replace_triggers_external_values`, using empty string `""` when data_disk is null

✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase, single-phase pattern verified)

✅ **Type Conversion:** No conversion needed (String → String)

✅ **Null Handling:** Correctly implements provider's conditional logic: only adds `diskEncryptionSet` object when `id != null && id != ""`

✅ **Conditional Assignment:** Exactly replicates provider code (lines 215-219) using merge pattern to conditionally add nested object

✅ **Merge Pattern:** No duplicate parent keys detected - `managedDisk` appears once, with nested merge for conditional `diskEncryptionSet`

✅ **Validations:** Azure Resource ID validation (`validate.DiskEncryptionSetID`) correctly skipped per executor.md rules

✅ **Deferred Work Completion:** No `following.md` file exists - no deferred work to complete

✅ **Edge Cases:** Comprehensive analysis included covering null vs empty string semantics, list iteration safety, merge pattern correctness, resource deletion scenarios, and cross-disk independence

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The conditional assignment logic matches the provider's Go code precisely (lines 215-219), using merge to conditionally add the `diskEncryptionSet` object only when the field is non-null and non-empty. The ForceNew tracking correctly uses Mode 1 with stable key wrapping, and all edge cases are properly handled.

**Status:** APPROVED ✅

---
