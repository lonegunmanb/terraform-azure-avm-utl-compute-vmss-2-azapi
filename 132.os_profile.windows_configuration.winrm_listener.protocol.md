# Task #132: os_profile.windows_configuration.winrm_listener.protocol Argument

## Summary

Implemented the `protocol` field for the `winrm_listener` block within the Windows configuration of an orchestrated VMSS. This field is required and specifies the WinRM listener protocol (Http or Https). The implementation directly assigns the protocol value from the Terraform variable to the Azure API property with proper validation and ForceNew tracking.

## Shadow Implementation

```hcl
locals {
  # In replace_triggers_external_values:
  replace_triggers_external_values = {
    # ... other fields ...
    windows_configuration_winrm_listener_protocol = {
      value = var.orchestrated_virtual_machine_scale_set_os_profile != null && var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration != null && var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener != null ? jsonencode([for listener in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener : listener.protocol]) : ""
    }
  }

  # In body:
  body = {
    properties = {
      virtualMachineProfile = {
        osProfile = {
          windowsConfiguration = {
            winRM = {
              listeners = [
                for listener in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener : {
                  protocol = listener.protocol
                  # certificateUrl = ... # Task #133
                }
              ]
            }
          }
        }
      }
    }
  }
}
```

**variables.tf validation:**
```hcl
variable "orchestrated_virtual_machine_scale_set_os_profile" {
  # ... type definition ...

  validation {
    condition = (
      var.orchestrated_virtual_machine_scale_set_os_profile == null ||
      var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration == null ||
      var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener == null ||
      alltrue([
        for listener in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener :
        contains(["Http", "Https"], listener.protocol)
      ])
    )
    error_message = "Each winrm_listener.protocol must be either 'Http' or 'Https'."
  }
}
```

## Create Phase Verification

### Pattern Identification

Queried the expand function to understand how `protocol` is processed within `winrm_listener`:

**Pattern:** Single-phase creation

The `protocol` field is processed during the Create phase within the `expandWinRMListenerVMSS` function:

```go
func expandWinRMListenerVMSS(input []interface{}) *virtualmachinescalesets.WinRMConfiguration {
    listeners := make([]virtualmachinescalesets.WinRMListener, 0)

    for _, v := range input {
        raw := v.(map[string]interface{})

        listener := virtualmachinescalesets.WinRMListener{
            Protocol: pointer.To(virtualmachinescalesets.ProtocolTypes(raw["protocol"].(string))),
        }

        certificateUrl := raw["certificate_url"].(string)
        if certificateUrl != "" {
            listener.CertificateURL = pointer.To(certificateUrl)
        }

        listeners = append(listeners, listener)
    }

    return &virtualmachinescalesets.WinRMConfiguration{
        Listeners: &listeners,
    }
}
```

**Classification:** Create phase → Assign to `local.body`

### Decision

The `protocol` field is assigned directly during Create phase as part of the winRM listeners array construction.

## Assignment Path Verification

### Predicted Path

`body.properties.virtualMachineProfile.osProfile.windowsConfiguration.winRM.listeners[].protocol`

### Go Code Evidence

From the expand function `expandWinRMListenerVMSS`:

```go
listener := virtualmachinescalesets.WinRMListener{
    Protocol: pointer.To(virtualmachinescalesets.ProtocolTypes(raw["protocol"].(string))),
}
// ...
listeners = append(listeners, listener)

return &virtualmachinescalesets.WinRMConfiguration{
    Listeners: &listeners,
}
```

The assignment chain (from parent Task #131 verification):
1. `listener.Protocol = pointer.To(...)` - assigns Protocol to each listener in the array
2. `winConfig.WinRM = expandWinRMListenerVMSS(...)` - returns WinRMConfiguration with listeners array
3. `osProfile.WindowsConfiguration = &winConfig` - assigns WindowsConfiguration to osProfile
4. `virtualMachineProfile.OsProfile = vmssOsProfile` - assigns osProfile to virtualMachineProfile
5. `props.Properties.VirtualMachineProfile = &virtualMachineProfile` - final assignment to properties

### Verified Path

`body.properties.virtualMachineProfile.osProfile.windowsConfiguration.winRM.listeners[].protocol`

### Path Comparison

✅ **Match:** Predicted path matches the verified path from Go code.

## Provider Schema

From `winRmListenerSchema()` in `shared_schema.go`:

```go
func winRmListenerSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeSet,
        Optional: true,
        // Whilst the SDK allows you to modify this, the API does not:
        //   Code="PropertyChangeNotAllowed"
        //   Message="Changing property 'windowsConfiguration.winRM.listeners' is not allowed."
        //   Target="windowsConfiguration.winRM.listeners"
        ForceNew: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "protocol": {
                    Type:     pluginsdk.TypeString,
                    Required: true,
                    ForceNew: true,
                    ValidateFunc: validation.StringInSlice([]string{
                        string(virtualmachines.ProtocolTypesHTTP),
                        string(virtualmachines.ProtocolTypesHTTPS),
                    }, false),
                },

                "certificate_url": {
                    Type:         pluginsdk.TypeString,
                    Optional:     true,
                    ForceNew:     true,
                    ValidateFunc: keyVaultValidate.NestedItemId,
                },
            },
        },
    }
}
```

**Key Properties:**
- `Type: TypeString` - String value
- `Required: true` - Must be provided when winrm_listener is specified
- `ForceNew: true` - Changes require resource replacement
- `ValidateFunc: validation.StringInSlice(["Http", "Https"], false)` - Must be either "Http" or "Https"

## Azure API Schema

From Azure API query for `body.properties.virtualMachineProfile.osProfile.windowsConfiguration.winRM.listeners`:

```
List(ObjectWithOptionalAttrs(map[string]Type{"certificateUrl":String, "protocol":String}, []string{"certificateUrl", "protocol"}))
```

The `protocol` property is a string within each listener object in the listeners array. Both `certificateUrl` and `protocol` are optional at the API level, but the provider enforces `protocol` as required.

## Hidden Fields

No hidden fields detected. The `expandWinRMListenerVMSS` function only processes the fields defined in the Terraform schema:
- `protocol` (this task)
- `certificate_url` (Task #133)

## Mapping

| Terraform Field | Azure API Field | Transformation |
|----------------|-----------------|----------------|
| protocol | protocol | Direct assignment (case-sensitive) |

**Naming Convention:**
- Terraform uses `protocol` (lowercase)
- Azure API uses `protocol` (lowercase)
- No transformation needed

**Value Mapping:**
The provider schema validates against `virtualmachines.ProtocolTypesHTTP` and `virtualmachines.ProtocolTypesHTTPS`, which correspond to the string values "Http" and "Https" (case-sensitive). The Azure API expects these exact values.

## Special Handling

### 1. Validation

**Requirement:** Protocol must be either "Http" or "Https" (case-sensitive).

**Implementation:** Added validation block in `variables.tf`:

```hcl
validation {
  condition = (
    var.orchestrated_virtual_machine_scale_set_os_profile == null ||
    var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration == null ||
    var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener == null ||
    alltrue([
      for listener in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener :
      contains(["Http", "Https"], listener.protocol)
    ])
  )
  error_message = "Each winrm_listener.protocol must be either 'Http' or 'Https'."
}
```

**Evidence:** This EXACTLY replicates the provider's validation logic from `validation.StringInSlice(["Http", "Https"], false)`.

### 2. ForceNew Tracking

**Requirement:** The schema marks `protocol` as `ForceNew: true` because the Azure API doesn't allow modifying WinRM listeners.

**Implementation:** Added to `replace_triggers_external_values`:

```hcl
windows_configuration_winrm_listener_protocol = {
  value = var.orchestrated_virtual_machine_scale_set_os_profile != null && 
          var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration != null && 
          var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener != null ? 
          jsonencode([for listener in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener : listener.protocol]) : 
          ""
}
```

**Mode 1 - Direct Value Tracking:** The key `windows_configuration_winrm_listener_protocol` is always present. The value is wrapped in an object to keep the key stable, and any change to the protocol values in the listeners array will trigger replacement.

**Rationale:** The parent block (winrm_listener) is already ForceNew, and this field is Required within that block, so any change to protocols requires resource replacement to match Azure API constraints.

### 3. Set to Array Iteration

The parent skeleton (Task #131) uses a `for` loop to iterate over the winrm_listener set:

```hcl
listeners = [
  for listener in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.winrm_listener : {
    protocol = listener.protocol
    # certificateUrl = ... # Task #133
  }
]
```

This correctly accesses the `protocol` field from each listener object in the set.

## Deferred Work Completion

Checked `following.md` - no work was deferred to this task.

## Critical Review & Edge Cases

### Edge Case Analysis

1. **Null Semantics:**
   - When `winrm_listener` is `null` or empty: The `protocol` field is not created (handled by parent Task #131 conditional)
   - When `winrm_listener` exists but is empty set: The parent conditional prevents creation of the winRM object
   - The `protocol` field is Required in the schema, so it must be present for each listener when the set is non-empty

2. **Value Constraints:**
   - The validation enforces exact case-sensitive values: "Http" or "Https"
   - The provider schema uses `validation.StringInSlice([], false)` where the second parameter `false` means case-sensitive
   - Implementation matches this exactly with `contains(["Http", "Https"], listener.protocol)`

3. **ForceNew Behavior:**
   - Any change to protocol values triggers replacement
   - Adding/removing listeners triggers replacement (handled by parent block)
   - The jsonencode approach in replace_triggers ensures the entire array of protocols is tracked
   - Empty array (`[]`) vs no field distinction: When winrm_listener is null, the trigger value is empty string `""`, which is stable

4. **Set Iteration Safety:**
   - The `for listener in ...` correctly iterates over all listeners in the set
   - Each listener must have a `protocol` field (Required in schema)
   - The direct access `listener.protocol` is safe because protocol is Required

5. **Idempotency:**
   - The implementation is idempotent: repeated applies with same protocol values produce identical API requests
   - No order-dependent logic (though sets are unordered, the for loop creates an array in a stable manner)
   - The protocol values are preserved exactly as provided

6. **Cross-Field Dependencies:**
   - According to the provider documentation, `certificate_url` must be specified when protocol is "Https"
   - This validation belongs to Task #133 (certificate_url field) per ownership rules in executor.md
   - No cross-field validation is needed in this task

### Null Boundary Verification

- **Null winrm_listener:** Handled by parent conditional in Task #131
- **Empty set winrm_listener:** Handled by `length() > 0` check in parent conditional
- **Protocol is Required:** Cannot be null when listener exists, enforced by schema
- **Empty string protocol:** Would fail validation (not in ["Http", "Https"])

### Safe References

All references are safe:
- Parent null checks in Task #131 ensure safe access to `.windows_configuration.winrm_listener`
- The `for` loop safely iterates over the set
- Direct field access `.protocol` is safe because protocol is Required in the schema

## Checklist

- ✅ Property in correct local (`body.properties.virtualMachineProfile.osProfile.windowsConfiguration.winRM.listeners[].protocol`)
- ✅ ForceNew wrapped: `windows_configuration_winrm_listener_protocol = { value = ... }`
- ✅ Validation IMPLEMENTED in variables.tf (MANDATORY - replicates StringInSlice validation)
- ✅ Hidden fields checked (none for this field)
- ✅ Deferred work: None to this task
- ✅ Critical review (null semantics, value constraints, ForceNew tracking, safe references)
- ✅ Edge Case Analysis completed
- ✅ Proof created
- ✅ Implementation exactly matches provider behavior from `expandWinRMListenerVMSS`

## Track.md Update

Status updated to "Pending for check" for Task #132.

---

**Implementation Status:** ✅ Complete

This implementation EXACTLY replicates the provider behavior:
1. Direct protocol value assignment from Terraform to Azure API
2. Case-sensitive validation for "Http" or "Https" values
3. ForceNew tracking for any protocol changes
4. Required field enforcement through schema and validation
5. Proper null handling through parent block conditionals

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #132 - os_profile.windows_configuration.winrm_listener.protocol

### Validation Results

✅ **ForceNew Logic:** Simple ForceNew (schema `ForceNew: true`) correctly implemented using Mode 1 - Direct Value Tracking. Key `windows_configuration_winrm_listener_protocol` is stable (always present), value wraps jsonencode of protocol array to detect any changes.

✅ **Stable Keys:** Key is always present in `replace_triggers_external_values` with empty string when winrm_listener is null.

✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase). Evidence from proof document shows protocol is assigned in `expandWinRMListenerVMSS` during Create phase.

✅ **Type Conversion:** Correct conversion from Terraform `set(object)` to Azure API array using `for listener in ...` iteration. Each listener.protocol is directly assigned.

✅ **Null Handling:** Properly conditional on parent block existence via Task #131 skeleton. Safe null propagation through parent checks.

✅ **Validations:** Validation EXACTLY replicates provider's `validation.StringInSlice(["Http", "Https"], false)` with case-sensitive check. Implementation uses `contains(["Http", "Https"], listener.protocol)` applied to all listeners with `alltrue([for listener ...])`.

✅ **Assignment Path:** Verified path `body.properties.virtualMachineProfile.osProfile.windowsConfiguration.winRM.listeners[].protocol` matches Go code evidence from `expandWinRMListenerVMSS`.

✅ **Field Placement:** Correctly placed in `body` (not `sensitive_body`) - protocol is not a sensitive field.

✅ **Deferred Work Completion:** No deferred work for this task (verified in following.md).

✅ **Deferred Work Recording:** No deferrals made by this task.

✅ **Edge Cases:** Comprehensive edge case analysis in proof document covers null semantics, value constraints, ForceNew behavior, set iteration safety, idempotency, and cross-field dependencies.

✅ **Shared Path Merge Check:** No shared path merge issues. The winRM block is constructed once with listeners array inside.

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The executor:
- Correctly used Mode 1 ForceNew tracking (direct value with wrapped object)
- Implemented EXACT validation logic from provider schema (case-sensitive StringInSlice)
- Properly traced assignment path through Go code
- Applied proper null handling via parent conditional
- Used correct iteration over set to build listeners array
- Required field protocol is directly assigned in each listener object

No deviations, simplifications, or "safer alternatives" were found. The implementation matches provider behavior line-by-line.

**Status:** APPROVED ✅

---
