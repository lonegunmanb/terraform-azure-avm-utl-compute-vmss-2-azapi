# Task #78: network_interface.ip_configuration.public_ip_address.name - Block Argument

## Summary

Implemented the `network_interface.ip_configuration.public_ip_address.name` field, which is a required string that specifies the name of the Public IP Address Configuration. The field is directly assigned to the Azure API's `publicIPAddressConfiguration.name` property with a validation ensuring the name is not empty.

## Shadow Implementation

```hcl
publicIPAddressConfiguration = {
  name = ip_config.public_ip_address[0].name # <-
  # properties = { # Task #79-83
  #   domainNameLabel = ... # Task #79
  #   idleTimeoutInMinutes = ... # Task #80
  #   publicIPPrefix = { id = ... } # Task #81
  #   publicIPAddressVersion = ... # Task #83
  #   ipTags = [ # Task #84-86
  #     { tag = ..., ipTagType = ... } # Task #85, #86
  #   ]
  # }
  # sku = { name = ... } # Task #82
}
```

**Validation in variables.tf:**
```hcl
validation { # <-
  condition = ( # <-
    var.orchestrated_virtual_machine_scale_set_network_interface == null || # <-
    alltrue([ # <-
      for nic in var.orchestrated_virtual_machine_scale_set_network_interface : alltrue([ # <-
        for ip_config in nic.ip_configuration : # <-
        ip_config.public_ip_address == null || alltrue([ # <-
          for pub_ip in ip_config.public_ip_address : # <-
          pub_ip.name != null && pub_ip.name != "" # <-
        ]) # <-
      ]) # <-
    ]) # <-
  ) # <-
  error_message = "The public_ip_address name must not be empty." # <-
} # <-
```

## Create Phase Verification

### Query Result

From Task #77's Create phase verification (reused):

```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
    // ... (setup code)
    
    if v, ok := d.GetOk("network_interface"); ok {
        networkInterfaces, err := ExpandOrchestratedVirtualMachineScaleSetNetworkInterface(v.([]interface{}))
        if err != nil {
            return fmt.Errorf("expanding `network_interface`: %w", err)
        }

        networkProfile.NetworkInterfaceConfigurations = networkInterfaces
        virtualMachineProfile.NetworkProfile = networkProfile
    }
    
    // ...
    props.Properties.VirtualMachineProfile = &virtualMachineProfile
    
    if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
        return fmt.Errorf("creating Orchestrated %s: %w", id, err)
    }
}
```

### Create Pattern

**Pattern:** Single-phase create

The resource uses `CreateOrUpdateThenPoll` which is a single-phase creation pattern. The `name` field is expanded as part of the public IP address configuration before the API call.

### Field Phase Classification

**Phase:** Create phase

The `name` field is:
1. Expanded via `ExpandOrchestratedVirtualMachineScaleSetNetworkInterface` → `expandOrchestratedVirtualMachineScaleSetIPConfiguration` → `expandOrchestratedVirtualMachineScaleSetPublicIPAddress`
2. Set in the `virtualMachineProfile.NetworkProfile` before the create call
3. Sent to the API in the initial `CreateOrUpdateThenPoll` request

**Decision:** Implement in `local.body` (Create phase)

## Assignment Path Verification

### Predicted Path

Based on parent skeleton from Task #77:
```
body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].properties.ipConfigurations[].properties.publicIPAddressConfiguration.name
```

### Go Code Evidence

From `expandOrchestratedVirtualMachineScaleSetPublicIPAddress`:

```go
func expandOrchestratedVirtualMachineScaleSetPublicIPAddress(raw map[string]interface{}) *virtualmachinescalesets.VirtualMachineScaleSetPublicIPAddressConfiguration {
    ipTagsRaw := raw["ip_tag"].([]interface{})
    ipTags := make([]virtualmachinescalesets.VirtualMachineScaleSetIPTag, 0)
    for _, ipTagV := range ipTagsRaw {
        ipTagRaw := ipTagV.(map[string]interface{})
        ipTags = append(ipTags, virtualmachinescalesets.VirtualMachineScaleSetIPTag{
            Tag:       pointer.To(ipTagRaw["tag"].(string)),
            IPTagType: pointer.To(ipTagRaw["type"].(string)),
        })
    }

    publicIPAddressConfig := virtualmachinescalesets.VirtualMachineScaleSetPublicIPAddressConfiguration{
        Name: raw["name"].(string), // ← Direct assignment to .Name field (root level)
        Properties: &virtualmachinescalesets.VirtualMachineScaleSetPublicIPAddressConfigurationProperties{
            IPTags: &ipTags,
        },
    }
    
    // ... other fields assigned to Properties
    
    return &publicIPAddressConfig
}
```

From `expandOrchestratedVirtualMachineScaleSetIPConfiguration`:

```go
ipConfiguration := virtualmachinescalesets.VirtualMachineScaleSetIPConfiguration{
    Name: raw["name"].(string),
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetIPConfigurationProperties{
        Primary:                               pointer.To(primary),
        PrivateIPAddressVersion:               pointer.To(version),
        // ... other fields
    },
}

publicIPConfigsRaw := raw["public_ip_address"].([]interface{})
if len(publicIPConfigsRaw) > 0 && publicIPConfigsRaw[0] != nil {
    publicIPConfigRaw := publicIPConfigsRaw[0].(map[string]interface{})
    publicIPAddressConfig := expandOrchestratedVirtualMachineScaleSetPublicIPAddress(publicIPConfigRaw)
    ipConfiguration.Properties.PublicIPAddressConfiguration = publicIPAddressConfig // ← Assigned to .Properties.PublicIPAddressConfiguration
}

return &ipConfiguration, nil
```

### Verified Path

```
body
└── properties
    └── virtualMachineProfile
        └── networkProfile
            └── networkInterfaceConfigurations[]
                └── properties
                    └── ipConfigurations[]
                        └── properties
                            └── publicIPAddressConfiguration (struct assigned here)
                                └── name (field at root level of publicIPAddressConfiguration)
```

### Path Comparison

**Match:** ✅ The predicted path matches the verified path exactly.

The assignment chain:
1. `publicIPAddressConfig.Name = raw["name"].(string)` - Direct assignment to root-level field
2. `ipConfiguration.Properties.PublicIPAddressConfiguration = publicIPAddressConfig` - Entire struct assigned
3. Parent structures already established by Task #77

**IMPORTANT:** The `name` field is at the ROOT level of `publicIPAddressConfiguration`, NOT inside the `properties` sub-object. The Go struct shows:
```go
type VirtualMachineScaleSetPublicIPAddressConfiguration struct {
    Name       string                                                                `json:"name"`
    Properties *VirtualMachineScaleSetPublicIPAddressConfigurationProperties        `json:"properties,omitempty"`
    Sku        *PublicIPAddressSku                                                  `json:"sku,omitempty"`
}
```

## Provider Schema

```go
func orchestratedVirtualMachineScaleSetPublicIPAddressSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "name": {
                    Type:         pluginsdk.TypeString,
                    Required:     true, // ← Required field
                    ValidateFunc: validation.StringIsNotEmpty, // ← Must not be empty
                },
                // ... other fields
            },
        },
    }
}
```

**Field Properties:**
- **Type:** `TypeString` (string)
- **Required:** `true` (cannot be omitted when public_ip_address block is specified)
- **ValidateFunc:** `validation.StringIsNotEmpty` (must not be empty string)
- **ForceNew:** `false` (not marked, can be updated)
- **Computed:** `false` (user must provide)
- **Sensitive:** `false` (not sensitive)

## Azure API Schema

From Task #77's analysis, the Azure API schema for `publicIPAddressConfiguration`:

```
ObjectWithOptionalAttrs(map[string]Type{
  "name": String, // ← Root-level field, not inside properties
  "properties": ObjectWithOptionalAttrs(map[string]Type{
    "deleteOption": String,
    "dnsSettings": ...,
    "idleTimeoutInMinutes": Number,
    "ipTags": ...,
    "publicIPAddressVersion": String,
    "publicIPPrefix": ...
  }, [...]),
  "sku": ...
}, [])
```

**API Field:** `name` (String, root level of publicIPAddressConfiguration)

**Note:** The Azure API schema shows `name` as a root-level field in the `publicIPAddressConfiguration` object, separate from the `properties` sub-object.

## Hidden Fields Check

### Expand Function Analysis

From the expand function evidence above:

```go
publicIPAddressConfig := virtualmachinescalesets.VirtualMachineScaleSetPublicIPAddressConfiguration{
    Name: raw["name"].(string), // ← Direct assignment from raw input
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetPublicIPAddressConfigurationProperties{
        IPTags: &ipTags,
    },
}
```

### Hidden Fields Result

**NO HIDDEN FIELDS** - The `name` field is directly assigned from user input with no modifications, defaults, or computed values:
- No hardcoded prefix/suffix
- No transformation logic
- No conditional defaults
- Pure passthrough of user-provided value

## Mapping

| Terraform Field | Azure API Field | Type |
|----------------|----------------|------|
| `public_ip_address[0].name` | `publicIPAddressConfiguration.name` | String (root level) |

**Snake case → Camel case:** `name` → `name` (no transformation, same in both)

## Special Handling

### Required Field

**Required Status:** The field is Required when the parent `public_ip_address` block is specified.

- Parent block (`public_ip_address`) is Optional
- When parent block is present, `name` is Required
- Our implementation accesses `ip_config.public_ip_address[0].name` directly
- Parent skeleton (Task #77) already checks `ip_config.public_ip_address != null && length(ip_config.public_ip_address) > 0`
- Safe access: No null check needed since parent ensures list has at least one element

### Validation

**Validation:** `validation.StringIsNotEmpty`

Implemented in `variables.tf`:

```hcl
validation {
  condition = (
    var.orchestrated_virtual_machine_scale_set_network_interface == null ||
    alltrue([
      for nic in var.orchestrated_virtual_machine_scale_set_network_interface : alltrue([
        for ip_config in nic.ip_configuration :
        ip_config.public_ip_address == null || alltrue([
          for pub_ip in ip_config.public_ip_address :
          pub_ip.name != null && pub_ip.name != ""
        ])
      ])
    ])
  )
  error_message = "The public_ip_address name must not be empty."
}
```

**Logic:**
1. If network_interface is null → pass
2. If public_ip_address is null → pass
3. If public_ip_address is present → name must not be null AND not be empty string
4. Matches provider's `validation.StringIsNotEmpty` exactly

**Note:** The schema already defines `name = string` (required, not optional), so null cannot occur naturally. The validation adds runtime enforcement at plan time.

### ForceNew Handling

**ForceNew:** Not applicable

- Schema does not mark field as `ForceNew: true`
- Provider allows updating the name without replacement
- No CustomizeDiff logic for this field
- **Implementation:** No entry in `replace_triggers_external_values`

### Root-Level Field Position

**CRITICAL:** The `name` field is at the ROOT of `publicIPAddressConfiguration`, NOT inside `properties`.

This is evident from:
1. Go struct definition showing `Name` as top-level field
2. Azure API schema showing `name` separate from `properties` object
3. Expand function assigning directly to struct root: `Name: raw["name"].(string)`

Our implementation correctly places it at the root:
```hcl
publicIPAddressConfiguration = {
  name = ip_config.public_ip_address[0].name  # ← Root level, correct
  # properties = { ... }  # ← Separate sub-object for other fields
}
```

## Deferred Work Completion

Checked `following.md` for any work deferred to Task #78: **None found.**

No validation, logic, or implementation was deferred to this task from earlier tasks.

## Critical Review & Edge Case Analysis

### Null Semantics

**Null meaning:** "Invalid configuration - Required field missing"

The field is Required when parent block is present:
- Variable definition: `name = string` (not optional)
- Schema: `Required: true`
- Validation: Ensures not null and not empty
- If parent block exists but name is missing → Terraform validation error at plan time

**Behavior:**
- Parent block absent → entire `publicIPAddressConfiguration` omitted (handled by Task #77)
- Parent block present, name missing → validation error (prevented by variables.tf)
- Parent block present, name empty string → validation error (prevented by variables.tf)
- Parent block present, name valid → name assigned to API

### Edge Cases

1. **Empty string:**
   - Validation: `pub_ip.name != ""`
   - Matches provider: `validation.StringIsNotEmpty`
   - Result: Terraform plan fails with error message
   - ✅ Correctly handled

2. **Whitespace-only string:**
   - Provider validation: `StringIsNotEmpty` allows whitespace (only checks length > 0)
   - Our validation: `!= ""` allows whitespace (matches provider)
   - Azure API: Will validate whitespace-only names
   - ✅ Matches provider behavior (let Azure API validate further)

3. **Special characters:**
   - Provider validation: Only checks non-empty, no character restrictions
   - Our validation: Only checks non-empty, no character restrictions
   - Azure API: Has specific naming rules (documented but not enforced in provider)
   - ✅ Matches provider behavior (defer to Azure API)

4. **Name length:**
   - Provider validation: No length restriction enforced
   - Our validation: No length restriction enforced
   - Azure API: Has length restrictions (enforced server-side)
   - ✅ Matches provider behavior (defer to Azure API)

5. **Null vs empty list:**
   - Check: `ip_config.public_ip_address == null || alltrue([...])`
   - Parent skeleton checks: `ip_config.public_ip_address != null && length(ip_config.public_ip_address) > 0`
   - Combined effect: Only validate name when list is non-null and non-empty
   - ✅ Correctly coordinated with parent block

6. **Multiple items in list:**
   - Variable type: `list(object({...}))`
   - Schema: TypeList (effectively maxItems = 1 per Task #77)
   - Access: `ip_config.public_ip_address[0].name` (first element)
   - Validation: Loops through all items `for pub_ip in ip_config.public_ip_address`
   - ✅ Validates all items even though only first is used (matches provider pattern)

### Idempotency

**Idempotent:** ✅ Yes

- Direct value assignment: `name = ip_config.public_ip_address[0].name`
- No transformation or computation
- No state-dependent logic
- No order dependencies
- Repeated applies with same input produce identical output
- ✅ Fully idempotent

### Safe References

**Safe:** ✅ Yes

Parent block (Task #77) ensures safety:
```hcl
ip_config.public_ip_address != null && length(ip_config.public_ip_address) > 0 ? {
  publicIPAddressConfiguration = {
    name = ip_config.public_ip_address[0].name  # ← Safe: parent checked null and length > 0
```

Safety chain:
1. Parent checks `!= null` before accessing
2. Parent checks `length > 0` before accessing `[0]`
3. Field is Required in schema, so `.name` always exists when block present
4. Validation adds extra runtime check for null/empty
5. ✅ All access paths are safe

### Integration with Sibling Fields

**Integration:** ✅ Correct

The implementation:
- Adds `name` at root level of `publicIPAddressConfiguration`
- Other fields (Tasks #79-86) will add `properties` and `sku` as siblings
- Structure matches Azure API schema exactly
- No conflicts with other fields
- ✅ Ready for sibling fields to be added

## Checklist

- ✅ Property in correct local (`local.body`)
- ✅ ForceNew handling (N/A - not a ForceNew field)
- ✅ All logic exactly replicated from provider (direct assignment, no transformations)
- ✅ Validations implemented in variables.tf (MANDATORY - StringIsNotEmpty replicated)
- ✅ TODO comments (N/A - not a sensitive field, no independent ephemeral variable)
- ✅ Hidden fields checked (none found - pure passthrough)
- ✅ Deferred work in following.md (N/A - no work deferred from this task)
- ✅ Deferred work from following.md (checked - none found)
- ✅ Critical review (null semantics, edge cases, idempotency, safe references)
- ✅ Edge Case Analysis section included
- ✅ Proof created
- ✅ `track.md` status will be updated to "Pending for check"
- ✅ Self-review: Added ONLY the name field implementation for task #78, no other fields

## Implementation Evidence

### Code Changes

1. **migrate_main.tf:** Replaced comment placeholder with actual field
   ```hcl
   name = ip_config.public_ip_address[0].name
   ```

2. **variables.tf:** Added validation block
   ```hcl
   validation {
     condition = (
       var.orchestrated_virtual_machine_scale_set_network_interface == null ||
       alltrue([
         for nic in var.orchestrated_virtual_machine_scale_set_network_interface : alltrue([
           for ip_config in nic.ip_configuration :
           ip_config.public_ip_address == null || alltrue([
             for pub_ip in ip_config.public_ip_address :
             pub_ip.name != null && pub_ip.name != ""
           ])
         ])
       ])
     )
     error_message = "The public_ip_address name must not be empty."
   }
   ```

### Compliance Statement

This implementation EXACTLY replicates the provider behavior:

**Provider Logic:**
```go
publicIPAddressConfig := virtualmachinescalesets.VirtualMachineScaleSetPublicIPAddressConfiguration{
    Name: raw["name"].(string),  // Direct assignment, no transformation
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetPublicIPAddressConfigurationProperties{
        IPTags: &ipTags,
    },
}
```

**Shadow Implementation:**
```hcl
publicIPAddressConfiguration = {
  name = ip_config.public_ip_address[0].name  # Direct assignment, matches provider
  # properties = { ... }  # Separate object for other fields
}
```

**Provider Validation:**
```go
"name": {
    Type:         pluginsdk.TypeString,
    Required:     true,
    ValidateFunc: validation.StringIsNotEmpty,
},
```

**Shadow Validation:**
```hcl
condition = (
  ... alltrue([
    for pub_ip in ip_config.public_ip_address :
    pub_ip.name != null && pub_ip.name != ""  # Exactly replicates StringIsNotEmpty
  ])
)
error_message = "The public_ip_address name must not be empty."
```

✅ No deviations, no simplifications, no "safer alternatives" - exact replication achieved.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-09
**Task:** #78 - network_interface.ip_configuration.public_ip_address.name

### Validation Results

✅ **ForceNew Logic:** N/A - Not a ForceNew field
✅ **Stable Keys:** N/A - Not in replace_triggers_external_values
✅ **Phase Detection:** Field correctly placed in local.body (Create phase)
✅ **Type Conversion:** String to String - direct passthrough, no conversion needed
✅ **Null Handling:** Correctly handled by parent skeleton's conditional check
✅ **Validations:** Provider's validation.StringIsNotEmpty exactly replicated in variables.tf
✅ **Deferred Work Completion:** Checked following.md - no deferred work for this task
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed (empty string, whitespace, null vs empty list, multiple items)
✅ **Root-Level Field Position:** CRITICAL - Correctly placed at root of publicIPAddressConfiguration, NOT inside properties
✅ **Shared Path Merge:** No merge conflicts - single field at root level
✅ **Safe References:** Parent skeleton (Task #77) ensures safe access with null and length checks
✅ **Idempotency:** Direct value assignment ensures full idempotency

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`:

**Provider Logic:**
- Direct assignment: `Name: raw["name"].(string)`
- Validation: `validation.StringIsNotEmpty`
- Root-level field in struct (not inside properties)

**Shadow Implementation:**
- Direct assignment: `name = ip_config.public_ip_address[0].name`
- Validation: `pub_ip.name != null && pub_ip.name != ""`
- Root-level field in HCL object (not inside properties)

**Critical Verification:**
- ✅ Field placement matches Azure API schema exactly (root level, separate from properties)
- ✅ Validation logic matches provider exactly (null check + empty string check)
- ✅ No transformation, no computation, pure passthrough
- ✅ Parent skeleton ensures safe access (null check + length check)
- ✅ Ready for sibling fields (properties, sku) to be added by future tasks

No deviations, simplifications, or "safer alternatives" were found. The implementation follows executor.md line-by-line.

**Status:** APPROVED ✅

---
