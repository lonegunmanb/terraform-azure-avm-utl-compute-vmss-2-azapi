# Task #73: network_interface.ip_configuration.load_balancer_backend_address_pool_ids

## Shadow Implementation

```hcl
ip_config.load_balancer_backend_address_pool_ids != null && length(ip_config.load_balancer_backend_address_pool_ids) > 0 ? { # <-
  loadBalancerBackendAddressPools = [ # <-
    for id in ip_config.load_balancer_backend_address_pool_ids : { # <-
      id = id # <-
    } # <-
  ] # <-
} : {}, # <-
```

## Summary

Implemented `load_balancer_backend_address_pool_ids` as an optional set of Load Balancer Backend Address Pool resource IDs, conditionally adding the `loadBalancerBackendAddressPools` array to the IP configuration when IDs are provided.

## Create Phase Verification

**Query Method:** `query_terraform_block_implementation_source_code` with `entrypoint_name=create`

**Pattern Identified:** Single-phase creation using `CreateOrUpdateThenPoll`

**Go Code Evidence:**
```go
// From resourceOrchestratedVirtualMachineScaleSetCreate
if v, ok := d.GetOk("network_interface"); ok {
    networkInterfaces, err := ExpandOrchestratedVirtualMachineScaleSetNetworkInterface(v.([]interface{}))
    if err != nil {
        return fmt.Errorf("expanding `network_interface`: %w", err)
    }

    networkProfile.NetworkInterfaceConfigurations = networkInterfaces
    virtualMachineProfile.NetworkProfile = networkProfile
}

// ...

props.Properties.VirtualMachineProfile = &virtualMachineProfile

log.Printf("[DEBUG] Creating Orchestrated %s.", id)
if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Field Classification:** Create phase - field is set before the `CreateOrUpdateThenPoll` call through the `ExpandOrchestratedVirtualMachineScaleSetNetworkInterface` expansion function.

**Decision:** Place in `local.body` (not `post_creation_updates`)

## Assignment Path Verification

**Predicted Path:** 
```
body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].properties.ipConfigurations[].properties.loadBalancerBackendAddressPools
```

**Go Code Evidence:**

1. **Field Read:**
```go
// From expandOrchestratedVirtualMachineScaleSetIPConfiguration
loadBalancerBackendAddressPoolIdsRaw := raw["load_balancer_backend_address_pool_ids"].(*pluginsdk.Set).List()
loadBalancerBackendAddressPoolIds := expandIDsToSubResources(loadBalancerBackendAddressPoolIdsRaw)
```

2. **SubResource Creation:**
```go
// From expandIDsToSubResources
func expandIDsToSubResources(input []interface{}) *[]virtualmachinescalesets.SubResource {
    ids := make([]virtualmachinescalesets.SubResource, 0)

    for _, v := range input {
        ids = append(ids, virtualmachinescalesets.SubResource{
            Id: pointer.To(v.(string)),
        })
    }

    return &ids
}
```

3. **Assignment to IPConfiguration Properties:**
```go
// From expandOrchestratedVirtualMachineScaleSetIPConfiguration
ipConfiguration := virtualmachinescalesets.VirtualMachineScaleSetIPConfiguration{
    Name: raw["name"].(string),
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetIPConfigurationProperties{
        // ...
        LoadBalancerBackendAddressPools: loadBalancerBackendAddressPoolIds,
        // ...
    },
}
```

4. **IP Configurations Array Assignment:**
```go
// From ExpandOrchestratedVirtualMachineScaleSetNetworkInterface
ipConfigurations := make([]virtualmachinescalesets.VirtualMachineScaleSetIPConfiguration, 0)
ipConfigurationsRaw := raw["ip_configuration"].([]interface{})
for _, configV := range ipConfigurationsRaw {
    configRaw := configV.(map[string]interface{})
    ipConfiguration, err := expandOrchestratedVirtualMachineScaleSetIPConfiguration(configRaw)
    if err != nil {
        return nil, err
    }

    ipConfigurations = append(ipConfigurations, *ipConfiguration)
}

config := virtualmachinescalesets.VirtualMachineScaleSetNetworkConfiguration{
    Name: raw["name"].(string),
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetNetworkConfigurationProperties{
        // ...
        IPConfigurations: ipConfigurations,
        // ...
    },
}
```

5. **Network Profile Assignment:**
```go
// From resourceOrchestratedVirtualMachineScaleSetCreate
networkProfile.NetworkInterfaceConfigurations = networkInterfaces
virtualMachineProfile.NetworkProfile = networkProfile
props.Properties.VirtualMachineProfile = &virtualMachineProfile
```

**Verified Path:** 
```
properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].properties.ipConfigurations[].properties.loadBalancerBackendAddressPools
```

**Path Comparison:** ✅ Match (adjusted for body vs properties root)

## Provider Schema

**Go Source:**
```go
// From orchestratedVirtualMachineScaleSetIPConfigurationSchema
"load_balancer_backend_address_pool_ids": {
    Type:     pluginsdk.TypeSet,
    Optional: true,
    Elem:     &pluginsdk.Schema{Type: pluginsdk.TypeString},
    Set:      pluginsdk.HashString,
},
```

**Schema Properties:**
- **Type:** Set of strings
- **Required:** No (Optional)
- **ForceNew:** No
- **Computed:** No
- **Default:** None
- **Validation:** None (accepts any string values)
- **DiffSuppressFunc:** None
- **ConflictsWith:** None

## Azure API Schema

**Resource Type:** `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

**Property Path:** `properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].properties.ipConfigurations[].properties.loadBalancerBackendAddressPools`

**API Type:** Array of SubResource objects, where each SubResource has:
- `id` (string): The resource ID of the Load Balancer Backend Address Pool

## Mapping

**Terraform → Azure API:**
- `load_balancer_backend_address_pool_ids` (set of strings) → `loadBalancerBackendAddressPools` (array of objects with `id` property)

**Naming Convention:**
- Terraform uses snake_case: `load_balancer_backend_address_pool_ids`
- Azure API uses camelCase: `loadBalancerBackendAddressPools`

## Special Handling

### No ForceNew
The field has no `ForceNew: true` in the schema, meaning changes can be applied without recreating the resource. Therefore, this field is NOT added to `replace_triggers_external_values`.

### No Validation
The provider schema has no validation functions. The field accepts any set of string values representing Load Balancer Backend Address Pool resource IDs.

### Conditional Rendering
Following the same pattern as `application_gateway_backend_address_pool_ids` (Task #71) and `application_security_group_ids` (Task #72), the field is only included in the Azure API payload when:
1. The value is not null
2. The set has at least one element

When these conditions are not met, an empty object `{}` is merged, effectively omitting the field.

### Array Transformation
Each ID in the Terraform set is transformed into an object with an `id` property:
```hcl
# Terraform input:
load_balancer_backend_address_pool_ids = [
  "/subscriptions/.../backendAddressPools/pool1",
  "/subscriptions/.../backendAddressPools/pool2"
]

# Azure API output:
loadBalancerBackendAddressPools = [
  { id = "/subscriptions/.../backendAddressPools/pool1" },
  { id = "/subscriptions/.../backendAddressPools/pool2" }
]
```

## Critical Review & Edge Case Analysis

### Null Semantics
- **`null` value:** Field is not set in Terraform config → API receives no `loadBalancerBackendAddressPools` property (omitted via empty object merge)
- **Empty set `[]`:** Set exists but has no elements → API receives no `loadBalancerBackendAddressPools` property (omitted via length check)
- **Meaning:** Both null and empty set result in the same behavior - the VM instances will not be connected to any Load Balancer Backend Address Pools

### Edge Cases

1. **Empty Set:** 
   - Input: `load_balancer_backend_address_pool_ids = []`
   - Condition: `length(ip_config.load_balancer_backend_address_pool_ids) > 0` returns false
   - Result: Empty object merged, field omitted from API payload
   - ✅ Safe

2. **Single ID:**
   - Input: Single Load Balancer Backend Address Pool ID in set
   - Result: Array with one SubResource object
   - ✅ Valid configuration

3. **Multiple IDs:**
   - Input: Multiple Load Balancer Backend Address Pool IDs
   - Result: Array with multiple SubResource objects
   - ✅ Supported by API (VMs can be in multiple backend pools)

4. **Invalid Resource ID Format:**
   - Provider has no validation on ID format
   - Azure API will reject invalid IDs during apply
   - ✅ Acceptable - API-level validation sufficient for resource IDs

5. **Duplicate IDs:**
   - Terraform `set` type automatically deduplicates
   - ✅ Safe - duplicates automatically prevented

### Idempotency
- ✅ Order-independent: Terraform set is unordered, and the for loop produces a consistent array
- ✅ No state-dependent logic: Field value depends only on current input
- ✅ Repeatable: Same input always produces same output

### Safe References
- ✅ Null check: `ip_config.load_balancer_backend_address_pool_ids != null` prevents null dereference
- ✅ Length check: `length(ip_config.load_balancer_backend_address_pool_ids) > 0` ensures non-empty before array creation
- ✅ For loop safety: Iterating over set is safe when length > 0

### Cross-Field Dependencies
No cross-field validations or dependencies with other fields. This field operates independently.

## Deferred Work Completion
No deferred work from `following.md` (file does not exist).

## Checklist

- ✅ Property in correct local (`local.body`)
- ✅ ForceNew: Not applicable (field is not ForceNew)
- ✅ Logic exactly replicated from provider (identical pattern to similar fields)
- ✅ Validations: None required (provider has no validations)
- ✅ Hidden fields: None
- ✅ Deferred work in following.md: N/A (no deferral needed)
- ✅ Deferred work from following.md: N/A (file doesn't exist)
- ✅ Critical review: Completed (null semantics, edge cases, idempotency, safe refs)
- ✅ Edge Case Analysis: Documented above
- ✅ Proof created: This document
- ✅ Track.md: Will update to "Pending for check"
- ✅ Self-Review: Only implemented Task #73, no other fields added

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-09
**Task:** #73 - network_interface.ip_configuration.load_balancer_backend_address_pool_ids

### Validation Results

✅ **ForceNew Logic:** Field is not ForceNew (schema shows Optional with no ForceNew). Correctly NOT added to replace_triggers_external_values.

✅ **Stable Keys:** Not applicable (field is not ForceNew, no replace_triggers entry)

✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase). Evidence from proof shows field set before CreateOrUpdateThenPoll call through ExpandOrchestratedVirtualMachineScaleSetNetworkInterface expansion function.

✅ **Type Conversion:** Correct conversion from Terraform `set(string)` to Azure API array of SubResource objects with `id` property. Each ID properly wrapped: `{ id = id }`

✅ **Null Handling:** Correct dual condition `!= null && length(...) > 0` ensures both null and empty set result in field omission via empty object merge. Matches provider behavior.

✅ **Validations:** None required. Provider schema has no ValidateFunc, ConflictsWith, or other validation constraints. Correctly not implemented.

✅ **Path Structure:** Verified correct nesting at `properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations[].properties.ipConfigurations[].properties.loadBalancerBackendAddressPools`

✅ **Shared Path Merge Check:** No duplicate parent keys detected. Field properly nested within ip_configuration properties merge. Structure uses proper nested merge pattern.

✅ **Implementation Pattern:** Matches established pattern from Task #71 (application_gateway_backend_address_pool_ids) and Task #72 (application_security_group_ids). Consistent approach across similar fields.

✅ **Deferred Work Completion:** No deferred work for this task (following.md does not exist)

✅ **Deferred Work Recording:** No deferrals made by this task

✅ **Edge Cases:** Comprehensive analysis covering null, empty set, single ID, multiple IDs, invalid IDs, duplicates. All edge cases properly handled. Idempotency verified (set type ensures order-independence and deduplication).

✅ **Scope Compliance:** Implementation only includes Task #73. No other fields added. Comments present for future tasks (#74-86) but not implemented.

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The field is correctly transformed from Terraform's `set(string)` to Azure API's array of SubResource objects, with proper null and empty set handling. The implementation follows the identical pattern established by similar fields (Tasks #71, #72), ensuring consistency across the codebase. No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
