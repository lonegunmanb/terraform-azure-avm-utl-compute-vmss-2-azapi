# Task #146: rolling_upgrade_policy.cross_zone_upgrades_enabled

## Summary
Implemented `rolling_upgrade_policy.cross_zone_upgrades_enabled` field with conditional logic - only set when scale set is zonal (zones specified). The field allows VMSS to ignore availability zone boundaries when constructing upgrade batches.

## Shadow Implementation

```hcl
# variables.tf
variable "orchestrated_virtual_machine_scale_set_rolling_upgrade_policy" {
  # ... existing fields ...
  
  validation {
    condition = (
      var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy == null ||
      var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.cross_zone_upgrades_enabled == null ||
      var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.cross_zone_upgrades_enabled == false ||
      (var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.cross_zone_upgrades_enabled == true &&
       var.orchestrated_virtual_machine_scale_set_zones != null &&
       length(var.orchestrated_virtual_machine_scale_set_zones) > 0)
    )
    error_message = "cross_zone_upgrades_enabled can only be set to true when zones is specified."
  }
}

# migrate_main.tf
locals {
  body = merge(
    {
      properties = merge(
        # ... existing properties ...
        var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy != null ? {
          upgradePolicy = {
            rollingUpgradePolicy = merge(
              {
                maxBatchInstancePercent = var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.max_batch_instance_percent
                maxUnhealthyInstancePercent = var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.max_unhealthy_instance_percent
                maxUnhealthyUpgradedInstancePercent = var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.max_unhealthy_upgraded_instance_percent
                pauseTimeBetweenBatches = var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.pause_time_between_batches
              },
              (var.orchestrated_virtual_machine_scale_set_zones != null && length(var.orchestrated_virtual_machine_scale_set_zones) > 0) ? { # <-
                enableCrossZoneUpgrade = coalesce(var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.cross_zone_upgrades_enabled, false) # <-
              } : {}, # <-
              # maxSurge = ... # Task #147
              # prioritizeUnhealthyInstances = ... # Task #148
            )
          }
        } : {},
      )
    }
  )
}
```

## Create Phase Verification

### Query Create Method
Queried `resourceOrchestratedVirtualMachineScaleSetCreate` to identify field assignment pattern.

### Pattern Classification
**Single-Phase Creation** - The field is set directly in the Create method before the CreateOrUpdateThenPoll call.

### Field Location
**Create Phase** - Field assigned before API call.

### Go Code Evidence
```go
zones := zones.ExpandUntyped(d.Get("zones").(*schema.Set).List())
if len(zones) > 0 {
    props.Zones = &zones
}

upgradeMode := virtualmachinescalesets.UpgradeMode(d.Get("upgrade_mode").(string))
rollingUpgradePolicy, err := ExpandVirtualMachineScaleSetRollingUpgradePolicy(d.Get("rolling_upgrade_policy").([]interface{}), len(zones) > 0, false)
if err != nil {
    return fmt.Errorf("expanding `rolling_upgrade_policy`: %w", err)
}

props.Properties.UpgradePolicy = &virtualmachinescalesets.UpgradePolicy{
    Mode:                 pointer.To(upgradeMode),
    RollingUpgradePolicy: rollingUpgradePolicy,
}
```

The code shows:
1. Zones are evaluated first
2. `ExpandVirtualMachineScaleSetRollingUpgradePolicy` is called with `len(zones) > 0` as the `isZonal` parameter
3. The expand function conditionally sets `EnableCrossZoneUpgrade` based on `isZonal`
4. Assigned before CreateOrUpdateThenPoll
5. This is Create phase - goes into `local.body`

### Expand Function Logic
```go
func ExpandVirtualMachineScaleSetRollingUpgradePolicy(input []interface{}, isZonal, overProvision bool) (*virtualmachinescalesets.RollingUpgradePolicy, error) {
    if len(input) == 0 {
        return nil, nil
    }

    raw := input[0].(map[string]interface{})

    rollingUpgradePolicy := &virtualmachinescalesets.RollingUpgradePolicy{
        MaxBatchInstancePercent:             pointer.To(int64(raw["max_batch_instance_percent"].(int))),
        MaxUnhealthyInstancePercent:         pointer.To(int64(raw["max_unhealthy_instance_percent"].(int))),
        MaxUnhealthyUpgradedInstancePercent: pointer.To(int64(raw["max_unhealthy_upgraded_instance_percent"].(int))),
        PauseTimeBetweenBatches:             pointer.To(raw["pause_time_between_batches"].(string)),
        PrioritizeUnhealthyInstances:        pointer.To(raw["prioritize_unhealthy_instances_enabled"].(bool)),
        MaxSurge:                            pointer.To(raw["maximum_surge_instances_enabled"].(bool)),
    }

    enableCrossZoneUpgrade := raw["cross_zone_upgrades_enabled"].(bool)
    if isZonal {
        // EnableCrossZoneUpgrade can only be set when for zonal scale set
        rollingUpgradePolicy.EnableCrossZoneUpgrade = pointer.To(enableCrossZoneUpgrade)
    } else if enableCrossZoneUpgrade {
        return nil, fmt.Errorf("`rolling_upgrade_policy.0.cross_zone_upgrades_enabled` can only be set to `true` when `zones` is specified")
    }

    // ... rest of function ...
    
    return rollingUpgradePolicy, nil
}
```

**Key Behavior:**
1. Field is read using type assertion `raw["cross_zone_upgrades_enabled"].(bool)` - if not set in Terraform, this will be false
2. **If isZonal is true:** Field is ALWAYS set to API (using user's value or false if not set)
3. **If isZonal is false and value is true:** Returns error
4. **If isZonal is false and value is false:** Field is NOT set to API

### Decision
Implement in `local.body` under `properties.upgradePolicy.rollingUpgradePolicy.enableCrossZoneUpgrade` with conditional logic based on zones.

## Assignment Path Verification

### Predicted Path
`properties.upgradePolicy.rollingUpgradePolicy.enableCrossZoneUpgrade`

### Go Code Trace
```go
// Step 1: Main resource structure
props := virtualmachinescalesets.VirtualMachineScaleSet{
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        // ...
    },
}

// Step 2: Expand function returns RollingUpgradePolicy struct
rollingUpgradePolicy, err := ExpandVirtualMachineScaleSetRollingUpgradePolicy(...)

// Step 3: Inside expand function - conditionally sets field
if isZonal {
    rollingUpgradePolicy.EnableCrossZoneUpgrade = pointer.To(enableCrossZoneUpgrade)
}

// Step 4: Assignment to Properties.UpgradePolicy
props.Properties.UpgradePolicy = &virtualmachinescalesets.UpgradePolicy{
    Mode:                 pointer.To(upgradeMode),
    RollingUpgradePolicy: rollingUpgradePolicy,  // <- Assigned here
}
```

### Assignment Trace
1. `props` = VirtualMachineScaleSet struct (root level)
2. `.Properties` = VirtualMachineScaleSetProperties (adds "properties" nesting)
3. `.UpgradePolicy` = UpgradePolicy struct (adds "upgradePolicy" nesting)
4. `.RollingUpgradePolicy` = RollingUpgradePolicy struct (adds "rollingUpgradePolicy" nesting)
5. `.EnableCrossZoneUpgrade` = bool field (adds "enableCrossZoneUpgrade" field)

### Verified Path
`properties.upgradePolicy.rollingUpgradePolicy.enableCrossZoneUpgrade` ✅

### Path Comparison
- **Predicted:** `properties.upgradePolicy.rollingUpgradePolicy.enableCrossZoneUpgrade`
- **Verified:** `properties.upgradePolicy.rollingUpgradePolicy.enableCrossZoneUpgrade`
- **Result:** ✅ **MATCH**

## Provider Schema

### Schema Definition
```go
"cross_zone_upgrades_enabled": {
    Type:     pluginsdk.TypeBool,
    Optional: true,
},
```

**Key Points:**
- Type: Bool
- Optional: true
- No Default specified (will be nil/null if not set)
- No ForceNew at field level (but parent block is ForceNew)
- No validations at field level (validation is in expand function)

## Azure API Schema

### API Field Documentation
From Azure API query:
```json
{
  "enableCrossZoneUpgrade": "Allow VMSS to ignore AZ boundaries when constructing upgrade batches. Take into consideration the Update Domain and maxBatchInstancePercent to determine the batch size."
}
```

**Key Points:**
- Field name: `enableCrossZoneUpgrade` (camelCase)
- Type: Boolean
- Purpose: Allow VMSS to ignore availability zone boundaries during upgrades
- Affects how upgrade batches are constructed across zones

## Hidden Fields Check

**NO hidden fields** - This task only implements the `cross_zone_upgrades_enabled` field which is explicitly defined in the schema.

The parent block skeleton (Task #141) already exists and contains all structural elements.

## Mapping

| Terraform Field | Azure API Field | Notes |
|-----------------|-----------------|-------|
| cross_zone_upgrades_enabled | enableCrossZoneUpgrade | Conditional - only set for zonal scale sets |

**Naming Convention:**
- snake_case → camelCase
- `_enabled` suffix removed (cross_zone_upgrades_enabled → enableCrossZoneUpgrade)
- Consistent with Azure API naming

## Special Handling

### 1. Conditional Field Logic

**Provider Behavior:**
The provider has conditional logic for setting this field:

```go
enableCrossZoneUpgrade := raw["cross_zone_upgrades_enabled"].(bool)
if isZonal {
    rollingUpgradePolicy.EnableCrossZoneUpgrade = pointer.To(enableCrossZoneUpgrade)
} else if enableCrossZoneUpgrade {
    return nil, fmt.Errorf("`rolling_upgrade_policy.0.cross_zone_upgrades_enabled` can only be set to `true` when `zones` is specified")
}
```

**Key Rules:**
1. If scale set is zonal (`zones` specified): Field is ALWAYS set to API
2. If scale set is not zonal and field is true: Error is returned
3. If scale set is not zonal and field is false/null: Field is NOT set to API

**Implementation:**
```hcl
(var.orchestrated_virtual_machine_scale_set_zones != null && length(var.orchestrated_virtual_machine_scale_set_zones) > 0) ? {
  enableCrossZoneUpgrade = coalesce(var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.cross_zone_upgrades_enabled, false)
} : {}
```

**Why `coalesce(..., false)`?**
The provider's type assertion `raw["cross_zone_upgrades_enabled"].(bool)` returns false if the field is not set (Go's zero value for bool). Using `coalesce` replicates this behavior - if user doesn't set the field (null), it becomes false.

### 2. Validation

**Added to variables.tf:**
```hcl
validation {
  condition = (
    var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy == null ||
    var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.cross_zone_upgrades_enabled == null ||
    var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.cross_zone_upgrades_enabled == false ||
    (var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.cross_zone_upgrades_enabled == true &&
     var.orchestrated_virtual_machine_scale_set_zones != null &&
     length(var.orchestrated_virtual_machine_scale_set_zones) > 0)
  )
  error_message = "cross_zone_upgrades_enabled can only be set to true when zones is specified."
}
```

**Validation Logic:**
- Valid: rolling_upgrade_policy is null (not set)
- Valid: cross_zone_upgrades_enabled is null (not set)
- Valid: cross_zone_upgrades_enabled is false
- Valid: cross_zone_upgrades_enabled is true AND zones is specified (non-null and non-empty)
- Invalid: cross_zone_upgrades_enabled is true AND zones is not specified

This exactly replicates the provider's validation in the expand function.

### 3. ForceNew Handling

The parent block (`rolling_upgrade_policy`) is ForceNew, so any change to this field triggers resource replacement. This was already handled in Task #141 by tracking the entire block in `replace_triggers_external_values`.

**No additional ForceNew tracking needed for this field.**

### 4. No Sensitive Fields

This field is not marked as Sensitive in the schema.

### 5. No Post-Creation Updates

The parent block is ForceNew, so no post-creation updates are possible.

## Deferred Work Completion

Checked `following.md` - no work was deferred to Task #146.

## Critical Review & Edge Cases

### Edge Case Analysis

#### 1. Null Semantics
**Question:** What does `cross_zone_upgrades_enabled = null` mean?
**Answer:** Field not set by user. In zonal scale sets, this is treated as false (via coalesce). In non-zonal scale sets, the field is not sent to API at all.

#### 2. Zonal vs Non-Zonal Scale Sets

**Scenario 1: Zonal scale set (zones = ["1", "2"])**
- User sets cross_zone_upgrades_enabled = true → API receives enableCrossZoneUpgrade = true
- User sets cross_zone_upgrades_enabled = false → API receives enableCrossZoneUpgrade = false
- User doesn't set field (null) → API receives enableCrossZoneUpgrade = false (via coalesce)

**Scenario 2: Non-zonal scale set (zones = null or [])**
- User sets cross_zone_upgrades_enabled = true → Validation error ✅
- User sets cross_zone_upgrades_enabled = false → Field not sent to API ✅
- User doesn't set field (null) → Field not sent to API ✅

**Impact:** The conditional merge ensures field is only sent when zones are specified.

#### 3. Zones Transition Scenarios

**Scenario: Non-zonal → Zonal (adding zones)**
- Entire rolling_upgrade_policy block is ForceNew (from Task #141)
- Resource will be replaced
- New resource can have enableCrossZoneUpgrade set

**Scenario: Zonal → Non-zonal (removing zones)**
- Entire rolling_upgrade_policy block is ForceNew
- Resource will be replaced
- New resource will not have enableCrossZoneUpgrade field sent to API

**Impact:** ForceNew on parent block handles all transition scenarios safely.

#### 4. Provider Type Assertion Behavior

The provider uses type assertion:
```go
enableCrossZoneUpgrade := raw["cross_zone_upgrades_enabled"].(bool)
```

In Go, if the field is not present in the map, this assertion returns the zero value for bool, which is `false`. In Terraform, an optional field not set by the user is `null`, not `false`. The `coalesce` function handles this difference by converting null to false, matching the provider's behavior.

#### 5. Default Behavior

**Provider:** No explicit default, but type assertion makes it effectively false
**Azure API:** Based on documentation, the default behavior (when field not sent) is likely false (don't ignore zone boundaries)
**Our Implementation:** Uses coalesce to default to false for zonal scale sets, matching provider

#### 6. Idempotency

**Question:** Is the implementation idempotent?
**Considerations:**
- Field presence is deterministic (based on zones variable)
- Value is deterministic (based on user input or false via coalesce)
- No ordering issues (single bool field)
- ForceNew prevents drift scenarios

**Result:** Implementation is idempotent.

#### 7. Safe References

All references are null-safe:
- Outer condition checks `rolling_upgrade_policy != null` before accessing block
- Zones condition checks `!= null && length(...) > 0`
- Field access uses coalesce to handle null

## Checklist

- ✅ Property in correct local (`properties.upgradePolicy.rollingUpgradePolicy.enableCrossZoneUpgrade`)
- ✅ ForceNew handled (inherited from parent block in Task #141)
- ✅ Validation implemented in variables.tf (cross-variable validation with zones)
- ✅ Conditional logic exactly replicates provider behavior
- ✅ Hidden fields checked (none for this task)
- ✅ Deferred work checked (`following.md` - none to this task)
- ✅ Critical review completed (edge cases analyzed)
- ✅ Edge Case Analysis section added
- ✅ Proof document created
- ✅ Comment placeholder replaced with implementation
- ✅ Self-review: Only added cross_zone_upgrades_enabled field, no other changes

## Compliance with executor.md

This implementation EXACTLY replicates the provider behavior:

1. ✅ **Conditional Logic:** Field only set when zones specified, matching `if isZonal` check
2. ✅ **Null Handling:** Uses coalesce to convert null to false, matching Go's type assertion behavior
3. ✅ **Validation:** Replicates expand function's error for true value without zones
4. ✅ **Path:** Correctly placed in properties.upgradePolicy.rollingUpgradePolicy.enableCrossZoneUpgrade
5. ✅ **Naming:** Correctly converted snake_case to camelCase

**No compromises, no "simpler approaches", no deviations - EXACT replication achieved.**

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent  
**Date:** 2025-12-11  
**Task:** #146 - rolling_upgrade_policy.cross_zone_upgrades_enabled

### Validation Results

✅ **ForceNew Logic:** Inherited from parent block (Task #141 - rolling_upgrade_policy is ForceNew)  
✅ **Stable Keys:** N/A - field is in local.body, not replace_triggers_external_values. Conditional presence in body correctly matches provider behavior.  
✅ **Phase Detection:** Field correctly placed in local.body (Create phase)  
✅ **Type Conversion:** Bool to Bool (no conversion needed)  
✅ **Null Handling:** Correctly uses coalesce(field, false) for zonal scale sets to match Go's type assertion behavior; omits field from body for non-zonal scale sets  
✅ **Validations:** Cross-variable validation implemented in variables.tf checking zones dependency  
✅ **Deferred Work Completion:** No deferred work for this task in following.md  
✅ **Deferred Work Recording:** No deferrals made by this task  
✅ **Edge Cases:** Comprehensive analysis of zonal vs non-zonal scenarios, null handling, and provider type assertion behavior

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`:

1. **Conditional Logic**: Field only set when `zones` specified, matching provider's `if isZonal` check
2. **Null Handling**: Uses `coalesce(field, false)` to replicate Go's type assertion behavior where unset bool returns false
3. **Validation**: Exactly replicates expand function's error condition for true value without zones
4. **Path**: Correctly placed at properties.upgradePolicy.rollingUpgradePolicy.enableCrossZoneUpgrade
5. **Naming**: Correctly converted snake_case to camelCase per Azure API conventions

No deviations, simplifications, or "safer alternatives" were found.

**Status:** APPROVED ✅

---
