# Task #26 - additional_capabilities.ultra_ssd_enabled

## Summary

Implemented the `ultra_ssd_enabled` argument within the `additional_capabilities` block at `properties.additionalCapabilities.ultraSSDEnabled` in the Azure API. This boolean field enables support for UltraSSD_LRS storage account type data disks. The field has a default value of `false` and is ForceNew.

## Shadow Implementation

```hcl
# In variables.tf:
variable "orchestrated_virtual_machine_scale_set_additional_capabilities" {
  type = object({
    ultra_ssd_enabled = optional(bool, false) # <-
  })
  default     = null
  description = <<-EOT
 - `ultra_ssd_enabled` - (Optional) Should the capacity to enable Data Disks of the `UltraSSD_LRS` storage account type be supported on this Virtual Machine Scale Set? Defaults to `false`. Changing this forces a new resource to be created.
EOT
}

# In migrate_main.tf, within local.body.properties merge:
var.orchestrated_virtual_machine_scale_set_additional_capabilities != null ? {
  additionalCapabilities = {
    ultraSSDEnabled = coalesce(var.orchestrated_virtual_machine_scale_set_additional_capabilities.ultra_ssd_enabled, false) # <-
  }
} : {},

# In migrate_main.tf, within local.replace_triggers_external_values:
replace_triggers_external_values = {
  # ... other fields ...
  ultra_ssd_enabled = { value = var.orchestrated_virtual_machine_scale_set_additional_capabilities != null ? coalesce(var.orchestrated_virtual_machine_scale_set_additional_capabilities.ultra_ssd_enabled, false) : false } # <-
}
```

## Create Phase Verification

**Query Method:** `query_terraform_block_implementation_source_code` with `entrypoint_name=create`

**Pattern Identified:** Single-phase (Create phase only)

**Evidence from Provider Source Code:**

```go
// In resourceOrchestratedVirtualMachineScaleSetCreate:
additionalCapabilitiesRaw := d.Get("additional_capabilities").([]interface{})
additionalCapabilities := ExpandOrchestratedVirtualMachineScaleSetAdditionalCapabilities(additionalCapabilitiesRaw)
props.Properties.AdditionalCapabilities = additionalCapabilities

// Later in the function:
log.Printf("[DEBUG] Creating Orchestrated %s.", id)
if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Classification:** Create phase - assigned before `client.CreateOrUpdateThenPoll()` call

**Decision:** Field goes in `local.body` (not `local.post_creation_updates`)

## Assignment Path Verification

**Predicted Path:** `body.properties.additionalCapabilities.ultraSSDEnabled`

**Go Code Evidence:**

```go
// From Create method:
props := virtualmachinescalesets.VirtualMachineScaleSet{
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        // ...
    },
}

// Assignment:
additionalCapabilitiesRaw := d.Get("additional_capabilities").([]interface{})
additionalCapabilities := ExpandOrchestratedVirtualMachineScaleSetAdditionalCapabilities(additionalCapabilitiesRaw)
props.Properties.AdditionalCapabilities = additionalCapabilities

// Expand function:
func ExpandOrchestratedVirtualMachineScaleSetAdditionalCapabilities(input []interface{}) *virtualmachinescalesets.AdditionalCapabilities {
    capabilities := virtualmachinescalesets.AdditionalCapabilities{}

    if len(input) > 0 {
        raw := input[0].(map[string]interface{})

        capabilities.UltraSSDEnabled = pointer.To(raw["ultra_ssd_enabled"].(bool))
    }

    return &capabilities
}
```

**Trace:**
1. `props` is the root `VirtualMachineScaleSet` object (maps to `body`)
2. `props.Properties` maps to `body.properties`
3. `props.Properties.AdditionalCapabilities` maps to `body.properties.additionalCapabilities`
4. Within the expand function, `capabilities.UltraSSDEnabled` maps to `body.properties.additionalCapabilities.ultraSSDEnabled`

**Verified Path:** `body.properties.additionalCapabilities.ultraSSDEnabled`

**Comparison:** ✅ Predicted path matches verified path

## Provider Schema

**Source:** `OrchestratedVirtualMachineScaleSetAdditionalCapabilitiesSchema` function

```go
func OrchestratedVirtualMachineScaleSetAdditionalCapabilitiesSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        MaxItems: 1,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "ultra_ssd_enabled": {
                    Type:     pluginsdk.TypeBool,
                    Optional: true,
                    Default:  false,
                    ForceNew: true,
                },
            },
        },
    }
}
```

**Key Properties:**
- **Type:** Bool
- **Optional:** Yes
- **Default:** `false`
- **ForceNew:** `true` - Changing this field requires resource replacement
- **Validations:** None
- **ConflictsWith:** None
- **RequiredWith:** None

## Azure API Schema

**Resource Type:** `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

**Path:** `body.properties.additionalCapabilities.ultraSSDEnabled`

**Type:** Boolean (optional)

**Description:** "The flag that enables or disables a capability to have one or more managed data disks with UltraSSD_LRS storage account type on the VM or VMSS. Managed disks with storage account type UltraSSD_LRS can be added to a virtual machine or virtual machine scale set only if this property is enabled."

## Mapping

| Terraform (snake_case) | Azure API (camelCase) |
|------------------------|----------------------|
| ultra_ssd_enabled | ultraSSDEnabled |

## Special Handling

### Default Value

The provider schema specifies `Default: false`. This is implemented in two places:

1. **Variable Definition:** Using `optional(bool, false)` in the object type definition
2. **Usage:** Using `coalesce()` to ensure `false` is used when the field is not explicitly set

**Implementation:**
```hcl
ultra_ssd_enabled = optional(bool, false)
ultraSSDEnabled = coalesce(var.orchestrated_virtual_machine_scale_set_additional_capabilities.ultra_ssd_enabled, false)
```

This ensures that when users don't specify `ultra_ssd_enabled`, it defaults to `false`, exactly matching provider behavior.

### ForceNew Handling

The schema specifies `ForceNew: true`, meaning changes to this field require resource replacement.

**Implementation in `replace_triggers_external_values`:**
```hcl
ultra_ssd_enabled = { value = var.orchestrated_virtual_machine_scale_set_additional_capabilities != null ? coalesce(var.orchestrated_virtual_machine_scale_set_additional_capabilities.ultra_ssd_enabled, false) : false }
```

**Key Points:**
- Wrapped in `{ value = ... }` to ensure stable key (Mode 1 - Direct Value Tracking)
- Always evaluates to a boolean value (`false` when parent block is null)
- Any change in value (including null → false, false → true, true → false) triggers replacement
- When parent block is null, the entire `additionalCapabilities` block is omitted from body, and the trigger value is `false`

### Expand Function Behavior

The provider's expand function has specific behavior:

```go
func ExpandOrchestratedVirtualMachineScaleSetAdditionalCapabilities(input []interface{}) *virtualmachinescalesets.AdditionalCapabilities {
    capabilities := virtualmachinescalesets.AdditionalCapabilities{}

    if len(input) > 0 {
        raw := input[0].(map[string]interface{})
        capabilities.UltraSSDEnabled = pointer.To(raw["ultra_ssd_enabled"].(bool))
    }

    return &capabilities
}
```

**Key Observations:**
- Always returns a non-nil pointer to `AdditionalCapabilities`
- When input length is 0, returns an empty struct (with `UltraSSDEnabled` as nil pointer)
- When input has elements, sets `UltraSSDEnabled` to a pointer of the bool value

**Our Implementation:**
- Only creates `additionalCapabilities` block when parent variable is not null
- Always sets `ultraSSDEnabled` to an explicit boolean value (never null)
- Uses `coalesce()` to apply the default of `false` when field is not set

This matches the effective behavior of the provider since the schema has `Default: false`.

## Critical Review & Edge Cases

### Edge Case Analysis

**1. Null Semantics:**
- **When parent block is `null`:**
  - The entire `additionalCapabilities` block is omitted from API request
  - ForceNew trigger value is `false`
  - ✅ Correct: Matches provider behavior when block is not specified
  
- **When parent block is `{}` (empty object):**
  - Block is created with `ultraSSDEnabled = false` (from default)
  - ForceNew trigger value is `false`
  - ✅ Correct: Matches provider default behavior

- **When field is explicitly set to `false`:**
  - Block is created with `ultraSSDEnabled = false`
  - ForceNew trigger value is `false`
  - ✅ Correct: Explicit value honored

- **When field is explicitly set to `true`:**
  - Block is created with `ultraSSDEnabled = true`
  - ForceNew trigger value is `true`
  - ✅ Correct: Explicit value honored

**2. Default Application:**
The provider schema has `Default: false`, which means:
- When users specify `additional_capabilities = {}`, the field defaults to `false`
- When users omit the field, it defaults to `false`

Our implementation uses both:
- `optional(bool, false)` in variable type
- `coalesce(..., false)` in usage

This ensures the default is consistently applied in all scenarios.

**3. ForceNew Behavior:**
- **Change from unset to `true`:** Triggers replacement ✅
- **Change from `false` to `true`:** Triggers replacement ✅
- **Change from `true` to `false`:** Triggers replacement ✅
- **Change from unset to `false`:** No replacement (both evaluate to `false`) ✅

**4. Idempotency:**
- Same input always produces same output ✅
- No order dependencies ✅
- Deterministic evaluation of default values ✅

**5. Safe References:**
- Parent block checked with `!= null` before accessing field ✅
- `coalesce()` handles null field values safely ✅
- ForceNew trigger safely handles null parent block ✅

**6. Integration with data_disk:**
The Create method shows this field is used when processing data disks:

```go
if v, ok := d.GetOk("data_disk"); ok {
    ultraSSDEnabled := d.Get("additional_capabilities.0.ultra_ssd_enabled").(bool)
    dataDisks, err := ExpandOrchestratedVirtualMachineScaleSetDataDisk(v.([]interface{}), ultraSSDEnabled)
    if err != nil {
        return fmt.Errorf("expanding `data_disk`: %w", err)
    }
    virtualMachineProfile.StorageProfile.DataDisks = dataDisks
}
```

This shows the field is read for data disk processing, but it's still set in `additionalCapabilities` block independently. Our implementation correctly separates these concerns - we set the field in the API body, and data disk tasks will read it as needed.

## Checklist

- ✅ Field implemented in `migrate_main.tf` at correct path
- ✅ Default value `false` applied using `optional(bool, false)` in variable type
- ✅ Default value applied using `coalesce()` in usage
- ✅ ForceNew handling added to `replace_triggers_external_values` with stable key wrapping
- ✅ Create phase verified (single-phase, Create only)
- ✅ Assignment path traced and verified
- ✅ Provider schema documented with ForceNew property
- ✅ Azure API schema queried (description documented)
- ✅ Expand function analyzed for behavior
- ✅ Mapping table created (snake_case → camelCase)
- ✅ No validations to implement (none in schema)
- ✅ Edge cases analyzed (null semantics, default application, ForceNew behavior, idempotency, safe references)
- ✅ Integration with data_disk documented
- ✅ Implementation exactly matches provider behavior
- ✅ Proof document contains no forbidden phrases
- ✅ Self-review completed: Only ultra_ssd_enabled implemented, no content from other tasks

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-08
**Task:** #26 - additional_capabilities.ultra_ssd_enabled

### Validation Results

✅ **ForceNew Logic:** Simple ForceNew (schema `ForceNew: true`) correctly implemented with Mode 1 - Direct Value Tracking
✅ **Stable Keys:** Key `ultra_ssd_enabled` in `replace_triggers_external_values` is stable with `{ value = ... }` wrapping
✅ **Phase Detection:** Field correctly placed in `local.body` (Create phase, single-phase pattern)
✅ **Type Conversion:** Bool to Bool - no conversion needed
✅ **Null Handling:** Correctly propagates null semantics with proper conditional and coalesce
✅ **Default Value:** Double-default approach (`optional(bool, false)` + `coalesce(..., false)`) exactly matches provider
✅ **Validations:** None required (schema has no validations)
✅ **Shared Path Merge:** No violations - `additionalCapabilities` appears only once in properties merge
✅ **Edge Cases:** All edge cases properly analyzed (null semantics, default application, ForceNew behavior, idempotency, safe references)
✅ **Assignment Path:** Correctly verified as `body.properties.additionalCapabilities.ultraSSDEnabled`
✅ **Provider Expand Function:** Behavior analyzed and correctly replicated

### Detailed Compliance Analysis

#### 1. ForceNew Implementation (executor.md compliance)
**Provider Schema:**
```go
"ultra_ssd_enabled": {
    Type:     pluginsdk.TypeBool,
    Optional: true,
    Default:  false,
    ForceNew: true,
}
```

**Implementation:**
```hcl
# In replace_triggers_external_values:
ultra_ssd_enabled = { value = var.orchestrated_virtual_machine_scale_set_additional_capabilities != null ? coalesce(var.orchestrated_virtual_machine_scale_set_additional_capabilities.ultra_ssd_enabled, false) : false }
```

**Why This is EXACT:**
- ✅ Schema has `ForceNew: true` (simple, unconditional ForceNew)
- ✅ No CustomizeDiff logic (checked resource function)
- ✅ Uses Mode 1 - Direct Value Tracking with `{ value = ... }` wrapper
- ✅ Key always present (stable)
- ✅ Always evaluates to boolean value (never null)
- ✅ Parent null check ensures safe evaluation
- ✅ `coalesce(..., false)` applies default when field not set

**Verification:**
- Scenario 1: Parent null → trigger value = `false` ✅
- Scenario 2: Parent `{}` → trigger value = `false` (from default) ✅
- Scenario 3: Field = `false` → trigger value = `false` ✅
- Scenario 4: Field = `true` → trigger value = `true` ✅
- Scenario 5: Change `false` → `true` → triggers replacement ✅
- Scenario 6: Change `true` → `false` → triggers replacement ✅

#### 2. Default Value Replication
**Provider Behavior:**
- Schema specifies `Default: false`
- When field not set, provider uses `false`

**Implementation:**
- Variable: `ultra_ssd_enabled = optional(bool, false)`
- Usage: `coalesce(var.orchestrated_virtual_machine_scale_set_additional_capabilities.ultra_ssd_enabled, false)`

**Why This is EXACT:**
- ✅ Double-default ensures `false` applied in all scenarios
- ✅ Matches provider's expand function behavior
- ✅ No deviation from provider defaults

#### 3. Body Path Implementation
**Provider Code:**
```go
capabilities.UltraSSDEnabled = pointer.To(raw["ultra_ssd_enabled"].(bool))
props.Properties.AdditionalCapabilities = additionalCapabilities
```

**Implementation:**
```hcl
additionalCapabilities = {
  ultraSSDEnabled = coalesce(var.orchestrated_virtual_machine_scale_set_additional_capabilities.ultra_ssd_enabled, false)
}
```

**Why This is EXACT:**
- ✅ Correct camelCase: `ultraSSDEnabled`
- ✅ Correct nesting: `properties.additionalCapabilities.ultraSSDEnabled`
- ✅ Conditional block creation matches provider pattern
- ✅ Default application matches pointer behavior

#### 4. Edge Case Handling
All edge cases documented in proof and correctly handled:
- ✅ Null parent block: entire block omitted, trigger = `false`
- ✅ Empty parent block: block created with default value `false`
- ✅ Explicit `false`: value honored
- ✅ Explicit `true`: value honored
- ✅ Idempotency: deterministic evaluation
- ✅ Safe references: parent null check prevents errors

#### 5. No Validations (Correct)
- ✅ Provider schema has no validations
- ✅ No ConflictsWith, RequiredWith, etc.
- ✅ None implemented (correct per executor.md)

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. No deviations, simplifications, or "safer alternatives" were found.

**Specific Compliance Points:**
1. ✅ ForceNew logic exactly matches schema (simple ForceNew with Mode 1 tracking)
2. ✅ Default value exactly matches provider (`false`)
3. ✅ Stable keys requirement satisfied (key always present, wrapped in object)
4. ✅ Assignment path exactly matches provider (traced through Go code)
5. ✅ Phase detection correct (Create phase, single-phase pattern)
6. ✅ No shared path merge violations
7. ✅ All edge cases properly analyzed and handled
8. ✅ Proof document complete with all required sections
9. ✅ No forbidden phrases (no "more conservative", "simpler", "safer")
10. ✅ Self-review completed (only ultra_ssd_enabled implemented)

**Status:** APPROVED ✅

---
