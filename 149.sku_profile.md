# Task #149: sku_profile Block Structure Skeleton

## Summary
Created structure skeleton for root-level block `sku_profile` from azurerm_orchestrated_virtual_machine_scale_set to azapi_resource. This block is conditionally included based on the `sku_profile` variable and maps to `properties.skuProfile` in Azure API. Implementation includes placeholders for child arguments.

## Shadow Implementation

```hcl
locals {
  body = merge(
    # ... other blocks ...
    var.orchestrated_virtual_machine_scale_set_sku_profile != null ? {  # <-
      properties = {  # <-
        skuProfile = {  # <-
          # allocationStrategy = ... # Task #150  # <-
          # vmSizes = ... # Task #151  # <-
        }  # <-
      }  # <-
    } : {}  # <-
  )
}
```

## Create Phase Verification

### Query Create Method
Queried `resourceOrchestratedVirtualMachineScaleSetCreate` to identify the phase where sku_profile is set.

### Go Code Evidence
```go
if v, ok := d.GetOk("sku_profile"); ok {
    props.Properties.SkuProfile = expandOrchestratedVirtualMachineScaleSetSkuProfile(v.([]interface{}))
}
```

This happens during the Create method BEFORE the `CreateOrUpdateThenPoll` call.

### Pattern Identification
Single-phase creation pattern - field is assigned before the create call.

### Decision
The `sku_profile` block is set in the **Create phase** → belongs in `local.body`.

## Assignment Path Verification

### Predicted Path
```
properties.skuProfile
```

### Go Code Evidence - Struct Assignment Trace

1. **Field assignment in Create method:**
```go
props.Properties.SkuProfile = expandOrchestratedVirtualMachineScaleSetSkuProfile(v.([]interface{}))
```

2. **Props structure definition:**
```go
props := virtualmachinescalesets.VirtualMachineScaleSet{
    Location: location.Normalize(d.Get("location").(string)),
    Tags:     tags.Expand(t),
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        // ...
    },
}
```

3. **Assignment trace:**
   - `props.Properties.SkuProfile = ...`
   - `props.Properties` is type `*VirtualMachineScaleSetProperties`
   - `SkuProfile` is a field in `VirtualMachineScaleSetProperties`
   - Final API path: `properties.skuProfile`

### Verified Path
```
properties.skuProfile
```

### Path Comparison
✅ **MATCH** - Predicted path matches verified path from Go code.

## Provider Schema

### Schema Definition
```go
"sku_profile": {
    Type:     pluginsdk.TypeList,
    Optional: true,
    ForceNew: true,
    MaxItems: 1,
    Elem: &pluginsdk.Resource{
        Schema: map[string]*pluginsdk.Schema{
            "allocation_strategy": {
                Type:     pluginsdk.TypeString,
                Required: true,
                ValidateFunc: validation.StringInSlice(
                    virtualmachinescalesets.PossibleValuesForAllocationStrategy(),
                    false,
                ),
            },

            "vm_sizes": {
                Type:     pluginsdk.TypeSet,
                Required: true,
                MinItems: 1,
                Elem: &pluginsdk.Schema{
                    Type:         pluginsdk.TypeString,
                    ValidateFunc: validation.StringIsNotEmpty,
                },
            },
        },
    },
},
```

**Key Properties:**
- **Type:** List (MaxItems: 1) - Represents a single nested block
- **Optional:** true
- **ForceNew:** true - Changing this forces a new resource
- **Child fields:** `allocation_strategy` (Required), `vm_sizes` (Required)

## Azure API Schema

From Azure API schema for `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`:

```
"skuProfile": ObjectWithOptionalAttrs(map[string]Type{
    "allocationStrategy": String,
    "vmSizes": List(ObjectWithOptionalAttrs(map[string]Type{
        "name": String,
        "rank": Number
    }, []string{"name", "rank"}))
}, []string{"allocationStrategy", "vmSizes"})
```

**Property Path in Azure API:**
```
properties.skuProfile
```

**Key Properties:**
- `allocationStrategy`: String (Optional in API schema)
- `vmSizes`: List of objects with `name` (String) and `rank` (Number)
- Parent: `properties` object

## Hidden Fields

### Expand Function Analysis

Queried `expandOrchestratedVirtualMachineScaleSetSkuProfile` to check for hidden fields:

```go
func expandOrchestratedVirtualMachineScaleSetSkuProfile(input []interface{}) *virtualmachinescalesets.SkuProfile {
    if len(input) == 0 || input[0] == nil {
        return nil
    }

    v := input[0].(map[string]interface{})
    vmSizesRaw := v["vm_sizes"].(*pluginsdk.Set).List()
    vmSizes := make([]virtualmachinescalesets.SkuProfileVMSize, 0)
    for _, vmSize := range vmSizesRaw {
        vmSizes = append(vmSizes, virtualmachinescalesets.SkuProfileVMSize{
            Name: pointer.To(vmSize.(string)),
        })
    }

    return &virtualmachinescalesets.SkuProfile{
        AllocationStrategy: pointer.To((virtualmachinescalesets.AllocationStrategy)(v["allocation_strategy"].(string))),
        VMSizes:            pointer.To(vmSizes),
    }
}
```

**Hidden Fields Found:** None

The expand function:
1. Reads `allocation_strategy` directly from Terraform config
2. Reads `vm_sizes` directly from Terraform config
3. Converts vm_sizes from list of strings to list of objects with `Name` field
4. **Does NOT hardcode** any hidden fields or additional properties
5. **Note:** Azure API schema shows `vmSizes` objects have both `name` and `rank` fields, but provider only sets `name` from user input

## Mapping

### Terraform → Azure API

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|------------------------|----------------------|-------|
| `sku_profile` | `skuProfile` | Block name |
| `allocation_strategy` | `allocationStrategy` | Child argument (Task #150) |
| `vm_sizes` | `vmSizes` | Child argument (Task #151) |

**Special Handling:**
- The `vm_sizes` field in Terraform is `set(string)` but Azure API expects list of objects with `name` field
- The expand function handles the conversion from string set to object list
- Azure API also has optional `rank` field in vmSizes objects, not exposed in Terraform schema

## Special Handling

### 1. ForceNew Behavior
**Provider Schema:** `ForceNew: true`

The entire `sku_profile` block is ForceNew. This means any change to the block or its child arguments requires replacement. However, since this is a Type 3 task (block skeleton only), ForceNew handling will be implemented by child tasks #150 and #151 for individual arguments.

### 2. Conditional Block
The block is optional and only included when `var.orchestrated_virtual_machine_scale_set_sku_profile != null`.

**Implementation:**
```hcl
var.orchestrated_virtual_machine_scale_set_sku_profile != null ? {
  properties = {
    skuProfile = {
      # child arguments here
    }
  }
} : {}
```

### 3. Cross-Field Validation (Already Implemented)
From Task #17 (sku_name), there are cross-field validations already implemented in `variables.tf`:

```hcl
validation {
  condition     = var.orchestrated_virtual_machine_scale_set_sku_name != "Mix" || var.orchestrated_virtual_machine_scale_set_sku_profile != null
  error_message = "`sku_profile` must be configured when `sku_name` is set to `Mix`."
}

validation {
  condition     = var.orchestrated_virtual_machine_scale_set_sku_profile == null || var.orchestrated_virtual_machine_scale_set_sku_name == "Mix"
  error_message = "`sku_profile` can only be configured when `sku_name` is set to `Mix`."
}
```

**Evidence from CustomizeDiff:**
```go
skuName, hasSkuName := diff.GetOk("sku_name")
_, hasSkuProfile := diff.GetOk("sku_profile")

if hasSkuProfile {
    if !hasSkuName || skuName != SkuNameMix {
        return fmt.Errorf("`sku_profile` can only be configured when `sku_name` is set to `Mix`")
    }
} else {
    if hasSkuName && skuName == SkuNameMix {
        return fmt.Errorf("`sku_profile` must be configured when `sku_name` is set to `Mix`")
    }
}
```

These validations were already implemented in Task #17, so no additional validation work is needed for this task.

### 4. Nesting in properties
Unlike `sku` which is a root-level field in the Azure API, `skuProfile` is nested under `properties`. The implementation correctly places it in `properties.skuProfile`.

## Deferred Work Completion

Checked `following.md` - file does not exist yet, so no deferred work to complete for this task.

## Critical Review & Edge Case

### Null Semantics
- **`sku_profile = null`:** Block is not included in the request body (entire conditional returns `{}`)
- **Block present but empty:** Not possible due to Required child arguments
- **Meaning:** null means "do not configure sku_profile" - this is the correct behavior

### Boundary Conditions
- **MaxItems: 1:** Terraform enforces single block, no array handling needed
- **Optional block:** Correctly handled with conditional merge
- **Required children:** Will be enforced by child task implementations

### Idempotency
- Block structure is idempotent - same input produces same output
- Child arguments will handle their own idempotency in Tasks #150 and #151

### Safe References
- Checks `var.orchestrated_virtual_machine_scale_set_sku_profile != null` before accessing
- Safe merge pattern prevents merge conflicts with other blocks

### Integration with sku_name
The `sku_profile` block has a tight coupling with `sku_name`:
- When `sku_name = "Mix"`, `sku_profile` is **required**
- When `sku_name != "Mix"`, `sku_profile` must **not** be set
- These validations are already implemented in Task #17

### Edge Case: Missing sku in Azure API Response
The Azure API schema shows `sku` as a root-level optional field. When `sku_name = "Mix"`, the `sku.name` is set to "Mix" but `sku.tier` is set to null. This is handled correctly in Task #17. The `sku_profile` block provides the actual VM size configuration when using Mix SKU.

## Child Tasks Ready for Delegation

The following child tasks are now ready to be implemented:

| Task # | Field | Type | Required | Status |
|--------|-------|------|----------|--------|
| **150** | **sku_profile.allocation_strategy** | **Argument** | **Yes** | **Ready** |
| **151** | **sku_profile.vm_sizes** | **Argument** | **Yes** | **Ready** |

**Both child tasks can now proceed** as the parent skeleton structure is complete.

## Checklist

- ✅ Property in correct local (`body`)
- ✅ Conditional block structure (`sku_profile != null`)
- ✅ Hidden fields checked (none found)
- ✅ Assignment path verified (`properties.skuProfile`)
- ✅ Deferred work checked (no following.md file exists)
- ✅ Critical review completed (null semantics, boundaries, idempotency, safe refs)
- ✅ Edge case analysis completed
- ✅ Proof document created
- ✅ Child tasks identified and listed as ready
- ✅ Cross-field validations already handled by Task #17
- ✅ ForceNew behavior documented (will be handled by child tasks)
- ✅ Self-Review: Only skeleton created, no individual arguments added

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #149 - sku_profile

### Issues Identified

#### Issue 1: CRITICAL - Shared Path Merge Violation (Data Loss Bug)

**Problem:**
The executor placed the `sku_profile` block as a separate `properties` object at the root level of the body merge, causing the `properties` key to appear **twice** at the same merge level. This violates executor.md's explicit requirement for nested merge on shared paths (executor.md lines 161-163) and checker.md's critical shared path merge check (checker.md lines 232-280).

**Executor's Implementation:**
```hcl
body = merge(
  {
    properties = merge(
      # ... all other properties including virtualMachineProfile ...
    )
  },
  # ... sku, zones, plan blocks ...
  var.orchestrated_virtual_machine_scale_set_sku_profile != null ? {
    properties = {  # ❌ DUPLICATE KEY - overwrites first properties!
      skuProfile = {
        # ...
      }
    }
  } : {}
)
```

**Why This Violates executor.md:**
From executor.md line 161-163:
> ⚠️ `merge()` is SHALLOW! Use nested `merge()` for shared paths

From checker.md lines 237-250:
> ❌ **VIOLATION - Multiple occurrences of same parent key:**
> ```hcl
> properties = merge(
>   condition1 ? { virtualMachineProfile = { field1 = ... } } : {},
>   condition2 ? { virtualMachineProfile = { field2 = ... } } : {}
>   # ^^^ virtualMachineProfile appears TWICE - second overwrites first!
> )
> ```

**Root Cause:**
Terraform's `merge()` function is **shallow** - when the same key appears multiple times at the same level, the **last occurrence overwrites all previous occurrences**. The executor's implementation would cause:
1. First `properties` block (lines 174-667) with all virtualMachineProfile settings gets created
2. Second `properties` block (lines 685-692) with only skuProfile overwrites it completely
3. **Result:** When sku_profile is set, ALL other properties (virtualMachineProfile, orchestrationMode, etc.) are LOST

**Impact:**
This is a **data loss bug** that would cause silent failures. When users set `sku_profile`, the entire VMSS would be created without virtualMachineProfile, networking, storage, or any other critical configuration.

### Corrections Made

#### Fix 1: Nested Merge for Shared Path

**Changed Files:**
- `migrate_main.tf`: Moved sku_profile block inside the first properties merge block

**New Implementation:**
```hcl
body = merge(
  {
    properties = merge(
      # ... other property fields ...
      var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy != null ? {
        upgradePolicy = { ... }
      } : {},
      var.orchestrated_virtual_machine_scale_set_sku_profile != null ? {
        skuProfile = {
          # allocationStrategy = ... # Task #150
          # vmSizes = ... # Task #151
        }
      } : {},  # ✅ NOW INSIDE properties merge, not a duplicate properties key
      var.orchestrated_virtual_machine_scale_set_sku_name != null ? {
        virtualMachineProfile = merge( ... )
      } : {}
    )
  },
  # ... sku, zones, plan blocks (NOT properties) ...
)
```

**Why This is EXACT:**
1. The `properties` key now appears **only once** at the root level of the body merge
2. All property fields (including `skuProfile`) are merged **inside** the single properties object
3. This matches the required pattern from checker.md line 247-256:
   ```hcl
   ✅ **CORRECT - Nested merge for shared paths:**
   properties = condition_for_parent ? {
     virtualMachineProfile = merge(
       condition1 ? { field1 = ... } : {},
       condition2 ? { field2 = ... } : {}
     )
   } : {}
   # virtualMachineProfile appears ONCE, children merged inside
   ```

**Verification:**
- **Scenario 1:** `sku_profile = null` → Empty object `{}` added to properties merge, no skuProfile field → ✅ Correct
- **Scenario 2:** `sku_profile != null` → `skuProfile` object added alongside other properties → ✅ Correct
- **Scenario 3:** Both `sku_profile` and `virtualMachineProfile` set → Both appear in properties → ✅ Correct (no overwrite)
- **Edge Case:** All properties set → Single properties object with all fields → ✅ Correct

**Placement Verification:**
The fix places `sku_profile` after `rolling_upgrade_policy` (line 232) and before `virtualMachineProfile` (line 239). This is correct because:
1. It's inside the first `properties` merge block
2. It's at the correct nesting level (`properties.skuProfile`)
3. It doesn't conflict with any other property names
4. The conditional structure matches the pattern used for other optional properties

### Compliance Statement

After corrections, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`:
- ✅ **Correct skeleton structure** with placeholders for child tasks
- ✅ **Correct assignment path** (`properties.skuProfile`)
- ✅ **Correct phase** (Create phase in `local.body`)
- ✅ **Correct conditional logic** (only included when variable is not null)
- ✅ **NO shared path merge violations** (properties key appears only once)
- ✅ **Stable merge structure** (no keys appearing/disappearing incorrectly)

**Status:** CORRECTED AND APPROVED ✅
