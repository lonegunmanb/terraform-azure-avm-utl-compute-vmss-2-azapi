# Task #124: os_profile.windows_configuration.additional_unattend_content.content

## Summary

Implemented the `content` field within `additional_unattend_content` nested block. This sensitive field contains XML formatted content added to the unattend.xml file for Windows setup. The implementation uses independent ephemeral variables following the nested block sensitive field pattern, with the hardcoded hidden fields (`componentName`, `passName`) added to the object structure alongside `content`.

## Shadow Implementation

```hcl
# migrate_variables.tf
variable "migrate_orchestrated_virtual_machine_scale_set_os_profile_windows_configuration_additional_unattend_content_content" {
  type = list(object({
    index   = number # <-
    content = string # <-
  }))
  nullable    = true # <-
  ephemeral   = true # <-
  description = "(Required for each item) The XML formatted content that is added to the unattend.xml file for the specified path and component. Changing this forces a new resource to be created." # <-
}

variable "migrate_orchestrated_virtual_machine_scale_set_os_profile_windows_configuration_additional_unattend_content_content_version" {
  type        = number # <-
  default     = null # <-
  description = "(Optional) Version tracker for additional_unattend_content content. Must be set when additional_unattend_content is provided." # <-

  validation { # <-
    condition     = var.migrate_orchestrated_virtual_machine_scale_set_os_profile_windows_configuration_additional_unattend_content_content == null || var.migrate_orchestrated_virtual_machine_scale_set_os_profile_windows_configuration_additional_unattend_content_content_version != null # <-
    error_message = "When additional_unattend_content content is set, additional_unattend_content_content_version must also be set." # <-
  } # <-
}

# variables.tf - marked for future cleanup
variable "orchestrated_virtual_machine_scale_set_os_profile" {
  # ...
  windows_configuration = optional(object({
    # ...
    additional_unattend_content = optional(list(object({
      content = string # TODO: delete later - migrated to independent ephemeral variable (Task #124) # <-
      setting = string
    })))
  }))
}

# migrate_main.tf
locals {
  # Task #124: Map content by index for additional_unattend_content # <-
  additional_unattend_content_map = var.migrate_orchestrated_virtual_machine_scale_set_os_profile_windows_configuration_additional_unattend_content_content != null ? { # <-
    for item in var.migrate_orchestrated_virtual_machine_scale_set_os_profile_windows_configuration_additional_unattend_content_content : item.index => item.content # <-
  } : {} # <-

  body = {
    properties = {
      virtualMachineProfile = {
        osProfile = {
          windowsConfiguration = {
            additionalUnattendContent = [ # <-
              for idx, content in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.additional_unattend_content : { # <-
                componentName = "Microsoft-Windows-Shell-Setup" # <- Hidden field (hardcoded)
                passName      = "OobeSystem" # <- Hidden field (hardcoded)
                # content = ... # Task #124 - in sensitive_body # <-
                # setting = ... # Task #125 # <-
              } # <-
            ] # <-
          }
        }
      }
    }
  }

  sensitive_body = {
    properties = {
      virtualMachineProfile = {
        osProfile = {
          windowsConfiguration = { # <-
            additionalUnattendContent = [ # <-
              for idx, content in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.additional_unattend_content : { # <-
                content = local.additional_unattend_content_map[idx] # <- Sensitive field value
              } # <-
            ] # <-
          } # <-
        }
      }
    }
  }

  sensitive_body_version = {
    "properties.virtualMachineProfile.osProfile.windowsConfiguration.additionalUnattendContent" = try(tostring(var.migrate_orchestrated_virtual_machine_scale_set_os_profile_windows_configuration_additional_unattend_content_content_version), "null") # <-
  }
}
```

## Create Phase Verification

### Query Results

Queried the Create method using `query_terraform_block_implementation_source_code` with `entrypoint_name=create`.

**Pattern:** Single-phase creation

From the Create method:

```go
osProfileRaw := d.Get("os_profile").([]interface{})

if len(osProfileRaw) > 0 && osProfileRaw[0] != nil {
    osProfile := osProfileRaw[0].(map[string]interface{})
    winConfigRaw = osProfile["windows_configuration"].([]interface{})
    customData := ""

    if v := osProfile["custom_data"]; v != nil {
        customData = v.(string)
    }

    if len(winConfigRaw) > 0 && winConfigRaw[0] != nil {
        osType = virtualmachinescalesets.OperatingSystemTypesWindows
        winConfig := winConfigRaw[0].(map[string]interface{})
        vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(winConfig, customData)
        // ...
    }

    if vmssOsProfile != nil {
        osProfile.AllowExtensionOperations = pointer.To(extensionOperationsEnabled)
    }

    virtualMachineProfile.OsProfile = vmssOsProfile
}

props := virtualmachinescalesets.VirtualMachineScaleSet{
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        VirtualMachineProfile: &virtualMachineProfile,
        // ...
    },
}

if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Classification:** Create phase - the field is processed during the expand function call before the CreateOrUpdateThenPoll call.

**Decision:** Place in `local.body` and `local.sensitive_body` (not in `post_creation_updates`). The `content` sensitive value goes to `sensitive_body`, while hardcoded fields and placeholder go in `body`.

## Assignment Path Verification

### Predicted Path

```
properties.virtualMachineProfile.osProfile.windowsConfiguration.additionalUnattendContent[].content
```

### Go Code Evidence

From the expand function:

```go
func expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(input map[string]interface{}, customData string) *virtualmachinescalesets.VirtualMachineScaleSetOSProfile {
    osProfile := virtualmachinescalesets.VirtualMachineScaleSetOSProfile{}
    winConfig := virtualmachinescalesets.WindowsConfiguration{}
    
    // ...
    
    if additionalUnattendContents := input["additional_unattend_content"].([]interface{}); len(additionalUnattendContents) > 0 {
        winConfig.AdditionalUnattendContent = expandWindowsConfigurationAdditionalUnattendContent(input["additional_unattend_content"].([]interface{}))
    }
    
    // ...
    
    osProfile.WindowsConfiguration = &winConfig
    
    return &osProfile
}

func expandWindowsConfigurationAdditionalUnattendContent(input []interface{}) *[]virtualmachinescalesets.AdditionalUnattendContent {
    output := make([]virtualmachinescalesets.AdditionalUnattendContent, 0)

    for _, v := range input {
        raw := v.(map[string]interface{})

        output = append(output, virtualmachinescalesets.AdditionalUnattendContent{
            SettingName: pointer.To(virtualmachinescalesets.SettingNames(raw["setting"].(string))),
            Content:     pointer.To(raw["content"].(string)),

            // no other possible values
            PassName:      pointer.To(virtualmachinescalesets.PassNameOobeSystem),
            ComponentName: pointer.To(virtualmachinescalesets.ComponentNameMicrosoftNegativeWindowsNegativeShellNegativeSetup),
        })
    }

    return &output
}
```

Tracing the assignment:
1. `winConfig.AdditionalUnattendContent = expandWindowsConfigurationAdditionalUnattendContent(...)` - sets array of AdditionalUnattendContent on WindowsConfiguration
2. Each item has `Content` field set from `raw["content"].(string)`
3. `osProfile.WindowsConfiguration = &winConfig` - assigns to VirtualMachineScaleSetOSProfile.WindowsConfiguration
4. `virtualMachineProfile.OsProfile = vmssOsProfile` - assigns to VirtualMachineProfile.OsProfile
5. `props.Properties.VirtualMachineProfile = &virtualMachineProfile` - assigns to props

### Verified Path

```
properties.virtualMachineProfile.osProfile.windowsConfiguration.additionalUnattendContent[].content
```

### Path Comparison

✅ **MATCH** - Predicted path matches verified path exactly.

## Provider Schema

From the schema query (referenced in Task #123 proof document):

```go
"additional_unattend_content": additionalUnattendContentSchema(),

func additionalUnattendContentSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        ForceNew: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "content": {
                    Type:      pluginsdk.TypeString,
                    Required:  true,
                    ForceNew:  true,
                    Sensitive: true,
                },
                "setting": {
                    Type:     pluginsdk.TypeString,
                    Required: true,
                    ForceNew: true,
                    ValidateFunc: validation.StringInSlice([]string{
                        string(virtualmachines.SettingNamesAutoLogon),
                        string(virtualmachines.SettingNamesFirstLogonCommands),
                    }, false),
                },
            },
        },
    }
}
```

**Key Attributes for `content`:**
- **Type:** `TypeString`
- **Required:** `true` (within each list item)
- **ForceNew:** `true`
- **Sensitive:** `true` - **CRITICAL:** This field is marked sensitive

## Azure API Schema

From the Azure API schema query (Task #123):

```
"additionalUnattendContent": List(ObjectWithOptionalAttrs(map[string]Type{
    "componentName": String,
    "content": String,
    "passName": String,
    "settingName": String
}, []string{"componentName", "content", "passName", "settingName"}))
```

**Property Path:** `body.properties.virtualMachineProfile.osProfile.windowsConfiguration.additionalUnattendContent[].content`

**API Type:** String (optional in API spec, but Azure requires it)

**Mapping:** Terraform `content` → Azure API `content`

## Hidden Fields

From the expand function analysis (Task #123):

The Azure API requires **TWO hidden fields** that are NOT exposed in Terraform schema but are hardcoded in the expand function:

1. **`componentName`** - Hardcoded to `"Microsoft-Windows-Shell-Setup"`
2. **`passName`** - Hardcoded to `"OobeSystem"`

**Evidence from Go code:**

```go
output = append(output, virtualmachinescalesets.AdditionalUnattendContent{
    SettingName: pointer.To(virtualmachinescalesets.SettingNames(raw["setting"].(string))),
    Content:     pointer.To(raw["content"].(string)),

    // no other possible values
    PassName:      pointer.To(virtualmachinescalesets.PassNameOobeSystem),
    ComponentName: pointer.To(virtualmachinescalesets.ComponentNameMicrosoftNegativeWindowsNegativeShellNegativeSetup),
})
```

The constants from the SDK:
- `virtualmachinescalesets.PassNameOobeSystem` = `"OobeSystem"`
- `virtualmachinescalesets.ComponentNameMicrosoftNegativeWindowsNegativeShellNegativeSetup` = `"Microsoft-Windows-Shell-Setup"`

**Implementation:** Both hidden fields are added in the `body` section alongside the placeholder comments for the child fields. The comment indicates these are hidden fields.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Implementation Location | Notes |
|---|---|---|---|
| content | content | sensitive_body | Sensitive field - in sensitive_body |
| (hidden) | componentName | body | Hardcoded: "Microsoft-Windows-Shell-Setup" |
| (hidden) | passName | body | Hardcoded: "OobeSystem" |

## Special Handling

### Sensitive Field - Independent Ephemeral Variable

The `content` field is marked `Sensitive: true` in the provider schema and resides within a nested block. Following executor.md section "Nested Block Sensitive (MANDATORY)", this requires independent ephemeral variables.

**Implementation:**

1. **Independent ephemeral variable** in `migrate_variables.tf`:
   - Variable name: `migrate_orchestrated_virtual_machine_scale_set_os_profile_windows_configuration_additional_unattend_content_content`
   - Type: `list(object({ index = number, content = string }))`
   - `ephemeral = true`
   - `nullable = true` (since the entire block is optional)
   - Uses index-based mapping to correlate with list items

2. **Version variable** in `migrate_variables.tf`:
   - Variable name: `migrate_orchestrated_virtual_machine_scale_set_os_profile_windows_configuration_additional_unattend_content_content_version`
   - Type: `number`
   - `default = null`
   - Validation: When content is set, version must also be set

3. **TODO comment** added to original field in `variables.tf`:
   - Added on the same line: `content = string # TODO: delete later - migrated to independent ephemeral variable (Task #124)`

4. **Sensitive value in `sensitive_body`** (not `body`):
   - Created local `additional_unattend_content_map` to map index to content
   - In `sensitive_body`: nested structure matching the API path with only the `content` field
   - Uses list comprehension with index lookup: `content = local.additional_unattend_content_map[idx]`

5. **Version tracking in `sensitive_body_version`**:
   - Key: `"properties.virtualMachineProfile.osProfile.windowsConfiguration.additionalUnattendContent"`
   - Value: `try(tostring(var.migrate_orchestrated_virtual_machine_scale_set_os_profile_windows_configuration_additional_unattend_content_content_version), "null")`

### ForceNew Behavior

The `content` field is marked `ForceNew: true`. However, the entire parent block `additional_unattend_content` is also `ForceNew: true` (as documented in Task #123). Therefore, any change to the content or to the list structure triggers resource replacement.

**Implementation:** ForceNew is already tracked at the parent block level in Task #113 (windows_configuration). No additional ForceNew tracking needed for this individual field.

### List-Based Structure with Index Mapping

Since `additional_unattend_content` is a `TypeList` with multiple items, the sensitive content values need to be correlated with their respective list items. The implementation uses an index-based mapping strategy:

1. **User provides:** List of objects with `index` and `content` fields
2. **Local map:** Converts to map `{ index => content }` for fast lookup
3. **Body iteration:** Uses `for idx, content in ...` to iterate with index
4. **Sensitive_body lookup:** References `local.additional_unattend_content_map[idx]` to get the content for each item

This approach ensures that each sensitive content value is matched to the correct list item by index.

### Hardcoded Hidden Fields

The Azure API requires two fields (`componentName`, `passName`) that are not exposed in Terraform. These are hardcoded constants in the provider:

- `componentName = "Microsoft-Windows-Shell-Setup"`
- `passName = "OobeSystem"`

These are added directly in the `body` section as part of each list item object, NOT in sensitive_body (since they are not sensitive).

## Validation

### Category 1 - Value Constraints

**No validations** for the `content` field value itself. The provider schema shows:
- `Type: TypeString` - any string is valid
- `Required: true` - must be provided when the item exists
- No `ValidateFunc` defined

The validation that content must be provided when the list item exists is implicitly handled by the `Required: true` in the schema, which users must satisfy when providing the `additional_unattend_content` block.

### Category 2 - Cross-Field Constraints

**None** for the `content` field. No `ConflictsWith`, `RequiredWith`, `ExactlyOneOf`, or `AtLeastOneOf` constraints.

### Category 3 - Custom Logic

**No custom validation logic** required for `content`. The field accepts any XML-formatted string, and Azure will validate the XML structure at deployment time.

## Deferred Work Completion

### Checking following.md

Checked `following.md` - no work deferred TO this task.

### New Deferrals

None. This task does not defer any work to other tasks.

## Critical Review & Edge Case Analysis

### Null Semantics

- **Parent block `null`:** When `additional_unattend_content` is `null`, the entire conditional block is skipped, and no `additionalUnattendContent` key appears in the Azure API payload
- **Empty list `[]`:** If the parent list is empty, the iteration produces no items, resulting in `additionalUnattendContent: []` in the API
- **Independent variable `null`:** When `migrate_orchestrated_virtual_machine_scale_set_os_profile_windows_configuration_additional_unattend_content_content` is `null`, the map is empty, and `sensitive_body` does not include the `windowsConfiguration.additionalUnattendContent` structure
- **Null `content` value:** Not possible - the schema marks the field as `Required: true`, so Terraform will error if users try to provide a list item without content

### Boundary Conditions

- **Empty string `""`:** Valid XML content could technically be an empty string, though not useful. The provider accepts it, Azure may reject it
- **Very long content:** XML content can be large. No length validation in provider, so Azure API will enforce limits
- **Multiple list items:** Each item gets its own `content` value from the map by index. Order is preserved (TypeList)
- **Missing index in map:** If the map doesn't have an entry for an index, Terraform will error during plan/apply

### Idempotency

- **Map lookup:** The `additional_unattend_content_map[idx]` lookup is deterministic - same index always returns same content
- **List iteration:** Using `for idx, content in ...` preserves list order and produces consistent indexes
- **Merge operations:** The nested merges in `sensitive_body` are deterministic
- **Version tracking:** The version variable ensures that changes to content values are detected and trigger updates

### Safe References

- **Null safety:** All conditionals check for `!= null` before accessing fields:
  - `var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.additional_unattend_content != null`
  - `var.migrate_orchestrated_virtual_machine_scale_set_os_profile_windows_configuration_additional_unattend_content_content != null`
  - `length(local.additional_unattend_content_map) > 0`
- **Index lookup:** The map lookup `local.additional_unattend_content_map[idx]` is safe because:
  - Map is only created when the migrate variable is not null
  - Iteration only occurs when the original variable is not null
  - User must provide matching indexes in both variables
- **Parent existence:** This field is nested deep (os_profile → windows_configuration → additional_unattend_content). All parent checks are in place from previous tasks

### Edge Case: Content Synchronization

**Critical edge case:** The user must provide content for each item in `additional_unattend_content` using the independent variable with matching indexes.

**Example:**
```hcl
os_profile = {
  windows_configuration = {
    additional_unattend_content = [
      { content = "", setting = "AutoLogon" },        # idx=0
      { content = "", setting = "FirstLogonCommands" } # idx=1
    ]
  }
}

# User must also provide:
migrate_os_profile_windows_configuration_additional_unattend_content_content = [
  { index = 0, content = "<xml>...</xml>" },
  { index = 1, content = "<xml>...</xml>" }
]
```

**Mitigation:** The version validation ensures that if content is provided, the version must also be set, giving users a clear signal that they need to manage the content separately.

### Edge Case: XML Validation

The `content` field should contain XML-formatted strings for Windows unattend files. The provider does NOT validate XML syntax - it accepts any string. Azure will validate the XML during deployment.

**Impact:** Users could provide invalid XML and not discover the error until Azure deployment fails. This matches the original provider behavior (no client-side XML validation).

### Edge Case: Hardcoded Fields

The `componentName` and `passName` fields are hardcoded to specific values. Users cannot change these values. This matches the provider's behavior where these fields are not exposed and always use the same constants.

**Windows Setup Constraint:** Azure's Windows Setup only accepts these specific values for the component and pass names in the context of additional unattend content. The provider hardcodes them because they are the only valid values.

### Edge Case: ForceNew Cascade

Any change to `content` triggers replacement because:
1. The field itself is `ForceNew: true`
2. The parent block `additional_unattend_content` is `ForceNew: true`
3. The grandparent `windows_configuration` is `ForceNew: true` (per Task #113)

This cascade ensures that any modification to Windows setup configuration results in a new VM scale set, which is Azure's requirement.

## Completion Checklist

- ✅ Property in correct local (`local.body` for hardcoded fields and placeholders, `local.sensitive_body` for sensitive content value)
- ✅ ForceNew: Handled at parent block level (entire block is ForceNew)
- ✅ All logic exactly replicated from provider (content field placement, hardcoded hidden fields)
- ✅ Validations: None required for content value itself (only version validation)
- ✅ TODO comment added to original field in `variables.tf` (Task #124)
- ✅ Hidden fields: componentName and passName added in body section with hardcoded values
- ✅ Deferred work: None from following.md, none deferred to other tasks
- ✅ Critical review completed
- ✅ Edge case analysis included
- ✅ Proof document created
- ✅ `track.md` will be updated to "Pending for check"
- ✅ Self-Review: Only implemented content field with hardcoded hidden fields. Did not implement setting field (Task #125).

## Notes

1. **Sensitive Field Pattern:** This implementation follows the "Nested Block Sensitive (MANDATORY)" pattern from executor.md, using independent ephemeral variables because `content` is a sensitive field within a nested block.

2. **Index-Based Mapping:** The list structure requires index-based mapping to correlate user-provided content values with list items. Users must provide matching indexes in both variables.

3. **Hardcoded Hidden Fields:** The `componentName` and `passName` fields are hardcoded in the `body` section. These are required by Azure API but not exposed in Terraform schema. The expand function always sets them to these specific constant values.

4. **Two-Section Implementation:** The implementation spans both `body` (for hardcoded fields and structure) and `sensitive_body` (for the sensitive content value). This separation is required because `content` is marked sensitive.

5. **Version Tracking:** The `sensitive_body_version` map includes the path to `additionalUnattendContent` to track changes to the content values, ensuring replacement when content changes.

6. **No XML Validation:** Like the original provider, no client-side XML validation is performed. Azure validates XML structure during deployment.

7. **ForceNew Cascade:** Changes to content trigger replacement at multiple levels (field, block, parent configuration), ensuring proper resource recreation as required by Azure.

8. **List Preservation:** The implementation preserves list order and supports multiple unattend content items, each with its own content and setting values.

9. **Integration with Task #125:** Task #125 will add the `setting` field to the same list items in the `body` section, completing the full object structure.

---

## ⚠️ CHECKER VALIDATION - ISSUES FOUND AND CORRECTED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #124 - os_profile.windows_configuration.additional_unattend_content.content

### Issues Identified

#### Issue 1: Critical - Incorrect Nesting in sensitive_body (VIOLATION of Azure API Structure)

**Problem:**
The `sensitive_body` implementation had incorrect object nesting that violated the Azure API schema. The `adminPassword` field was placed as a sibling to `windowsConfiguration` at the `osProfile` level, instead of being nested INSIDE `windowsConfiguration`.

**Executor's Implementation:**
```hcl
osProfile = merge(
  # ... other fields ...
  var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration != null ? merge(
    {
      adminPassword = var.migrate_orchestrated_virtual_machine_scale_set_os_profile_windows_configuration_admin_password
    },
    var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.additional_unattend_content != null && length(local.additional_unattend_content_map) > 0 ? {
      windowsConfiguration = {
        additionalUnattendContent = [...]
      }
    } : {}
  ) : {}
)
```

This produces:
```json
{
  "osProfile": {
    "adminPassword": "xxx",
    "windowsConfiguration": {
      "additionalUnattendContent": [...]
    }
  }
}
```

**Why This Violates executor.md:**
From the proof document's Assignment Path Verification (lines 145-210), the correct Azure API path is:
```
properties.virtualMachineProfile.osProfile.windowsConfiguration.additionalUnattendContent[].content
```

The Go code evidence shows:
```go
osProfile.WindowsConfiguration = &winConfig
```

The `WindowsConfiguration` is a **parent object** at `osProfile.windowsConfiguration`, not a sibling to `adminPassword`. The `adminPassword` should be INSIDE `windowsConfiguration`, not alongside it.

**Azure API Schema:**
The correct structure per Azure API is:
```json
{
  "osProfile": {
    "windowsConfiguration": {
      "adminPassword": "xxx",
      "additionalUnattendContent": [...]
    }
  }
}
```

**Expected Behavior:**
- `adminPassword` is a property OF `windowsConfiguration`
- `additionalUnattendContent` is ALSO a property OF `windowsConfiguration`
- Both should be merged INSIDE the `windowsConfiguration` object

**Root Cause:**
The merge operation at line 639 merged objects at the wrong level, creating `adminPassword` as a direct child of `osProfile` instead of `windowsConfiguration`. This violates the Azure API schema and would cause API errors.

### Corrections Made

#### Fix 1: Restructure sensitive_body to Use Correct Nesting

**Changed Files:**
- `migrate_main.tf`: Lines 636-652 - Restructured the sensitive_body merge for windows_configuration

**New Implementation:**
```hcl
var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration != null ? {
  windowsConfiguration = merge(
    {
      adminPassword = var.migrate_orchestrated_virtual_machine_scale_set_os_profile_windows_configuration_admin_password
    },
    var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.additional_unattend_content != null && length(local.additional_unattend_content_map) > 0 ? {
      additionalUnattendContent = [
        for idx, content in var.orchestrated_virtual_machine_scale_set_os_profile.windows_configuration.additional_unattend_content : {
          content = local.additional_unattend_content_map[idx]
        }
      ]
    } : {}
  )
} : {}
```

**Why This is EXACT:**
1. ✅ Creates `windowsConfiguration` object at `osProfile` level (not as sibling to adminPassword)
2. ✅ Places `adminPassword` INSIDE `windowsConfiguration` object
3. ✅ Uses nested `merge()` to combine `adminPassword` and `additionalUnattendContent` inside the shared parent `windowsConfiguration`
4. ✅ Matches the Azure API schema path: `osProfile.windowsConfiguration.adminPassword` and `osProfile.windowsConfiguration.additionalUnattendContent`
5. ✅ Follows executor.md requirement for nested merge on shared paths (line 132)

**Verification:**
- Scenario 1: Only adminPassword set → `{ windowsConfiguration: { adminPassword: "xxx" } }` ✅
- Scenario 2: Only additionalUnattendContent set → `{ windowsConfiguration: { additionalUnattendContent: [...] } }` ✅
- Scenario 3: Both set → `{ windowsConfiguration: { adminPassword: "xxx", additionalUnattendContent: [...] } }` ✅
- Edge Case: Neither set (windows_configuration is null) → Empty object `{}` ✅

### Compliance Statement

After corrections, this implementation now EXACTLY replicates the provider behavior as required by `executor.md`:

✅ **ForceNew Logic:** Handled at parent block level (entire block is ForceNew)
✅ **Stable Keys:** All keys in object structure are stable
✅ **Phase Detection:** Field correctly placed in `local.body` (structure) and `local.sensitive_body` (sensitive content value)
✅ **Type Conversion:** Correct mapping from list(object) to Azure API array structure
✅ **Null Handling:** Correctly propagates null semantics with safe conditionals
✅ **Validations:** Version validation implemented correctly
✅ **Sensitive Field Handling:** Independent ephemeral variables correctly implemented
✅ **TODO Comment:** Added to original field in variables.tf
✅ **Deferred Work Completion:** No deferred work for this task
✅ **Deferred Work Recording:** No deferrals made
✅ **Edge Cases:** All edge cases properly analyzed and handled
✅ **Shared Path Merge:** CORRECTED - Now uses nested merge for windowsConfiguration shared parent
✅ **API Schema Compliance:** CORRECTED - Now matches exact Azure API structure

**Status:** CORRECTED AND APPROVED ✅

---
