# Task #24 - Check Root Hidden Fields

## Summary

Examined the Create method for `azurerm_orchestrated_virtual_machine_scale_set` to identify hardcoded values in the root properties block. Found that `orchestrationMode` is hardcoded to `Flexible` with no corresponding schema argument. Added this to `local.body.properties`. No locks detected in CRUD methods.

## Shadow Implementation

```hcl
locals {
  body = merge(
    {
      properties = merge(
        {
          orchestrationMode = "Flexible"  # <- Hidden hardcoded field
        },
        var.orchestrated_virtual_machine_scale_set_zone_balance != null ? {
          zoneBalance = var.orchestrated_virtual_machine_scale_set_zone_balance
        } : {},
        # ... other properties
      )
    },
    # ... other root-level fields
  )
}
```

## Create Phase Verification

### Phase Classification: Single-Phase Create

**Query Method:** `query_terraform_block_implementation_source_code(block_type="resource", terraform_type="azurerm_orchestrated_virtual_machine_scale_set", entrypoint_name="create")`

**Pattern Identified:** Single-phase creation with direct `CreateOrUpdateThenPoll` call.

**Go Code Evidence:**

```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).Compute.VirtualMachineScaleSetsClient
	subscriptionId := meta.(*clients.Client).Account.SubscriptionId
	ctx, cancel := timeouts.ForCreate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	// ... validation and preparation code ...

	props := virtualmachinescalesets.VirtualMachineScaleSet{
		Location: location.Normalize(d.Get("location").(string)),
		Tags:     tags.Expand(t),
		Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
			PlatformFaultDomainCount: pointer.To(int64(d.Get("platform_fault_domain_count").(int))),
			// OrchestrationMode needs to be hardcoded to Uniform, for the
			// standard VMSS resource, since virtualMachineProfile is now supported
			// in both VMSS and Orchestrated VMSS...
			OrchestrationMode: pointer.To(virtualmachinescalesets.OrchestrationModeFlexible),
		},
	}

	// ... more property assignments ...

	log.Printf("[DEBUG] Creating Orchestrated %s.", id)
	if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
		return fmt.Errorf("creating Orchestrated %s: %w", id, err)
	}

	log.Printf("[DEBUG] Orchestrated %s was created", id)
	log.Printf("[DEBUG] Retrieving Orchestrated %s.", id)

	d.SetId(id.ID())

	return resourceOrchestratedVirtualMachineScaleSetRead(d, meta)
}
```

**Decision:** The `orchestrationMode` field is hardcoded to `Flexible` during the Create phase (before the `CreateOrUpdateThenPoll` call). This is a single-phase operation, so the field belongs in `local.body.properties`.

## Assignment Path Verification

### Predicted Path
`properties.orchestrationMode`

### Go Code Trace

From the Create method:

```go
props := virtualmachinescalesets.VirtualMachineScaleSet{
	Location: location.Normalize(d.Get("location").(string)),
	Tags:     tags.Expand(t),
	Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
		PlatformFaultDomainCount: pointer.To(int64(d.Get("platform_fault_domain_count").(int))),
		OrchestrationMode: pointer.To(virtualmachinescalesets.OrchestrationModeFlexible),
	},
}
```

**Struct Assignments:**
1. `props.Properties = &virtualmachinescalesets.VirtualMachineScaleSetProperties{...}` - Creates the properties object
2. Within Properties: `OrchestrationMode: pointer.To(virtualmachinescalesets.OrchestrationModeFlexible)` - Sets the orchestrationMode field

### Verified Path
`properties.orchestrationMode`

### Path Comparison
✅ **Match** - The predicted path matches the verified path from Go code analysis.

## Provider Schema

**No Schema Entry:** The `orchestrationMode` field has NO corresponding schema entry in the provider. This is a **hidden hardcoded field** that is automatically set by the provider.

**Go Code Evidence:**

The provider schema does not include an `orchestration_mode` argument. The Create method comment explicitly states:

```go
// OrchestrationMode needs to be hardcoded to Uniform, for the
// standard VMSS resource, since virtualMachineProfile is now supported
// in both VMSS and Orchestrated VMSS...
OrchestrationMode: pointer.To(virtualmachinescalesets.OrchestrationModeFlexible),
```

**Key Point:** The comment mentions "hardcoded to Uniform" for the standard VMSS resource, but for the **orchestrated** VMSS resource, it's hardcoded to **`Flexible`**. This is the defining characteristic that distinguishes orchestrated VMSS from standard VMSS.

## Azure API Schema

**Resource Type:** `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

**Field Path:** `properties.orchestrationMode`

**Query:** `query_azapi_resource_schema(resource_type="Microsoft.Compute/virtualMachineScaleSets", api_version="2024-11-01", path="body.properties.orchestrationMode")`

From Azure API specification, `orchestrationMode` is an enum with possible values:
- `Flexible`
- `Uniform`

For `azurerm_orchestrated_virtual_machine_scale_set`, the provider always sets this to `Flexible`.

## Hidden Fields

### orchestrationMode

**Type:** Hardcoded value
**Value:** `"Flexible"`
**Location:** `properties.orchestrationMode`
**Evidence:** Set in Create method with comment explaining it distinguishes orchestrated from standard VMSS
**Reason:** This is the defining characteristic of orchestrated VMSS - it MUST be `Flexible` for this resource type

## Locks Detection

### Create Method

**Query Method:** `query_terraform_block_implementation_source_code(block_type="resource", terraform_type="azurerm_orchestrated_virtual_machine_scale_set", entrypoint_name="create")`

**Search Pattern:** Looked for lock acquisition patterns:
- `locks.ByName(name, resourceType)`
- `locks.MultipleByName(&names, resourceType)`
- Any lock-related code

**Result:** ❌ **No locks found**

The Create method does not acquire any resource locks.

### Update Method

**Query Method:** `query_terraform_block_implementation_source_code(block_type="resource", terraform_type="azurerm_orchestrated_virtual_machine_scale_set", entrypoint_name="update")`

**Result:** ❌ **No locks found**

The Update method does not acquire any resource locks.

### Delete Method

**Query Method:** `query_terraform_block_implementation_source_code(block_type="resource", terraform_type="azurerm_orchestrated_virtual_machine_scale_set", entrypoint_name="delete")`

**Result:** ❌ **No locks found**

The Delete method does not acquire any resource locks.

**Conclusion:** The resource does not use any locking mechanism. The `local.locks` list remains empty.

## Mapping

Not applicable - this is a hardcoded value, not a user input.

## Special Handling

### Hardcoded Value

**Implementation:**
- Added `orchestrationMode = "Flexible"` to `properties` merge in `local.body`
- Placed as the first field in properties for clarity
- No variable reference needed - this is a constant

### Why Hidden Field Is Required

The Azure API requires `orchestrationMode` to be specified when creating a Virtual Machine Scale Set. The AzureRM provider hides this complexity from users by:

1. Providing two separate resources:
   - `azurerm_virtual_machine_scale_set` (standard, uses `Uniform` mode)
   - `azurerm_orchestrated_virtual_machine_scale_set` (flexible, uses `Flexible` mode)

2. Hardcoding the appropriate `orchestrationMode` based on the resource type used

When migrating to `azapi_resource`, we MUST explicitly set this field because AzAPI has no such abstraction - it directly exposes the Azure API structure.

### No ForceNew

The `orchestrationMode` field is **immutable** after creation per Azure API requirements. However, since this is a hardcoded constant that never changes, there's no need to add it to `replace_triggers_external_values`. The value will always be `"Flexible"` for this resource.

### No Validation

Since this is a hardcoded value (not a user input), no validation is needed.

## Critical Review & Edge Case Analysis

### Null Semantics
- **Not applicable** - This is a hardcoded constant, not nullable

### Boundary Conditions
- **Not applicable** - The value is always `"Flexible"`, no boundaries to check

### Idempotency
- ✅ **Idempotent** - The value is constant across all applies
- ✅ No risk of ordering issues or state drift

### Safe References
- ✅ **No references** - Direct string literal, no null checks needed

### Edge Cases

1. **Migration from Standard to Orchestrated VMSS**
   - Users cannot change `orchestrationMode` on an existing VMSS
   - Migration requires resource recreation
   - The hardcoded value ensures correct mode for orchestrated VMSS

2. **Compatibility with Azure API**
   - Azure API validates `orchestrationMode` is set correctly
   - Hardcoding ensures API compatibility
   - Prevents user error from invalid mode

3. **Future API Changes**
   - If Azure introduces new orchestration modes, this would require updating the Shadow Module
   - Current implementation matches provider v4.20.0 behavior exactly

### Consistency Check

**Verification:** Confirmed that `orchestrationMode` is:
- ✅ Set in Create method before API call
- ✅ NOT in provider schema (hidden from users)
- ✅ Required by Azure API specification
- ✅ Immutable after creation
- ✅ Always `"Flexible"` for orchestrated VMSS

## Checklist

- ✅ Property in correct local (`local.body.properties`)
- ✅ No ForceNew needed (immutable constant)
- ✅ Exact replication of provider behavior (hardcoded to "Flexible")
- ✅ No validations needed (not a user input)
- ✅ Hidden fields documented
- ✅ Locks detection performed (none found)
- ✅ Critical review completed (null, edge, idempotent, safe refs)
- ✅ Edge Case Analysis included
- ✅ Proof created
- ✅ Ready to update track.md
- ✅ Self-Review: Only added orchestrationMode field - no other hidden fields from future tasks

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-04
**Task:** #24 - __check_root_hidden_fields__

### Validation Results

✅ **Task Type:** Correctly identified as Type 2 (Check Root Hidden Fields)
✅ **Hidden Field Detection:** Correctly identified `orchestrationMode` hardcoded to "Flexible"
✅ **Placement:** Field correctly placed in `local.body.properties` (line 35 of migrate_main.tf)
✅ **Create Phase Verification:** Single-phase Create pattern correctly documented with Go code evidence
✅ **Assignment Path Verification:** Correct path `properties.orchestrationMode` with full struct trace
✅ **Locks Detection:** Properly performed across all CRUD methods (Create, Update, Delete), none found
✅ **ForceNew Logic:** Correctly determined no ForceNew trigger needed (immutable constant)
✅ **No Validations:** Correctly determined none needed (not a user input)
✅ **Edge Cases:** Comprehensive analysis including migration scenarios and API compatibility
✅ **Exact Replication:** Implementation exactly matches provider behavior (hardcoded to "Flexible")
✅ **Proof Quality:** All required sections present, Go code evidence provided, no forbidden phrases
✅ **Self-Review:** Confirmed only `orchestrationMode` added, no scope creep

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The `orchestrationMode` field is correctly hardcoded to `"Flexible"` matching the provider's behavior for orchestrated VMSS. No deviations, simplifications, or "safer alternatives" were found. The locks detection was properly performed across all CRUD methods. All required proof sections are complete with appropriate Go code evidence.

**Status:** APPROVED ✅

---
