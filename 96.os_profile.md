# Task #96: os_profile Block Structure Skeleton

## Summary

Created the structure skeleton for the `os_profile` block migration from `azurerm_orchestrated_virtual_machine_scale_set` to `azapi_resource`. This establishes the conditional framework with comment placeholders for all child fields (custom_data, linux_configuration, windows_configuration). The block maps to `properties.virtualMachineProfile.osProfile` in the Azure API.

## Shadow Implementation

```hcl
locals {
  body = {
    properties = merge(
      # ... existing properties ...
      var.orchestrated_virtual_machine_scale_set_os_profile != null ? {
        virtualMachineProfile = merge(
          # ... other virtualMachineProfile sections ...
          {
            osProfile = {
              # custom_data = ... # Task #97
              # allowExtensionOperations = ... # Hidden field - set in Create method
              # adminUsername = ... # Handled by child configurations
              # adminPassword = ... # Handled by child configurations  
              # computerNamePrefix = ... # Handled by child configurations
              # secrets = ... # Handled by child configurations
              # linuxConfiguration = ... # Task #98-112
              # windowsConfiguration = ... # Task #113-133
            }
          }
        )
      } : {}
    )
  }
}
```

## Create Phase Verification

### Pattern Identification

Queried the Create method using `query_terraform_block_implementation_source_code`:

**Pattern:** Single-phase creation

The `os_profile` block is processed during the Create phase and directly assigned to the request payload:

```go
osProfileRaw := d.Get("os_profile").([]interface{})

if len(osProfileRaw) > 0 && osProfileRaw[0] != nil {
    osProfile := osProfileRaw[0].(map[string]interface{})
    winConfigRaw = osProfile["windows_configuration"].([]interface{})
    linConfigRaw = osProfile["linux_configuration"].([]interface{})
    customData := ""

    // Pass custom data if it is defined in the config file
    if v := osProfile["custom_data"]; v != nil {
        customData = v.(string)
    }

    if len(winConfigRaw) > 0 && winConfigRaw[0] != nil {
        osType = virtualmachinescalesets.OperatingSystemTypesWindows
        winConfig := winConfigRaw[0].(map[string]interface{})
        vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithWindowsConfiguration(winConfig, customData)
        // ... validation logic ...
    }

    if len(linConfigRaw) > 0 && linConfigRaw[0] != nil {
        osType = virtualmachinescalesets.OperatingSystemTypesLinux
        linConfig := linConfigRaw[0].(map[string]interface{})
        vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration(linConfig, customData)
        // ... validation logic ...
    }

    if vmssOsProfile != nil {
        vmssOsProfile.AllowExtensionOperations = pointer.To(extensionOperationsEnabled)
    }

    virtualMachineProfile.OsProfile = vmssOsProfile
}

// Later assignment:
props.Properties.VirtualMachineProfile = &virtualMachineProfile
```

**Classification:** Create phase → Assign to `local.body`

### Decision

The `os_profile` block will be added to `local.body` as it is set during the single-phase create operation.

## Assignment Path Verification

### Predicted Path

`body.properties.virtualMachineProfile.osProfile`

### Go Code Evidence

From the Create method, the assignment chain is:

1. `vmssOsProfile = expandOrchestratedVirtualMachineScaleSetOsProfileWith{Windows|Linux}Configuration(...)`
2. `virtualMachineProfile.OsProfile = vmssOsProfile`
3. `props.Properties.VirtualMachineProfile = &virtualMachineProfile`
4. `client.CreateOrUpdateThenPoll(ctx, id, props, ...)`

```go
virtualMachineProfile := virtualmachinescalesets.VirtualMachineScaleSetVMProfile{
    StorageProfile: &virtualmachinescalesets.VirtualMachineScaleSetStorageProfile{},
}

// ... later ...

virtualMachineProfile.OsProfile = vmssOsProfile

// ... later ...

props.Properties.VirtualMachineProfile = &virtualMachineProfile
```

The struct assignment chain:
- `VirtualMachineScaleSet.Properties.VirtualMachineProfile.OsProfile`

### Verified Path

`body.properties.virtualMachineProfile.osProfile`

### Path Comparison

✅ **MATCH** - Predicted path matches the verified assignment chain from Go source code.

## Provider Schema

From `OrchestratedVirtualMachineScaleSetOSProfileSchema()`:

```go
func OrchestratedVirtualMachineScaleSetOSProfileSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        MaxItems: 1,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "custom_data": {
                    Type:         pluginsdk.TypeString,
                    Optional:     true,
                    Sensitive:    true,
                    ValidateFunc: validation.StringIsBase64,
                },
                "windows_configuration": OrchestratedVirtualMachineScaleSetWindowsConfigurationSchema(),
                "linux_configuration":   OrchestratedVirtualMachineScaleSetLinuxConfigurationSchema(),
            },
        },
    }
}
```

**Key Properties:**
- **Type:** List with MaxItems: 1
- **Optional:** Yes
- **Child Fields:**
  - `custom_data` (optional, sensitive)
  - `windows_configuration` (optional, mutually exclusive with linux_configuration)
  - `linux_configuration` (optional, mutually exclusive with windows_configuration)

## Azure API Schema

Query result for `body.properties.virtualMachineProfile.osProfile`:

```
ObjectWithOptionalAttrs(map[string]Type{
    "adminPassword": String,
    "adminUsername": String,
    "allowExtensionOperations": Bool,
    "computerNamePrefix": String,
    "customData": String,
    "linuxConfiguration": ObjectWithOptionalAttrs(...),
    "requireGuestProvisionSignal": Bool,
    "secrets": List(ObjectWithOptionalAttrs(...)),
    "windowsConfiguration": ObjectWithOptionalAttrs(...)
})
```

All properties are optional at the Azure API level.

## Hidden Fields Detection

### From Create Method Analysis

Found **ONE hidden field** set in the Create method:

#### 1. `allowExtensionOperations`

**Evidence from Create method:**

```go
extensionOperationsEnabled := d.Get("extension_operations_enabled").(bool)

// ... later in the code ...

if vmssOsProfile != nil {
    vmssOsProfile.AllowExtensionOperations = pointer.To(extensionOperationsEnabled)
}
```

**Source:** Root-level argument `extension_operations_enabled` (Task #8)
**Mapping:** `extension_operations_enabled` → `allowExtensionOperations`
**Note:** This field is NOT defined in the `os_profile` schema but is set programmatically from a root-level field.

#### 2. `requireGuestProvisionSignal`

This field exists in the Azure API schema but is NOT exposed in the Terraform schema. According to the TODO comment in the schema function:

```go
// TODO: exposing requireGuestProvisionSignal once it's available
// https://github.com/Azure/azure-rest-api-specs/pull/7246
```

**Status:** Not yet exposed - will remain unmapped until added to provider.

### Hidden Fields Assignment

The hidden field `allowExtensionOperations` should be added as part of Task #8 (`extension_operations_enabled`), not in this skeleton task. This skeleton only creates the framework.

## Mapping

| Terraform (snake_case) | Azure API (camelCase) | Notes |
|---|---|---|
| os_profile | osProfile | Block wrapper |
| custom_data | customData | Task #97 |
| linux_configuration | linuxConfiguration | Tasks #98-112 |
| windows_configuration | windowsConfiguration | Tasks #113-133 |

**Hidden fields (not in os_profile schema):**
- `allowExtensionOperations` - Set from root-level `extension_operations_enabled` (Task #8)

## Special Handling

### Block Conditionality

The entire `osProfile` object is conditional based on whether `var.orchestrated_virtual_machine_scale_set_os_profile` is not null.

### Mutual Exclusivity

From the Create method logic, `windows_configuration` and `linux_configuration` are mutually exclusive:
- If `windows_configuration` is set, osType = Windows
- If `linux_configuration` is set, osType = Linux
- Only one can be present at a time

### Computer Name Prefix Logic

Special defaulting logic exists in the Create method (NOT part of this skeleton task):
- If `computer_name_prefix` is not set, defaults to the scale set name
- Validation differs for Windows vs Linux
- Will be handled in child configuration tasks (#98-133)

### Extension Operations Validation

The Create method validates relationships between `extension_operations_enabled` (root-level) and `provision_vm_agent` (in configurations):

```go
if extensionOperationsEnabled && !provisionVMAgent {
    return fmt.Errorf("`extension_operations_enabled` cannot be set to `true` when `provision_vm_agent` is set to `false`")
}
```

This validation should be implemented in Task #8 when handling `extension_operations_enabled`.

## Validation

### Category 1 - Value Constraints

No direct value constraints for the block itself. Child fields have their own validations handled in respective tasks.

### Category 2 - Cross-Field Constraints

Not applicable at the block level. Child configurations have cross-field constraints handled in their respective tasks.

### Category 3 - Custom Logic

Mutual exclusivity between `windows_configuration` and `linux_configuration` is enforced by the structure (both are optional, but logically only one should be set). This is implicitly handled by the block structure.

## Critical Review & Edge Cases

### Null Semantics

- **`null` os_profile:** When `var.orchestrated_virtual_machine_scale_set_os_profile` is `null`, the entire `osProfile` object is omitted from the API payload (no virtualMachineProfile.osProfile property).
- **Empty os_profile:** Not possible in Terraform - the block must contain at least one of the child configurations.

### Boundary Conditions

1. **No configuration set:** If os_profile block is not provided, the entire osProfile section is omitted
2. **Both configurations provided:** While Terraform schema doesn't prevent this, the provider logic will only process one (Windows takes precedence in the code)

### Idempotency

The skeleton structure uses `merge()` which is idempotent. The conditional `!= null` check ensures the block is only added when explicitly configured.

### Safe References

All child field references will use safe navigation in their respective tasks (e.g., checking for null before accessing nested properties).

### Edge Case: Hidden Field Coordination

The `allowExtensionOperations` hidden field must be coordinated with Task #8. When Task #8 is implemented, it must add this field to the `osProfile` object within the skeleton structure created here.

## Child Tasks Ready for Delegation

The following child tasks are now **READY** for implementation as the parent skeleton structure is in place:

### Direct Children (Level 1)

| Task # | Field | Type | Dependent On |
|--------|-------|------|--------------|
| 97 | os_profile.custom_data | Argument | Skeleton #96 ✅ |
| 98 | os_profile.linux_configuration | Block Skeleton | Skeleton #96 ✅ |
| 113 | os_profile.windows_configuration | Block Skeleton | Skeleton #96 ✅ |

### Note on Task Ordering

Tasks #97, #98, and #113 can now proceed in parallel as they are independent of each other:
- Task #97 implements the `custom_data` argument
- Task #98 creates the skeleton for `linux_configuration` block (which enables tasks #99-112)
- Task #113 creates the skeleton for `windows_configuration` block (which enables tasks #114-133)

## Completion Checklist

- ✅ Property in correct local (`local.body`)
- ✅ Block structure skeleton created with comment placeholders
- ✅ Conditional logic based on variable null check
- ✅ ForceNew: Not applicable to block structure
- ✅ Validations: No validations at block level (handled by children)
- ✅ Hidden fields identified and documented (allowExtensionOperations)
- ✅ Critical review completed
- ✅ Edge case analysis included
- ✅ Proof document created
- ✅ `track.md` will be updated
- ✅ Self-Review: Only skeleton structure created, no child implementations

## Notes

1. **Skeleton Only:** This task creates ONLY the block structure framework. Child fields (#97-133) will be implemented in their respective tasks.

2. **Hidden Field Coordination:** Task #8 (`extension_operations_enabled`) must add the `allowExtensionOperations` field to this os_profile structure.

3. **Mutual Exclusivity:** While both `windows_configuration` and `linux_configuration` are optional in schema, logically only one should be populated at runtime. The provider code processes them sequentially but only one will actually be used based on OS type.

4. **Computer Name Defaulting:** Special logic exists to default `computer_name_prefix` to the scale set name if not provided. This will be handled in the respective configuration tasks (#98 and #113).

5. **No Direct Fields:** The os_profile block has no direct simple fields at its root level - all fields are either in child blocks (linux_configuration, windows_configuration) or the root-level custom_data which is passed to the expand functions.

6. **API Structure:** The osProfile sits under virtualMachineProfile, which is already part of the provider's structure. The merge pattern ensures proper nesting.
