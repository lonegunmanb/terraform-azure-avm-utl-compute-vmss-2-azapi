# Task #45 - extension.publisher

## Shadow Implementation

**File: `migrate_main.tf`**

```hcl
locals {
  body = {
    properties = merge(
      var.orchestrated_virtual_machine_scale_set_sku_name != null ? {
        virtualMachineProfile = merge(
          var.orchestrated_virtual_machine_scale_set_extension != null || var.orchestrated_virtual_machine_scale_set_extensions_time_budget != null ? {
            extensionProfile = merge(
              var.orchestrated_virtual_machine_scale_set_extension != null ? {
                extensions = [
                  for ext in var.orchestrated_virtual_machine_scale_set_extension : {
                    name = ext.name
                    properties = { # <-
                      publisher = ext.publisher # <-
                      # type = ... # Task #46
                      # typeHandlerVersion = ... # Task #47
                      # ... other fields
                    } # <-
                  }
                ]
              } : {},
              # ... extensions_time_budget merge
            )
          } : {}
        )
      } : {}
    )
  }
}
```

**File: `variables.tf`**

```hcl
variable "orchestrated_virtual_machine_scale_set_extension" {
  type = set(object({
    # ... other fields
    publisher = string # <-
    # ... other fields
  }))
  
  validation { # <-
    condition = ( # <-
      var.orchestrated_virtual_machine_scale_set_extension == null || # <-
      alltrue([for ext in var.orchestrated_virtual_machine_scale_set_extension : ext.publisher != ""]) # <-
    ) # <-
    error_message = "The extension publisher must not be empty." # <-
  } # <-
}
```

## Summary

Implemented `extension.publisher` field which maps to `properties.virtualMachineProfile.extensionProfile.extensions[].properties.publisher` in Azure API. The field is Required with StringIsNotEmpty validation in the provider schema. This is the first field inside the `properties` sub-object of each extension.

## Create Phase Verification

### Query Create Method

From `resourceOrchestratedVirtualMachineScaleSetCreate` source code:

```go
if v, ok := d.GetOk("extension"); ok {
    var err error
    virtualMachineProfile.ExtensionProfile, hasHealthExtension, err = expandOrchestratedVirtualMachineScaleSetExtensions(v.(*pluginsdk.Set).List())
    if err != nil {
        return err
    }
}

// Later in the Create method (before CreateOrUpdateThenPoll):
if !isLegacy {
    props.Properties.VirtualMachineProfile = &virtualMachineProfile
}

log.Printf("[DEBUG] Creating Orchestrated %s.", id)
if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
    return fmt.Errorf("creating Orchestrated %s: %w", id, err)
}
```

**Pattern:** Single-phase creation pattern. Extension data is expanded via `expandOrchestratedVirtualMachineScaleSetExtensions` and assigned to `virtualMachineProfile.ExtensionProfile` which is then assigned to `props.Properties.VirtualMachineProfile` before the `CreateOrUpdateThenPoll` call.

**Classification:** Create phase - field is set before the create API call.

**Decision:** Implement in `local.body` (NOT in `local.post_creation_updates`).

## Assignment Path Verification

### Predicted Path

`properties.virtualMachineProfile.extensionProfile.extensions[].properties.publisher`

### Go Code Evidence

From `expandOrchestratedVirtualMachineScaleSetExtensions` function:

```go
func expandOrchestratedVirtualMachineScaleSetExtensions(input []interface{}) (extensionProfile *virtualmachinescalesets.VirtualMachineScaleSetExtensionProfile, hasHealthExtension bool, err error) {
    extensionProfile = &virtualmachinescalesets.VirtualMachineScaleSetExtensionProfile{}
    if len(input) == 0 {
        return nil, false, nil
    }

    extensions := make([]virtualmachinescalesets.VirtualMachineScaleSetExtension, 0)
    for _, v := range input {
        extensionRaw := v.(map[string]interface{})
        extension := virtualmachinescalesets.VirtualMachineScaleSetExtension{
            Name: pointer.To(extensionRaw["name"].(string)),
        }
        
        extensionProps := virtualmachinescalesets.VirtualMachineScaleSetExtensionProperties{
            Publisher:               pointer.To(extensionRaw["publisher"].(string)), // <- Assigns to Publisher field
            Type:                    &extensionType,
            TypeHandlerVersion:      pointer.To(extensionRaw["type_handler_version"].(string)),
            AutoUpgradeMinorVersion: pointer.To(autoUpgradeMinorVersion),
        }
        // ... other properties
        
        extension.Properties = &extensionProps // <- Assigns properties to extension
        extensions = append(extensions, extension)
    }
    extensionProfile.Extensions = &extensions  // <- Assigns to Extensions field

    return extensionProfile, hasHealthExtension, nil
}

// Assignment trace in Create method:
virtualMachineProfile.ExtensionProfile = expandedProfile  // <- Returns extensionProfile
// ... later ...
props.Properties.VirtualMachineProfile = &virtualMachineProfile  // <- Adds VirtualMachineProfile nesting
```

**Trace:**
1. `expandOrchestratedVirtualMachineScaleSetExtensions` creates `VirtualMachineScaleSetExtensionProperties` with `Publisher` field set
2. Properties are assigned to `extension.Properties`
3. Extensions are assigned to `extensionProfile.Extensions`
4. `extensionProfile` is assigned to `virtualMachineProfile.ExtensionProfile`
5. `virtualMachineProfile` is assigned to `props.Properties.VirtualMachineProfile`
6. Final path: `properties.virtualMachineProfile.extensionProfile.extensions[].properties.publisher`

**Key Observation:** The `publisher` field is inside the `properties` sub-object of each extension, NOT at the root level like `name`.

### Verified Path

`properties.virtualMachineProfile.extensionProfile.extensions[].properties.publisher`

### Path Comparison

✅ **MATCH** - Predicted path matches verified path. The `publisher` field is correctly placed inside the `properties` sub-object.

## Provider Schema

From `OrchestratedVirtualMachineScaleSetExtensionsSchema` function:

```go
func OrchestratedVirtualMachineScaleSetExtensionsSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeSet,
        Optional: true,
        Computed: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "name": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ValidateFunc: validation.StringIsNotEmpty,
                },

                "publisher": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ValidateFunc: validation.StringIsNotEmpty,
                },

                "type": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ValidateFunc: validation.StringIsNotEmpty,
                },

                "type_handler_version": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ValidateFunc: validation.StringIsNotEmpty,
                },
                // ... other fields
            },
        },
    }
}
```

**Key Properties:**
- **Type:** `TypeString`
- **Required:** `true`
- **Validation:** `validation.StringIsNotEmpty` - ensures the publisher is not an empty string
- **ForceNew:** Not present (not a ForceNew field)
- **Computed:** Not present (not a Computed field)
- **Sensitive:** Not present (not sensitive)
- **DiffSuppressFunc:** Not present

## Azure API Schema

**Path:** `properties.virtualMachineProfile.extensionProfile.extensions[].properties.publisher`

**Type:** String

**Extension Properties Structure:**
```
{
  "name": "string",  // Root level
  "properties": {    // Properties sub-object
    "publisher": "string",
    "type": "string",
    "typeHandlerVersion": "string",
    // ... other fields
  }
}
```

## Hidden Fields

None. The `publisher` field is directly mapped from Terraform configuration without any transformations or computed values.

## Mapping

**Terraform → Azure API:**

| Terraform Field | Azure API Field | Notes |
|----------------|-----------------|-------|
| `extension[].publisher` | `extensions[].properties.publisher` | No naming conversion needed |

**Naming:** The field name `publisher` remains unchanged (no snake_case to camelCase conversion).

## Special Handling

### No ForceNew Logic

The `publisher` field does NOT have `ForceNew: true` in the provider schema. However, extensions are part of a set, and changing the publisher effectively creates a new extension entry in the set.

**Decision:** No explicit ForceNew tracking needed for this field. The set-based nature of the `extension` block handles identity changes automatically through Terraform's set hashing mechanism.

### Validation Implementation

The provider schema includes `ValidateFunc: validation.StringIsNotEmpty`. Per executor.md lines 95-100, ALL value constraint validations MUST be replicated in `variables.tf`.

**Implementation:**
```hcl
validation {
  condition = (
    var.orchestrated_virtual_machine_scale_set_extension == null ||
    alltrue([for ext in var.orchestrated_virtual_machine_scale_set_extension : ext.publisher != ""])
  )
  error_message = "The extension publisher must not be empty."
}
```

**Why This is EXACT:**
1. Replicates `validation.StringIsNotEmpty` from the provider
2. Checks all extension objects in the set using `alltrue()`
3. Correctly handles the case when the entire extension set is `null`
4. The error message matches the provider's intent (preventing empty publishers)

### Properties Sub-Object Creation

**Critical Implementation Detail:** Task #45 is the first field to be implemented inside the `properties` sub-object. This task creates the `properties` block structure.

**Implementation:**
```hcl
for ext in var.orchestrated_virtual_machine_scale_set_extension : {
  name = ext.name  # <- Root level (Task #44)
  properties = {   # <- Created by Task #45
    publisher = ext.publisher  # <- Task #45
    # type = ... # Task #46
    # ... other fields inside properties
  }
}
```

## Deferred Work Completion

Checked `following.md` - **File does not exist.** No deferred work to complete for this task.

## Critical Review & Edge Case Analysis

### Null Semantics

- **`ext.publisher == null`:** Not possible. The field is defined as `publisher = string` (not `optional(string)`) in the variable type, so Terraform enforces non-null constraint at plan time.
- **`ext.publisher == ""`:** Would violate the StringIsNotEmpty validation. The validation block explicitly prevents empty strings.

**Note:** The validation ensures empty strings are rejected at plan time, exactly matching the provider's behavior.

### Edge Cases

1. **Empty Extension Set:** If `var.orchestrated_virtual_machine_scale_set_extension == null`, the entire extension skeleton is omitted (handled by Task #43). If the set is empty (`[]`), an empty extensions array would be created, which is valid.

2. **Duplicate Publishers:** Multiple extensions can have the same publisher (e.g., "Microsoft.Azure.Extensions"). The Azure API allows this - extensions are identified by their name, not publisher.

3. **Publisher Length:** The provider schema does not specify a maximum length validation for publisher names. Azure API likely has limits, but we don't replicate them here (following provider behavior).

4. **Special Characters:** No validation for allowed characters in the provider schema. We follow provider behavior by not adding restrictions. Common publishers include dots (e.g., "Microsoft.Azure.Extensions").

5. **Case Sensitivity:** The provider does not normalize case. We pass the value through unchanged, preserving user input exactly.

### Idempotency

- **String Value:** Direct mapping of string value from Terraform to Azure API ensures idempotency.
- **No Transformations:** No case conversions, no trimming, no normalization - the value passes through unchanged.
- **Set Identity:** The publisher field contributes to set element identity in Terraform along with other fields.

### Safe References

- **Null Safety:** The field is accessed as `ext.publisher` within a `for` loop iterating over a set. The loop only executes if the set is non-null (checked by Task #43's conditional: `var.orchestrated_virtual_machine_scale_set_extension != null`).
- **Type Safety:** The type constraint `publisher = string` ensures the field is always a string when accessed.
- **Validation Safety:** The validation block ensures the string is never empty, matching provider behavior.

## Checklist

- ✅ Property in correct local (`local.body`)
- ✅ Correct path (`extensions[].properties.publisher` inside properties sub-object)
- ✅ No ForceNew needed (set-based identity handling)
- ✅ Validation IMPLEMENTED in variables.tf (StringIsNotEmpty)
- ✅ Hidden fields checked (none)
- ✅ Provider schema analyzed
- ✅ Azure API schema verified
- ✅ Create phase verified (single-phase, before API call)
- ✅ Assignment path traced and verified
- ✅ Mapping documented
- ✅ Edge cases analyzed
- ✅ Critical review completed
- ✅ Deferred work checked (none exists)
- ✅ Implementation exactly matches provider behavior
- ✅ Properties sub-object created for first field
- ✅ Proof document created
- ✅ Self-review: Only implemented extension.publisher field as required by Task #45

---

**Status:** ✅ Ready for Checker Review

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-08
**Task:** #45 - extension.publisher

### Validation Results

✅ **Field Placement:** Correctly placed inside `properties` sub-object at `extensions[].properties.publisher`
✅ **Assignment Path:** Traced through Go code - matches predicted path exactly
✅ **Create Phase:** Correctly placed in `local.body` (single-phase creation, before API call)
✅ **Type Conversion:** Direct string mapping, no conversion needed
✅ **Null Handling:** Type constraint `publisher = string` enforces non-null
✅ **Validation Implementation:** StringIsNotEmpty validation correctly replicated in `variables.tf`:
  - Checks for null set first
  - Uses `alltrue()` to validate all extensions
  - Checks `ext.publisher != ""`
  - Error message matches provider intent
✅ **ForceNew Logic:** Not applicable - set-based identity handles changes automatically
✅ **Stable Keys:** Not applicable to this field
✅ **Properties Sub-Object Creation:** Task #45 correctly creates the `properties` block structure
✅ **Deferred Work Completion:** No `following.md` file exists - no deferred work to complete
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** Properly analyzed - empty strings prevented, null handled, no transformations
✅ **Proof Document Quality:** No forbidden phrases found, exact replication documented

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`:
- The field is placed in the correct location within the Azure API structure
- The provider's `validation.StringIsNotEmpty` is correctly replicated
- No deviations, simplifications, or "safer alternatives" were found
- The proof document shows comprehensive analysis with Go code evidence
- All checker.md validation requirements are met

**Status:** APPROVED ✅
