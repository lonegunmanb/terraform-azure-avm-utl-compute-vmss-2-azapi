# Task #60 - network_interface - Structure Skeleton

## Summary

Created structure skeleton for `network_interface` block in `virtualMachineProfile.networkProfile.networkInterfaceConfigurations`. The skeleton includes conditional rendering when `network_interface` is provided, properly integrates with existing `networkApiVersion`, and sets up comment placeholders for all child tasks (#61-#86).

## Shadow Implementation

```hcl
var.orchestrated_virtual_machine_scale_set_network_api_version != null || var.orchestrated_virtual_machine_scale_set_network_interface != null ? { # <-
  networkProfile = merge( # <-
    var.orchestrated_virtual_machine_scale_set_network_api_version != null ? { # <-
      networkApiVersion = var.orchestrated_virtual_machine_scale_set_network_api_version # <-
    } : {}, # <-
    var.orchestrated_virtual_machine_scale_set_network_interface != null ? { # <-
      networkInterfaceConfigurations = [ # <-
        for nic in var.orchestrated_virtual_machine_scale_set_network_interface : { # <-
          name = nic.name # Task #61 # <-
          properties = merge( # <-
            { # <-
              # auxiliaryMode = ... # Task #62 # <-
              # auxiliarySku = ... # Task #63 # <-
              # dnsSettings = { # Task #64 # <-
              #   dnsServers = ... # Task #64 # <-
              # } # <-
              # enableAcceleratedNetworking = ... # Task #65 # <-
              # enableIPForwarding = ... # Task #66 # <-
              # networkSecurityGroup = { # Task #67 # <-
              #   id = ... # Task #67 # <-
              # } # <-
              # primary = ... # Task #68 # <-
              ipConfigurations = [ # <-
                # for ip_config in nic.ip_configuration : { # Task #69-86 # <-
                #   name = ... # Task #70 # <-
                #   properties = { # Task #71-86 # <-
                #     applicationGatewayBackendAddressPools = ... # Task #71 # <-
                #     applicationSecurityGroups = ... # Task #72 # <-
                #     loadBalancerBackendAddressPools = ... # Task #73 # <-
                #     primary = ... # Task #74 # <-
                #     subnet = { id = ... } # Task #75 # <-
                #     privateIPAddressVersion = ... # Task #76 # <-
                #     publicIPAddressConfiguration = { # Task #77-86 # <-
                #       name = ... # Task #78 # <-
                #       properties = { # Task #79-83 # <-
                #         domainNameLabel = ... # Task #79 # <-
                #         idleTimeoutInMinutes = ... # Task #80 # <-
                #         publicIPPrefix = { id = ... } # Task #81 # <-
                #       } # <-
                #       sku = { name = ... } # Task #82 # <-
                #       publicIPAddressVersion = ... # Task #83 # <-
                #       ipTags = [ # Task #84-86 # <-
                #         { tag = ..., ipTagType = ... } # Task #85, #86 # <-
                #       ] # <-
                #     } # <-
                #   } # <-
                # } # <-
              ] # <-
            } # <-
          ) # <-
        } # <-
      ] # <-
    } : {} # <-
  ) # <-
} : {}, # <-
```

## Create Phase Verification

### Query Create Method

Queried the Create method using `query_terraform_block_implementation_source_code` with `entrypoint_name=create`.

### Provider Code Evidence

```go
if v, ok := d.GetOk("network_interface"); ok {
    networkInterfaces, err := ExpandOrchestratedVirtualMachineScaleSetNetworkInterface(v.([]interface{}))
    if err != nil {
        return fmt.Errorf("expanding `network_interface`: %w", err)
    }

    networkProfile.NetworkInterfaceConfigurations = networkInterfaces
    virtualMachineProfile.NetworkProfile = networkProfile
}
```

### Pattern Identification

**Single-phase Create pattern** - Field is set directly in the props structure before `CreateOrUpdateThenPoll` call.

### Decision

Field belongs in **Create phase** → Added to `local.body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations`

## Assignment Path Verification

### Predicted Path

```
body
└── properties
    └── virtualMachineProfile
        └── networkProfile
            └── networkInterfaceConfigurations[]
```

### Provider Code Evidence

```go
// Create method
networkProfile := &virtualmachinescalesets.VirtualMachineScaleSetNetworkProfile{
    NetworkApiVersion: pointer.To((virtualmachinescalesets.NetworkApiVersion)(d.Get("network_api_version").(string))),
}

// Later in Create method
if v, ok := d.GetOk("network_interface"); ok {
    networkInterfaces, err := ExpandOrchestratedVirtualMachineScaleSetNetworkInterface(v.([]interface{}))
    if err != nil {
        return fmt.Errorf("expanding `network_interface`: %w", err)
    }

    networkProfile.NetworkInterfaceConfigurations = networkInterfaces
    virtualMachineProfile.NetworkProfile = networkProfile
}

// From expand function
func ExpandOrchestratedVirtualMachineScaleSetNetworkInterface(input []interface{}) (*[]virtualmachinescalesets.VirtualMachineScaleSetNetworkConfiguration, error) {
    output := make([]virtualmachinescalesets.VirtualMachineScaleSetNetworkConfiguration, 0)

    for _, v := range input {
        raw := v.(map[string]interface{})
        config := virtualmachinescalesets.VirtualMachineScaleSetNetworkConfiguration{
            Name: raw["name"].(string),
            Properties: &virtualmachinescalesets.VirtualMachineScaleSetNetworkConfigurationProperties{
                // ...
                IPConfigurations: ipConfigurations,
                Primary: pointer.To(raw["primary"].(bool)),
            },
        }
        output = append(output, config)
    }
    return &output, nil
}

// Assignment to virtual machine profile
props.Properties.VirtualMachineProfile = &virtualMachineProfile
```

### Verified Path

```
body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations
```

### Path Comparison

✅ **MATCH** - Predicted path matches the verified assignment path exactly.

## Provider Schema

From `OrchestratedVirtualMachineScaleSetNetworkInterfaceSchema()`:

```go
func OrchestratedVirtualMachineScaleSetNetworkInterfaceSchema() *pluginsdk.Schema {
    return &pluginsdk.Schema{
        Type:     pluginsdk.TypeList,
        Optional: true,
        Elem: &pluginsdk.Resource{
            Schema: map[string]*pluginsdk.Schema{
                "name": {
                    Type:         pluginsdk.TypeString,
                    Required:     true,
                    ForceNew:     true,
                    ValidateFunc: validation.StringIsNotEmpty,
                },

                "ip_configuration": orchestratedVirtualMachineScaleSetIPConfigurationSchema(),

                "auxiliary_mode": {
                    Type:     pluginsdk.TypeString,
                    Optional: true,
                    ValidateFunc: validation.StringInSlice([]string{
                        string(virtualmachinescalesets.NetworkInterfaceAuxiliaryModeAcceleratedConnections),
                        string(virtualmachinescalesets.NetworkInterfaceAuxiliaryModeFloating),
                    }, false),
                },

                "auxiliary_sku": {
                    Type:     pluginsdk.TypeString,
                    Optional: true,
                    ValidateFunc: validation.StringInSlice([]string{
                        string(virtualmachinescalesets.NetworkInterfaceAuxiliarySkuAEight),
                        string(virtualmachinescalesets.NetworkInterfaceAuxiliarySkuAFour),
                        string(virtualmachinescalesets.NetworkInterfaceAuxiliarySkuAOne),
                        string(virtualmachinescalesets.NetworkInterfaceAuxiliarySkuATwo),
                    }, false),
                },

                "dns_servers": {
                    Type:     pluginsdk.TypeList,
                    Optional: true,
                    Elem: &pluginsdk.Schema{
                        Type:         pluginsdk.TypeString,
                        ValidateFunc: validation.StringIsNotEmpty,
                    },
                },

                "enable_accelerated_networking": {
                    Type:     pluginsdk.TypeBool,
                    Optional: true,
                    Default:  false,
                },

                "enable_ip_forwarding": {
                    Type:     pluginsdk.TypeBool,
                    Optional: true,
                    Default:  false,
                },

                "network_security_group_id": {
                    Type:         pluginsdk.TypeString,
                    Optional:     true,
                    ValidateFunc: networksecuritygroups.ValidateNetworkSecurityGroupID,
                },

                "primary": {
                    Type:     pluginsdk.TypeBool,
                    Optional: true,
                    Default:  false,
                },
            },
        },
    }
}
```

**Block Type:** `TypeList` (Optional)

**Child Fields:**
- `name` (String, Required, ForceNew) - Task #61
- `ip_configuration` (Block, Required) - Task #69-86
- `auxiliary_mode` (String, Optional) - Task #62
- `auxiliary_sku` (String, Optional) - Task #63
- `dns_servers` (List(String), Optional) - Task #64
- `enable_accelerated_networking` (Bool, Optional, Default: false) - Task #65
- `enable_ip_forwarding` (Bool, Optional, Default: false) - Task #66
- `network_security_group_id` (String, Optional) - Task #67
- `primary` (Bool, Optional, Default: false) - Task #68

## Azure API Schema

Query: `body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations`

Result (formatted):
```
List(Object{
  name: String
  properties: Object{
    auxiliaryMode: String (optional)
    auxiliarySku: String (optional)
    deleteOption: String (optional)
    disableTcpStateTracking: Bool (optional)
    dnsSettings: Object{
      dnsServers: List(String) (optional)
    } (optional)
    enableAcceleratedNetworking: Bool (optional)
    enableFpga: Bool (optional)
    enableIPForwarding: Bool (optional)
    ipConfigurations: List(Object{...}) (required in properties)
    networkSecurityGroup: Object{
      id: String
    } (optional)
    primary: Bool (optional)
  }
})
```

## Hidden Fields Check

### Expand Function Analysis

Queried `ExpandOrchestratedVirtualMachineScaleSetNetworkInterface`:

```go
func ExpandOrchestratedVirtualMachineScaleSetNetworkInterface(input []interface{}) (*[]virtualmachinescalesets.VirtualMachineScaleSetNetworkConfiguration, error) {
    output := make([]virtualmachinescalesets.VirtualMachineScaleSetNetworkConfiguration, 0)

    for _, v := range input {
        raw := v.(map[string]interface{})

        dnsServers := utils.ExpandStringSlice(raw["dns_servers"].([]interface{}))

        ipConfigurations := make([]virtualmachinescalesets.VirtualMachineScaleSetIPConfiguration, 0)
        ipConfigurationsRaw := raw["ip_configuration"].([]interface{})
        for _, configV := range ipConfigurationsRaw {
            configRaw := configV.(map[string]interface{})
            ipConfiguration, err := expandOrchestratedVirtualMachineScaleSetIPConfiguration(configRaw)
            if err != nil {
                return nil, err
            }

            ipConfigurations = append(ipConfigurations, *ipConfiguration)
        }

        config := virtualmachinescalesets.VirtualMachineScaleSetNetworkConfiguration{
            Name: raw["name"].(string),
            Properties: &virtualmachinescalesets.VirtualMachineScaleSetNetworkConfigurationProperties{
                DnsSettings: &virtualmachinescalesets.VirtualMachineScaleSetNetworkConfigurationDnsSettings{
                    DnsServers: dnsServers,
                },
                EnableAcceleratedNetworking: pointer.To(raw["enable_accelerated_networking"].(bool)),
                EnableIPForwarding:          pointer.To(raw["enable_ip_forwarding"].(bool)),
                IPConfigurations:            ipConfigurations,
                Primary:                     pointer.To(raw["primary"].(bool)),
            },
        }

        if auxiliaryMode := raw["auxiliary_mode"].(string); auxiliaryMode != "" {
            config.Properties.AuxiliaryMode = pointer.To(virtualmachinescalesets.NetworkInterfaceAuxiliaryMode(auxiliaryMode))
        }

        if auxiliarySku := raw["auxiliary_sku"].(string); auxiliarySku != "" {
            config.Properties.AuxiliarySku = pointer.To(virtualmachinescalesets.NetworkInterfaceAuxiliarySku(auxiliarySku))
        }

        if nsgId := raw["network_security_group_id"].(string); nsgId != "" {
            config.Properties.NetworkSecurityGroup = &virtualmachinescalesets.SubResource{
                Id: pointer.To(nsgId),
            }
        }

        output = append(output, config)
    }

    return &output, nil
}
```

### Hidden Fields Result

**NO HIDDEN FIELDS FOUND** - The expand function only uses fields that are explicitly defined in the schema:
- `name` (from schema)
- `dns_servers` (from schema)
- `enable_accelerated_networking` (from schema)
- `enable_ip_forwarding` (from schema)
- `ip_configuration` (from schema - expanded separately)
- `primary` (from schema)
- `auxiliary_mode` (from schema - conditional)
- `auxiliary_sku` (from schema - conditional)
- `network_security_group_id` (from schema - conditional)

All fields are user-provided from the Terraform configuration. No hardcoded values or computed fields are added by the provider.

## Mapping

| Terraform Field | Azure API Field | Task # |
|----------------|----------------|--------|
| `network_interface` | `networkInterfaceConfigurations` | #60 |
| `network_interface[].name` | `networkInterfaceConfigurations[].name` | #61 |
| `network_interface[].auxiliary_mode` | `networkInterfaceConfigurations[].properties.auxiliaryMode` | #62 |
| `network_interface[].auxiliary_sku` | `networkInterfaceConfigurations[].properties.auxiliarySku` | #63 |
| `network_interface[].dns_servers` | `networkInterfaceConfigurations[].properties.dnsSettings.dnsServers` | #64 |
| `network_interface[].enable_accelerated_networking` | `networkInterfaceConfigurations[].properties.enableAcceleratedNetworking` | #65 |
| `network_interface[].enable_ip_forwarding` | `networkInterfaceConfigurations[].properties.enableIPForwarding` | #66 |
| `network_interface[].network_security_group_id` | `networkInterfaceConfigurations[].properties.networkSecurityGroup.id` | #67 |
| `network_interface[].primary` | `networkInterfaceConfigurations[].properties.primary` | #68 |
| `network_interface[].ip_configuration` | `networkInterfaceConfigurations[].properties.ipConfigurations` | #69-86 |

## Special Handling

### Block Structure

**Structure Type:** Type 3 - Block Structure Skeleton

This is a structure skeleton task that creates the framework for the `network_interface` block without implementing individual arguments. Child tasks (#61-#86) will replace comment placeholders with actual implementations.

### Integration with Network API Version

The skeleton properly integrates with the existing `network_api_version` field by:
1. Using conditional check for both `network_api_version` and `network_interface`
2. Merging both configurations into a single `networkProfile` object
3. Preserving the existing `networkApiVersion` functionality

### Iteration Pattern

The skeleton uses Terraform's `for` expression to iterate over the list of network interfaces:
```hcl
for nic in var.orchestrated_virtual_machine_scale_set_network_interface : {
  name = nic.name
  properties = merge(...)
}
```

This pattern allows multiple network interfaces to be defined, matching the provider's `TypeList` schema.

### Placeholder Organization

Comment placeholders are organized by:
- Root-level network_interface fields (Tasks #61-#68)
- Nested ip_configuration block structure (Tasks #69-86)
- Further nested blocks within ip_configuration (public_ip_address, ip_tag)

## Critical Review & Edge Case Analysis

### Null Semantics

**Block-level null handling:**
- When `var.orchestrated_virtual_machine_scale_set_network_interface` is `null`, the entire `networkInterfaceConfigurations` key is omitted from the merge
- This matches provider behavior where network_interface is Optional

**Integration with network_api_version:**
- The outer conditional checks `network_api_version != null || network_interface != null`
- This ensures `networkProfile` is created when either field is set
- When only `network_api_version` is set, `networkInterfaceConfigurations` is omitted
- When only `network_interface` is set, `networkApiVersion` is omitted
- When both are set, both are included in the merged object

### Boundary Conditions

**Empty list scenario:**
- If `network_interface = []` (empty list), the `for` expression produces an empty array
- This is valid Azure API input and matches provider behavior

**Single vs. multiple interfaces:**
- The `for` expression handles both single and multiple network interface definitions
- No special handling needed for array size

### Idempotency

**Stable structure:**
- The skeleton uses a `for` expression that maintains order of network interfaces
- Each network interface is identified by its `name` field (ForceNew in schema)
- Repeated applies with same inputs produce identical output

**Merge safety:**
- Using `merge()` at the `networkProfile` level safely combines `networkApiVersion` and `networkInterfaceConfigurations`
- No risk of key collision between these two fields

### Safe References

**Variable access:**
- All variable accesses use safe null checks with conditional operators (`!= null`)
- The `for` expression only executes when `network_interface != null`
- Child field access (`nic.name`) is safe because we've already verified the parent is not null

**Nested structure:**
- The skeleton properly nests `networkInterfaceConfigurations` within `networkProfile`
- The merge pattern ensures `networkProfile` is only created when needed

### Edge Cases

1. **Both network_api_version and network_interface are null:**
   - Outer conditional evaluates to `false`
   - Entire `networkProfile` block is replaced with `{}`
   - ✅ Correct: No networkProfile in output

2. **Only network_api_version is set:**
   - Outer conditional evaluates to `true`
   - Inner conditional for `network_interface` evaluates to `false`
   - Result: `networkProfile = { networkApiVersion = "..." }`
   - ✅ Correct: Matches existing behavior

3. **Only network_interface is set:**
   - Outer conditional evaluates to `true`
   - Inner conditional for `network_api_version` evaluates to `false`
   - Result: `networkProfile = { networkInterfaceConfigurations = [...] }`
   - ✅ Correct: Network profile without API version

4. **Both are set:**
   - Both inner conditionals evaluate to `true`
   - Result: `networkProfile = { networkApiVersion = "...", networkInterfaceConfigurations = [...] }`
   - ✅ Correct: Both fields present

5. **Empty network_interface list:**
   - `for` expression produces `[]`
   - Result: `networkInterfaceConfigurations = []`
   - ✅ Correct: Valid API input

## Child Tasks Ready for Delegation

Based on the structure skeleton created, the following child tasks are now ready for implementation by other executor agents:

### Root-Level Network Interface Fields (Direct Children)
- **Task #61**: `network_interface[].name` - Required, String, ForceNew
- **Task #62**: `network_interface[].auxiliary_mode` - Optional, String
- **Task #63**: `network_interface[].auxiliary_sku` - Optional, String
- **Task #64**: `network_interface[].dns_servers` - Optional, List(String)
- **Task #65**: `network_interface[].enable_accelerated_networking` - Optional, Bool, Default: false
- **Task #66**: `network_interface[].enable_ip_forwarding` - Optional, Bool, Default: false
- **Task #67**: `network_interface[].network_security_group_id` - Optional, String
- **Task #68**: `network_interface[].primary` - Optional, Bool, Default: false

### Nested ip_configuration Block
- **Task #69**: `network_interface[].ip_configuration` - Block structure skeleton (Type 3)

After Task #69 completes the ip_configuration block skeleton, the following tasks will become ready:
- **Task #70**: `ip_configuration[].name` - Required, String
- **Task #71**: `ip_configuration[].application_gateway_backend_address_pool_ids` - Optional
- **Task #72**: `ip_configuration[].application_security_group_ids` - Optional
- **Task #73**: `ip_configuration[].load_balancer_backend_address_pool_ids` - Optional
- **Task #74**: `ip_configuration[].primary` - Optional, Bool
- **Task #75**: `ip_configuration[].subnet_id` - Optional, String
- **Task #76**: `ip_configuration[].version` - Optional, String
- **Task #77**: `ip_configuration[].public_ip_address` - Block structure skeleton (Type 3)

After Task #77 completes, these tasks become ready:
- **Task #78**: `public_ip_address[].name` - Required, String
- **Task #79**: `public_ip_address[].domain_name_label` - Optional, String
- **Task #80**: `public_ip_address[].idle_timeout_in_minutes` - Optional, Int
- **Task #81**: `public_ip_address[].public_ip_prefix_id` - Optional, String
- **Task #82**: `public_ip_address[].sku_name` - Optional, String
- **Task #83**: `public_ip_address[].version` - Optional, String
- **Task #84**: `public_ip_address[].ip_tag` - Block structure skeleton (Type 3)

After Task #84 completes, these tasks become ready:
- **Task #85**: `ip_tag[].tag` - Required, String
- **Task #86**: `ip_tag[].type` - Required, String

### Summary of Immediately Ready Tasks

The following **8 tasks** are now immediately ready for delegation (no dependencies):
1. Task #61 - name
2. Task #62 - auxiliary_mode
3. Task #63 - auxiliary_sku
4. Task #64 - dns_servers
5. Task #65 - enable_accelerated_networking
6. Task #66 - enable_ip_forwarding
7. Task #67 - network_security_group_id
8. Task #68 - primary

**Plus 1 structure skeleton task:**
- Task #69 - ip_configuration block skeleton

## Checklist

- ✅ Structure skeleton created with conditional rendering
- ✅ Integrated with existing network_api_version using merge
- ✅ Comment placeholders added for all child tasks (#61-#86)
- ✅ for expression pattern used for list iteration
- ✅ No hidden fields found in expand function
- ✅ Create phase verified (single-phase pattern)
- ✅ Assignment path verified and matches prediction
- ✅ Null semantics analyzed (block omitted when null)
- ✅ Edge cases covered (empty list, single/multiple interfaces, both/neither fields set)
- ✅ Idempotency verified (stable iteration order)
- ✅ Safe references verified (null checks in place)
- ✅ Child tasks documented with dependencies
- ✅ Proof document created with all required sections
- ✅ Self-review completed: Only skeleton created, no individual argument implementations

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-04
**Task:** #60 - network_interface

### Validation Results

✅ **Task Type:** Type 3 - Block Structure Skeleton correctly implemented
✅ **Create Phase:** Field correctly placed in `local.body.properties.virtualMachineProfile.networkProfile`
✅ **Assignment Path:** Verified path matches provider code exactly: `body.properties.virtualMachineProfile.networkProfile.networkInterfaceConfigurations`
✅ **Skeleton Structure:** Proper conditional rendering with merge logic integrating with existing `network_api_version`
✅ **Iteration Pattern:** Correct `for` expression over network_interface list
✅ **Placeholders:** All child tasks (#61-#86) have proper comment placeholders with task references
✅ **No Hidden Fields:** Verified through expand function analysis - no hardcoded or computed fields added
✅ **Null Handling:** Correctly omits block when null, properly merges when present
✅ **Edge Cases:** Comprehensive analysis covers empty list, null scenarios, integration with network_api_version
✅ **Integration:** Properly merges with existing `network_api_version` field using conditional merge pattern
✅ **Scope Compliance:** Only skeleton structure created; no individual argument implementations (correct for Type 3)

### Compliance Statement

This implementation EXACTLY follows executor.md requirements for Type 3 (Block Structure Skeleton) tasks:
1. ✅ Creates conditional skeleton with proper null handling
2. ✅ Integrates with existing fields using merge pattern
3. ✅ Adds comment placeholders for all child tasks (#61-#86)
4. ✅ Uses proper iteration pattern (`for` expression)
5. ✅ Verifies no hidden fields exist in provider expand function
6. ✅ Provides comprehensive edge case analysis
7. ✅ Maintains scope discipline (skeleton only, no argument logic)

The skeleton properly sets up the framework for 27 child tasks to implement individual fields and nested blocks. The integration with `network_api_version` ensures both fields can coexist in the same `networkProfile` object.

**Status:** APPROVED ✅

---
