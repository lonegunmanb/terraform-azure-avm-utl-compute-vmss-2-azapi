# Task #106 - os_profile.linux_configuration.admin_ssh_key - STRUCTURE SKELETON

## Summary

Created structure skeleton for the `admin_ssh_key` block within `os_profile.linux_configuration`. This block is a set of SSH key objects that will configure SSH authentication for Linux VMSS instances. Comment placeholders added for child tasks #107-108 to implement individual fields.

## Shadow Implementation

```hcl
locals {
  body = {
    properties = merge(
      var.orchestrated_virtual_machine_scale_set_os_profile != null ? {
        osProfile = merge(
          var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration != null ? merge(
            {
              linuxConfiguration = merge(
                {
                  adminUsername                 = var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.admin_username
                  disablePasswordAuthentication = var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.disable_password_authentication
                  provisionVMAgent              = coalesce(var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.provision_vm_agent, true)
                },
                var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.admin_ssh_key != null && length(var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.admin_ssh_key) > 0 ? { # <-
                  ssh = { # <-
                    publicKeys = [ # <-
                      for ssh_key in var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.admin_ssh_key : { # <-
                        # keyData = ... # Task #107 # <-
                        # path = ... # Task #107 (computed from username) # <-
                      } # <-
                    ] # <-
                  } # <-
                } : {}, # <-
                {
                  # secrets = ... # Task #109-112
                },
                {
                  patchSettings = {
                    assessmentMode = var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.patch_assessment_mode
                    patchMode      = var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.patch_mode
                  }
                }
              )
            }
          ) : {}
        )
      } : {}
    )
  }
}
```

## Create Phase Verification

**Query Result:**
```go
func expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration(input map[string]interface{}, customData string) *virtualmachinescalesets.VirtualMachineScaleSetOSProfile {
	osProfile := virtualmachinescalesets.VirtualMachineScaleSetOSProfile{}
	linConfig := virtualmachinescalesets.LinuxConfiguration{}
	patchSettings := virtualmachinescalesets.LinuxPatchSettings{}

	if len(input) > 0 {
		osProfile.CustomData = pointer.To(customData)
		osProfile.AdminUsername = pointer.To(input["admin_username"].(string))

		if adminPassword := input["admin_password"].(string); adminPassword != "" {
			osProfile.AdminPassword = pointer.To(adminPassword)
		}

		if computerPrefix := input["computer_name_prefix"].(string); computerPrefix != "" {
			osProfile.ComputerNamePrefix = pointer.To(computerPrefix)
		}

		if secrets := input["secret"].([]interface{}); len(secrets) > 0 {
			osProfile.Secrets = expandLinuxSecretsVMSS(secrets)
		}

		if sshPublicKeys := expandSSHKeysVMSS(input["admin_ssh_key"].(*pluginsdk.Set).List()); len(sshPublicKeys) > 0 {
			if linConfig.Ssh == nil {
				linConfig.Ssh = &virtualmachinescalesets.SshConfiguration{}
			}
			linConfig.Ssh.PublicKeys = &sshPublicKeys
		}

		linConfig.DisablePasswordAuthentication = pointer.To(input["disable_password_authentication"].(bool))
		linConfig.ProvisionVMAgent = pointer.To(input["provision_vm_agent"].(bool))

		// Automatic VM Guest Patching
		patchSettings.AssessmentMode = pointer.To(virtualmachinescalesets.LinuxPatchAssessmentMode(input["patch_assessment_mode"].(string)))
		patchSettings.PatchMode = pointer.To(virtualmachinescalesets.LinuxVMGuestPatchMode(input["patch_mode"].(string)))
		linConfig.PatchSettings = &patchSettings
	}

	osProfile.LinuxConfiguration = &linConfig

	return &osProfile
}
```

**Pattern Identification:** Single-phase create pattern - all fields set in Create phase via `expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration`.

**Field Classification:** Create phase - the `admin_ssh_key` set is processed in the Create phase at line:
```go
if sshPublicKeys := expandSSHKeysVMSS(input["admin_ssh_key"].(*pluginsdk.Set).List()); len(sshPublicKeys) > 0 {
    if linConfig.Ssh == nil {
        linConfig.Ssh = &virtualmachinescalesets.SshConfiguration{}
    }
    linConfig.Ssh.PublicKeys = &sshPublicKeys
}
```

**Decision:** Block skeleton belongs in `local.body` (Create phase).

## Assignment Path Verification

**Predicted Path:** `properties.virtualMachineProfile.osProfile.linuxConfiguration.ssh.publicKeys`

**Go Code Evidence:**

From Create method:
```go
props := virtualmachinescalesets.VirtualMachineScaleSet{
    Location: location.Normalize(d.Get("location").(string)),
    Properties: &virtualmachinescalesets.VirtualMachineScaleSetProperties{
        OrchestrationMode: pointer.To(virtualmachinescalesets.OrchestrationModeFlexible),
        // ...
        VirtualMachineProfile: expandOrchestratedVirtualMachineScaleSetVirtualMachineProfile(d, hashedEncryptionAtHost),
    },
}
```

From `expandOrchestratedVirtualMachineScaleSetVirtualMachineProfile`:
```go
profile.OsProfile = expandOrchestratedVirtualMachineScaleSetOsProfile(d)
```

From `expandOrchestratedVirtualMachineScaleSetOsProfile`:
```go
if linConfigRaw := osProfileRaw["linux_configuration"].([]interface{}); len(linConfigRaw) > 0 {
    linConfig := linConfigRaw[0].(map[string]interface{})
    return expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration(linConfig, customData)
}
```

From `expandOrchestratedVirtualMachineScaleSetOsProfileWithLinuxConfiguration`:
```go
osProfile := virtualmachinescalesets.VirtualMachineScaleSetOSProfile{}
linConfig := virtualmachinescalesets.LinuxConfiguration{}

if sshPublicKeys := expandSSHKeysVMSS(input["admin_ssh_key"].(*pluginsdk.Set).List()); len(sshPublicKeys) > 0 {
    if linConfig.Ssh == nil {
        linConfig.Ssh = &virtualmachinescalesets.SshConfiguration{}
    }
    linConfig.Ssh.PublicKeys = &sshPublicKeys
}

osProfile.LinuxConfiguration = &linConfig
```

Assignment chain:
1. `props.Properties = &VirtualMachineScaleSetProperties{ ... }` (adds `properties`)
2. `properties.VirtualMachineProfile = profile` (adds `virtualMachineProfile`)
3. `profile.OsProfile = osProfile` (adds `osProfile`)
4. `osProfile.LinuxConfiguration = &linConfig` (adds `linuxConfiguration`)
5. `linConfig.Ssh = &SshConfiguration{ PublicKeys: &sshPublicKeys }` (adds `ssh.publicKeys`)

**Verified Path:** `properties.virtualMachineProfile.osProfile.linuxConfiguration.ssh.publicKeys`

**Path Comparison:** ✅ Matches predicted path.

## Provider Schema

From `orchestrated_virtual_machine_scale_set.go`:

```go
func OrchestratedVirtualMachineScaleSetLinuxConfigurationSchema() *pluginsdk.Schema {
	return &pluginsdk.Schema{
		Type:     pluginsdk.TypeList,
		Optional: true,
		MaxItems: 1,
		Elem: &pluginsdk.Resource{
			Schema: map[string]*pluginsdk.Schema{
				"admin_username": {
					Type:         pluginsdk.TypeString,
					Required:     true,
					ForceNew:     true,
					ValidateFunc: validateAdminUsernameLinux,
				},

				"admin_password": {
					Type:             pluginsdk.TypeString,
					Optional:         true,
					ForceNew:         true,
					Sensitive:        true,
					DiffSuppressFunc: adminPasswordDiffSuppressFunc,
					ValidateFunc:     validatePasswordComplexityLinux,
				},

				"admin_ssh_key":        SSHKeysSchema(false),  // <-- Block definition
				"computer_name_prefix": computerPrefixLinuxSchema(),

				"disable_password_authentication": {
					Type:     pluginsdk.TypeBool,
					Optional: true,
					Default:  true,
				},

				"provision_vm_agent": {
					Type:     pluginsdk.TypeBool,
					Optional: true,
					Default:  true,
					ForceNew: true,
				},

				"patch_assessment_mode": {
					Type:     pluginsdk.TypeString,
					Optional: true,
					Default:  string(virtualmachinescalesets.LinuxPatchAssessmentModeImageDefault),
					ValidateFunc: validation.StringInSlice([]string{
						string(virtualmachinescalesets.LinuxPatchAssessmentModeAutomaticByPlatform),
						string(virtualmachinescalesets.LinuxPatchAssessmentModeImageDefault),
					}, false),
				},

				"patch_mode": {
					Type:     pluginsdk.TypeString,
					Optional: true,
					Default:  string(virtualmachinescalesets.LinuxVMGuestPatchModeImageDefault),
					ValidateFunc: validation.StringInSlice([]string{
						string(virtualmachinescalesets.LinuxVMGuestPatchModeImageDefault),
						string(virtualmachinescalesets.LinuxVMGuestPatchModeAutomaticByPlatform),
					}, false),
				},

				"secret": linuxSecretSchema(),
			},
		},
	}
}
```

From `ssh_keys.go`:

```go
func SSHKeysSchema(isVirtualMachine bool) *pluginsdk.Schema {
	// the SSH Keys for a Virtual Machine cannot be changed once provisioned:
	// Code="PropertyChangeNotAllowed" Message="Changing property 'linuxConfiguration.ssh.publicKeys' is not allowed."

	return &pluginsdk.Schema{
		Type:     pluginsdk.TypeSet,
		Optional: true,
		ForceNew: isVirtualMachine,  // false for VMSS
		Set:      SSHKeySchemaHash,
		Elem: &pluginsdk.Resource{
			Schema: map[string]*pluginsdk.Schema{
				"public_key": {
					Type:             pluginsdk.TypeString,
					Required:         true,
					ForceNew:         isVirtualMachine,  // false for VMSS
					ValidateFunc:     validate.SSHKey,
					DiffSuppressFunc: suppress.SSHKey,
				},

				"username": {
					Type:         pluginsdk.TypeString,
					Required:     true,
					ForceNew:     isVirtualMachine,  // false for VMSS
					ValidateFunc: validation.StringIsNotEmpty,
				},
			},
		},
	}
}
```

**Key Findings:**
- **Type:** `TypeSet` (set of objects)
- **Optional:** true
- **ForceNew:** false (for VMSS - `isVirtualMachine` parameter is false)
- **Fields:** 
  - `public_key`: Required, ForceNew=false for VMSS
  - `username`: Required, ForceNew=false for VMSS

## Azure API Schema

Queried path: `properties.virtualMachineProfile.osProfile.linuxConfiguration.ssh.publicKeys`

**Result:**
```
Array of SSH public keys used to authenticate with linux based VMs.
Type: array
Items: {
  "keyData": "SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in Azure]https://docs.microsoft.com/azure/virtual-machines/linux/create-ssh-keys-detailed).",
  "path": "Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys"
}
```

**Schema Summary:**
- Array of objects with `keyData` (string) and `path` (string) properties
- Path is computed based on username: `/home/{username}/.ssh/authorized_keys`

## Hidden Fields

**Expand Function Analysis:**

From `expandSSHKeysVMSS`:
```go
func expandSSHKeysVMSS(input []interface{}) []virtualmachinescalesets.SshPublicKey {
	output := make([]virtualmachinescalesets.SshPublicKey, 0)

	for _, v := range input {
		raw := v.(map[string]interface{})

		username := raw["username"].(string)
		output = append(output, virtualmachinescalesets.SshPublicKey{
			KeyData: pointer.To(raw["public_key"].(string)),
			Path:    pointer.To(formatUsernameForAuthorizedKeysPath(username)),
		})
	}

	return output
}

func formatUsernameForAuthorizedKeysPath(username string) string {
	return fmt.Sprintf("/home/%s/.ssh/authorized_keys", username)
}
```

**Hidden Field Discovered:**
- **`path`**: Not exposed in Terraform schema, but computed in expand function from `username`
  - Formula: `/home/{username}/.ssh/authorized_keys`
  - This is a standard Linux convention for SSH authorized keys
  - Will be implemented in Task #107 (child task for individual fields)

**No hidden fields in the block structure itself** - the `ssh` wrapper and `publicKeys` array are standard Azure API fields visible in the schema.

## Mapping

**Terraform (snake_case) → Azure API (camelCase):**
- `admin_ssh_key` → `ssh.publicKeys` (structure transformation + array)
- Block is wrapped in `ssh` object with `publicKeys` array

The block itself doesn't have a direct 1:1 mapping - it's transformed:
- Input: Set of objects `{public_key, username}`
- Output: Array nested in `ssh.publicKeys` with computed `path` field

## Special Handling

### Block Structure Only (Type 3 Task)

This is a **Type 3: Block Structure Skeleton** task:
- ✅ Created conditional block skeleton with `for` loop
- ✅ Added comment placeholders for child tasks (#107-108)
- ✅ Identified hidden field (`path`) to be implemented by child task
- ❌ NO field implementations - those belong to child tasks

### Conditional Logic

The SSH configuration block is conditionally included only when:
```hcl
var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.admin_ssh_key != null && 
length(var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.admin_ssh_key) > 0
```

This matches provider behavior:
```go
if sshPublicKeys := expandSSHKeysVMSS(input["admin_ssh_key"].(*pluginsdk.Set).List()); len(sshPublicKeys) > 0 {
    if linConfig.Ssh == nil {
        linConfig.Ssh = &virtualmachinescalesets.SshConfiguration{}
    }
    linConfig.Ssh.PublicKeys = &sshPublicKeys
}
```

### ForceNew Handling

**NOT applicable for this block:**
- The block itself has `ForceNew: false` for VMSS
- Child fields also have `ForceNew: false` for VMSS
- No `replace_triggers_external_values` needed

This differs from Virtual Machines where SSH keys are ForceNew, but VMSS allows updates.

### Iteration Pattern

Used `for` expression to iterate over the set:
```hcl
for ssh_key in var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.admin_ssh_key : {
  # Individual key fields - Task #107-108
}
```

This matches the expand function's iteration pattern.

## Child Tasks Ready for Delegation

The following child tasks are now **ready to be delegated** as the parent skeleton exists:

### Task #107: os_profile.linux_configuration.admin_ssh_key.public_key
- **Type:** Block Argument (Type 4)
- **Required:** Yes
- **Description:** Implement `public_key` field mapping to `keyData` in Azure API
- **DiffSuppressFunc:** Has `suppress.SSHKey` - normalize SSH key format
- **ValidateFunc:** Has `validate.SSHKey` - validate SSH key format
- **Placeholder Location:** Line 399 in migrate_main.tf

### Task #108: os_profile.linux_configuration.admin_ssh_key.username
- **Type:** Block Argument (Type 4)
- **Required:** Yes
- **Description:** Implement `username` field and compute `path` hidden field
- **Hidden Field:** Must compute `path` = `/home/{username}/.ssh/authorized_keys`
- **ValidateFunc:** Has `validation.StringIsNotEmpty`
- **Placeholder Location:** Line 400 in migrate_main.tf (for path computation)

**Note:** Both tasks should be implemented together as the `path` field depends on `username`.

## Critical Review & Edge Case Analysis

### Null Semantics
- **Empty set:** When `admin_ssh_key` is null or empty set, the entire `ssh` configuration block is omitted (not set to empty array)
- **Matches provider:** Conditional check ensures empty sets don't create empty `ssh` blocks

### Edge Cases

1. **Empty Set vs Null:**
   - Handled by: `admin_ssh_key != null && length(admin_ssh_key) > 0`
   - Prevents creating `ssh` block with empty `publicKeys` array

2. **Set Iteration:**
   - Sets have no guaranteed order in Terraform
   - Provider uses `TypeSet` with custom hash function (`SSHKeySchemaHash`)
   - Order doesn't matter for SSH keys - all are valid authentication methods

3. **Multiple Keys for Same User:**
   - Allowed by schema - each key entry can have same username
   - Each creates separate entry in `publicKeys` array
   - All keys for a user go to same `/home/{user}/.ssh/authorized_keys` file (Azure handles appending)

4. **Username Validation:**
   - Provider validates username in parent field (`admin_username`)
   - SSH key username should match `admin_username` (documented convention)
   - No cross-field validation in provider - user responsibility

### Idempotency

- **Set ordering:** Terraform sets are unordered, converted to array for API
- **Hash function:** Provider uses `SSHKeySchemaHash` for set membership
- **Safe:** Same set of keys always produces consistent API payload

### Safe References

All references check parent existence:
```hcl
var.orchestrated_virtual_machine_scale_set_os_profile.linux_configuration.admin_ssh_key != null && 
length(...) > 0
```

Prevents null reference errors when parent blocks don't exist.

## Checklist

- ✅ Block skeleton created in correct local (`local.body`)
- ✅ Conditional logic matches provider behavior
- ✅ ForceNew handling: Not applicable (no ForceNew for VMSS)
- ✅ Hidden fields identified (path computation)
- ✅ Validation: Will be implemented by child tasks (#107-108)
- ✅ Edge case analysis completed
- ✅ Child tasks identified and ready (#107-108)
- ✅ Comment placeholders added for child tasks
- ✅ Proof document created
- ✅ Track.md will be updated to Pending for check
- ✅ Self-review: Only skeleton created, no individual field logic added

## Track.md Update

Task #106 status will be updated to "Pending for check" after proof document submission.

Child tasks #107-108 are now ready to be assigned to executor agents.

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #106 - os_profile.linux_configuration.admin_ssh_key

### Validation Results

✅ **Task Type:** Correctly identified and executed as Type 3 (Block Structure Skeleton)
✅ **Schema Investigation:** Complete - queried resource function, expand function, and identified hidden field (`path`)
✅ **Create Phase Verification:** Correctly identified single-phase create pattern, field placed in `local.body`
✅ **Assignment Path Verification:** Correctly traced through all struct assignments to `properties.virtualMachineProfile.osProfile.linuxConfiguration.ssh.publicKeys`
✅ **Conditional Logic:** Matches provider behavior exactly - checks both null and length > 0
✅ **Iteration Pattern:** Correct `for` expression over set matching provider's iteration
✅ **ForceNew Logic:** Correctly identified `ForceNew: false` for VMSS - no replace triggers needed
✅ **Hidden Fields:** Identified `path` field computation, properly delegated to child Task #107
✅ **Stable Keys:** Not applicable - no conditional keys in replace_triggers_external_values
✅ **Shared Path Merge:** Correct nested merge structure within linuxConfiguration
✅ **Phase Detection:** Field correctly placed in Create phase (`local.body`)
✅ **Type Conversion:** Set iteration pattern correctly implemented
✅ **Null Handling:** Correctly propagates null semantics - omits entire ssh block when empty/null
✅ **Validations:** Block-level validations N/A, child field validations delegated to Tasks #107-108
✅ **Deferred Work Completion:** No deferred work for this task in following.md
✅ **Edge Cases:** All edge cases properly analyzed (empty sets, set ordering, multiple keys per user)
✅ **Proof Document:** No forbidden phrases, exact provider behavior replication documented
✅ **Self-Review:** Only skeleton created, no field implementations added, correct scope adherence

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The block structure skeleton correctly:
- Conditionally includes the `ssh` configuration block only when the set is non-empty
- Uses proper iteration pattern over the set matching provider's expand function
- Identifies the hidden `path` field for child task implementation
- Places placeholders for child tasks #107-108 to implement individual fields
- Maintains correct Azure API nesting structure

No deviations, simplifications, or "safer alternatives" were found. The implementation is a precise skeleton following Type 3 task requirements.

**Status:** APPROVED ✅

---
