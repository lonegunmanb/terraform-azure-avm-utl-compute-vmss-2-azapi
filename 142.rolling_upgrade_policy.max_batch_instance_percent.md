# Task #142: rolling_upgrade_policy.max_batch_instance_percent

## Summary
Implemented `rolling_upgrade_policy.max_batch_instance_percent` as a required integer field that sets the maximum percentage of instances to upgrade in parallel during rolling upgrades. Direct field assignment in Create phase.

## Shadow Implementation

```hcl
# migrate_main.tf
locals {
  body = merge(
    {
      properties = merge(
        var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy != null ? {
          upgradePolicy = {
            rollingUpgradePolicy = {
              maxBatchInstancePercent = var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy.max_batch_instance_percent # <-
            }
          }
        } : {},
      )
    }
  )
}
```

## Create Phase Verification

**Pattern**: Single-phase Create

**Query**: `query_terraform_block_implementation_source_code(entrypoint_name="create")`

**Evidence**:
```go
func resourceOrchestratedVirtualMachineScaleSetCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	// ...
	upgradeMode := virtualmachinescalesets.UpgradeMode(d.Get("upgrade_mode").(string))
	rollingUpgradePolicy, err := ExpandVirtualMachineScaleSetRollingUpgradePolicy(d.Get("rolling_upgrade_policy").([]interface{}), len(zones) > 0, false)
	if err != nil {
		return fmt.Errorf("expanding `rolling_upgrade_policy`: %w", err)
	}

	props.Properties.UpgradePolicy = &virtualmachinescalesets.UpgradePolicy{
		Mode:                 pointer.To(upgradeMode),
		RollingUpgradePolicy: rollingUpgradePolicy,
	}
	// ...
	if err := client.CreateOrUpdateThenPoll(ctx, id, props, virtualmachinescalesets.DefaultCreateOrUpdateOperationOptions()); err != nil {
		return fmt.Errorf("creating Orchestrated %s: %w", id, err)
	}
}
```

**Classification**: Create phase - field is set before CreateOrUpdateThenPoll

**Decision**: Implement in `local.body` (Create phase)

## Assignment Path Verification

**Predicted Path**: `properties.upgradePolicy.rollingUpgradePolicy.maxBatchInstancePercent`

**Tracing**:
1. `props` is type `virtualmachinescalesets.VirtualMachineScaleSet`
2. `props.Properties` is assigned to `&virtualmachinescalesets.VirtualMachineScaleSetProperties{...}`
3. `props.Properties.UpgradePolicy` is assigned to `&virtualmachinescalesets.UpgradePolicy{...}` 
4. Within UpgradePolicy, `RollingUpgradePolicy` is set by calling `ExpandVirtualMachineScaleSetRollingUpgradePolicy`

**Expand Function Evidence**:
```go
func ExpandVirtualMachineScaleSetRollingUpgradePolicy(input []interface{}, isZonal, overProvision bool) (*virtualmachinescalesets.RollingUpgradePolicy, error) {
	if len(input) == 0 {
		return nil, nil
	}

	raw := input[0].(map[string]interface{})

	rollingUpgradePolicy := &virtualmachinescalesets.RollingUpgradePolicy{
		MaxBatchInstancePercent:             pointer.To(int64(raw["max_batch_instance_percent"].(int))),
		MaxUnhealthyInstancePercent:         pointer.To(int64(raw["max_unhealthy_instance_percent"].(int))),
		MaxUnhealthyUpgradedInstancePercent: pointer.To(int64(raw["max_unhealthy_upgraded_instance_percent"].(int))),
		PauseTimeBetweenBatches:             pointer.To(raw["pause_time_between_batches"].(string)),
		PrioritizeUnhealthyInstances:        pointer.To(raw["prioritize_unhealthy_instances_enabled"].(bool)),
		MaxSurge:                            pointer.To(raw["maximum_surge_instances_enabled"].(bool)),
	}
	// ...
	return rollingUpgradePolicy, nil
}
```

**Verified Path**: `properties.upgradePolicy.rollingUpgradePolicy.maxBatchInstancePercent`

**Path Comparison**: ✅ Match - Predicted path matches implementation

## Provider Schema

**Source**: `query_golang_source_code(symbol="func", name="VirtualMachineScaleSetRollingUpgradePolicySchema")`

```go
func VirtualMachineScaleSetRollingUpgradePolicySchema() *pluginsdk.Schema {
	return &pluginsdk.Schema{
		Type:     pluginsdk.TypeList,
		Optional: true,
		ForceNew: true,
		MaxItems: 1,
		Elem: &pluginsdk.Resource{
			Schema: map[string]*pluginsdk.Schema{
				"max_batch_instance_percent": {
					Type:     pluginsdk.TypeInt,
					Required: true,
				},
				// ...
			},
		},
	}
}
```

**Field Properties**:
- Type: `TypeInt`
- Required: `true`
- ForceNew: `true` (at block level)
- No validation functions
- No DiffSuppressFunc

## Azure API Schema

**Resource Type**: `Microsoft.Compute/virtualMachineScaleSets@2024-11-01`

**Property Path**: `properties.upgradePolicy.rollingUpgradePolicy.maxBatchInstancePercent`

**Schema Type**: `Number` (all optional in Azure API schema for rollingUpgradePolicy)

**API Structure** (from full schema query):
```
upgradePolicy: ObjectWithOptionalAttrs({
  rollingUpgradePolicy: ObjectWithOptionalAttrs({
    maxBatchInstancePercent: Number,
    maxUnhealthyInstancePercent: Number,
    maxUnhealthyUpgradedInstancePercent: Number,
    pauseTimeBetweenBatches: String,
    enableCrossZoneUpgrade: Bool,
    maxSurge: Bool,
    prioritizeUnhealthyInstances: Bool,
    rollbackFailedInstancesOnPolicyBreach: Bool
  }, []string{...})
}, []string{...})
```

## Hidden Fields

None. The field is directly exposed in the provider schema.

## Mapping

**Terraform (snake_case)**: `max_batch_instance_percent`
**Azure API (camelCase)**: `maxBatchInstancePercent`

## Special Handling

### ForceNew Handling
- **Block-level ForceNew**: The entire `rolling_upgrade_policy` block has `ForceNew: true` (handled in Task #141)
- **Field-level**: No additional ForceNew handling needed for this field

### Validations
- **Provider validation**: None. The provider does not validate the value range for `max_batch_instance_percent`
- **Implementation**: No validation added (exact replication of provider behavior)
- **Note**: While the field represents a percentage, the provider doesn't enforce range constraints

### Type Conversion
- **Provider**: Reads as `int`, converts to `int64` with `pointer.To(int64(...))`
- **Shadow Module**: Direct assignment - Terraform will handle int to number conversion for JSON

### Parent Block Context
- Only set when parent block `rolling_upgrade_policy` is not null (conditional merge)
- Parent validation (Task #141) ensures rolling_upgrade_policy is only set when upgrade_mode is "Rolling"

## Deferred Work Completion

Checked `following.md` - no work deferred to Task #142.

## Critical Review & Edge Case Analysis

### Null Semantics
- **Provider behavior**: Field is `Required: true` within the block, cannot be null when block exists
- **Shadow implementation**: ✅ Correctly references required field from parent object
- **Edge case**: If parent block is null, entire upgradePolicy is omitted (handled by conditional merge)

### Boundary Conditions
- **Type**: Integer (number in JSON)
- **Range**: Provider has no validation, but logically represents a percentage
- **API acceptance**: Azure API will validate acceptable ranges server-side
- **Edge cases**: 
  - Value 0: Valid, means no parallel upgrades
  - Negative values: No provider validation, will fail at API level
  - Value > 100: No provider validation, may be accepted by API or fail

### Idempotency
- **Direct value assignment**: ✅ Idempotent
- **No transformation**: Value stored as-is
- **Re-apply**: Same value produces same output

### Safe References
- **Parent object check**: ✅ Field only accessed when `var.orchestrated_virtual_machine_scale_set_rolling_upgrade_policy != null`
- **Required field**: No null check needed - field is required in variable definition
- **Type safety**: ✅ Field defined as `number` in variable object type

### Integration Points
- **Depends on**: upgrade_mode = "Rolling" (validated in Task #141)
- **Block siblings**: Tasks #143-148 will add sibling fields
- **Conditional context**: All sibling fields share same parent null check

## Checklist

- ✅ Property in correct local (`body.properties.upgradePolicy.rollingUpgradePolicy`)
- ✅ All logic exactly replicated from provider (direct field assignment, no validations)
- ✅ Validations: None in provider, none added (exact replication)
- ✅ Hidden fields checked: None
- ✅ Deferred work: None deferred by this task, none deferred to this task
- ✅ Critical review completed
- ✅ Edge Case Analysis completed
- ✅ Proof created
- ✅ Track.md ready to update
- ✅ Self-Review: Only implemented Task #142 field, no other fields added

---

## ✅ CHECKER VALIDATION - APPROVED

**Checked by:** Checker Agent
**Date:** 2025-12-11
**Task:** #142 - rolling_upgrade_policy.max_batch_instance_percent

### Validation Results

✅ **ForceNew Logic:** Block-level ForceNew correctly handled by parent task (#141) - entire rolling_upgrade_policy object tracked in replace_triggers_external_values
✅ **Stable Keys:** ForceNew tracking uses stable key pattern with wrapped value
✅ **Phase Detection:** Field correctly placed in local.body (Create phase)
✅ **Type Conversion:** Correct direct assignment from Terraform number to Azure API Number
✅ **Null Handling:** Correctly propagates null semantics via parent block conditional merge
✅ **Validations:** None required - provider schema has no validation functions (exact replication)
✅ **Deferred Work Completion:** No deferred work for this task (checked following.md)
✅ **Deferred Work Recording:** No deferrals made by this task
✅ **Edge Cases:** All edge cases properly analyzed and handled
✅ **Shared Path Merge:** No duplicate keys - upgradePolicy appears only once in merge
✅ **Field Scope:** Only Task #142 field implemented, no out-of-scope additions

### Compliance Statement

This implementation EXACTLY replicates the provider behavior as required by `executor.md`. The field is:
- A required integer within the rolling_upgrade_policy block
- Directly assigned in Create phase without transformation
- Protected by block-level ForceNew (parent task responsibility)
- Has no validation requirements (matching provider schema)
- Correctly nested under upgradePolicy.rollingUpgradePolicy path

No deviations, simplifications, or "safer alternatives" were found. The implementation matches the provider's expand function exactly.

**Status:** APPROVED ✅

---
